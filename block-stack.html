<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Block Stack</title>
<style>
:root {
  --green: #0f0;
  --yellow: #ff0;
  --red: #f00;
  --bg: #000;
  --focus-outline: #0ff;
}

/* Accessibility and mobile improvements */
* {
  box-sizing: border-box;
}

body { 
  height: 100%; 
  background: var(--bg); 
  color: var(--green); 
  font-family: monospace; 
  display: flex; 
  justify-content: center; 
  align-items: flex-start;  
  margin: 0; 
  padding: 15px;
  font-size: 16px; /* Prevent zoom on mobile */
}

/* Focus styles for accessibility */
*:focus {
  outline: 2px solid var(--focus-outline);
  outline-offset: 2px;
}

/* Mobile-first responsive design */
#container {  
  height: 100%; 
  display: flex; 
  flex-direction: column;
  gap: 15px; 
  align-items: center;
  width: 100%;
  max-width: 800px;
}

  #gameNav, 
  #gameNav a {
    display: block;
    margin-top: 5px;
    text-transform: uppercase;
  color: var(--green);
    text-decoration: none;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

#gameNav a:hover,
#gameNav a:focus {
  background-color: rgba(0, 255, 0, 0.1);
  }

  #gameNav a.active {
  color: var(--yellow);
  font-weight: bold;
    text-decoration: underline;
  background-color: rgba(255, 255, 0, 0.1);
}

#tetris { 
  border: 4px solid var(--green); 
  height: auto;
  width: 100%;
  max-width: 240px;
  aspect-ratio: 240/480;
  image-rendering: pixelated; 
  background: var(--bg); 
  display: block;
  border-radius: 6px;
}

#sidebar { 
  display: flex; 
  flex-direction: column; 
  gap: 15px;
  width: 100%;
  max-width: 450px;
}

#title { 
  text-transform: uppercase; 
  font-size: clamp(1.5rem, 4vw, 2rem);
  color: var(--yellow); 
  text-shadow: 0 0 8px var(--red); 
  text-align: center;
  margin: 0;
}

#scoreboard { 
  border: 2px solid var(--green); 
  padding: 12px;
  border-radius: 6px;
}

.section-title { 
  color: var(--yellow); 
  margin-bottom: 8px; 
  font-weight: bold;
}

#instructions {
  line-height: 1.4;
}

/* Mobile controls */
.mobile-controls {
  display: none;
  gap: 10px;
  margin-top: 15px;
  justify-content: center;
  flex-wrap: wrap;
}

.mobile-btn {
  background: rgba(0, 255, 0, 0.2);
  border: 2px solid var(--green);
  color: var(--green);
  padding: 15px;
  border-radius: 8px;
  font-size: 1.2rem;
  font-family: monospace;
  cursor: pointer;
  user-select: none;
  touch-action: manipulation;
  min-width: 60px;
  transition: all 0.2s;
}

.mobile-btn:hover,
.mobile-btn:focus,
.mobile-btn:active {
  background: rgba(0, 255, 0, 0.3);
  transform: scale(1.05);
}

/* Responsive breakpoints */
@media (min-width: 768px) {
  #container {
    flex-direction: row;
    align-items: flex-start;
    gap: 20px;
    padding: 20px;
  }
  
  #tetris {
    height: 80vh;
    width: 240px;
  }
  
  #sidebar {
    width: 450px;
  }
  
  .mobile-controls {
    display: none;
  }
}

@media (max-width: 767px) {
  .mobile-controls {
    display: flex;
  }
  
  body {
    padding: 10px;
  }
  
  #tetris {
    max-width: 100vw;
    margin: 0 auto;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  :root {
    --green: #00ff00;
    --yellow: #ffff00;
    --red: #ff0000;
    --focus-outline: #ffffff;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Skip link for accessibility */
.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: var(--green);
  color: var(--bg);
  padding: 8px;
  text-decoration: none;
  border-radius: 4px;
  z-index: 1001;
  transition: top 0.3s;
}

.skip-link:focus {
  top: 6px;
}

/* Screen reader support */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
</style>
</head>
<body>
<!-- Skip to main content link for accessibility -->
<a href="#tetris" class="skip-link">Skip to game</a>

<div id="container">
  <nav id="gameNav" style="padding:10px; background:#111; color:#0f0; font-family:monospace;">
    <strong>Games:</strong>
  </nav>
  <canvas id="tetris" width="240" height="480" role="img" aria-label="Block Stack game area" tabindex="0"></canvas>
  <div id="sidebar">
    <h1 id="title">BLOCK STACK</h1>
    <div id="scoreboard" role="region" aria-label="Game Score">
      <div class="section-title">SCORE</div>
      <div id="score" aria-live="polite">0</div>
      <div class="section-title">LINES</div>
      <div id="lines" aria-live="polite">0</div>
      <div class="section-title">LEVEL</div>
      <div id="level" aria-live="polite">1</div>
    </div>
    <div id="instructions" role="region" aria-label="Game Controls">
      <div class="section-title">CONTROLS</div>
      <div role="list">
        <div role="listitem">‚Üê / ‚Üí: Move</div>
        <div role="listitem">‚Üì: Soft drop</div>
        <div role="listitem">‚Üë / X: Rotate CW</div>
        <div role="listitem">Z: Rotate CCW</div>
        <div role="listitem">Space: Hard drop</div>
        <div role="listitem">Shift: Hold piece</div>
        <div role="listitem">P: Pause</div>
        <div role="listitem">R: Reset</div>
      </div>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <button class="mobile-btn" id="leftBtn" aria-label="Move Left">‚Üê</button>
      <button class="mobile-btn" id="rightBtn" aria-label="Move Right">‚Üí</button>
      <button class="mobile-btn" id="downBtn" aria-label="Soft Drop">‚Üì</button>
      <button class="mobile-btn" id="rotateBtn" aria-label="Rotate Clockwise">‚Üª</button>
      <button class="mobile-btn" id="hardDropBtn" aria-label="Hard Drop">‚¨á</button>
      <button class="mobile-btn" id="pauseBtn" aria-label="Pause/Resume">‚è∏</button>
      <button class="mobile-btn" id="resetBtn" aria-label="Reset Game">üîÑ</button>
    </div>
  </div>
</div>
<script src="navigation.js"></script>
<script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
context.scale(20, 20);

const colors = [null,'#FF0D72','#0DC2FF','#0DFF72','#F538FF','#FF8E0D','#FFE138','#3877FF'];

function createMatrix(w,h){const matrix=[];while(h--){matrix.push(new Array(w).fill(0));}return matrix;}
function createPiece(type){if(type==='T')return[[0,1,0],[1,1,1],[0,0,0]];
else if(type==='O')return[[2,2],[2,2]];
else if(type==='L')return[[0,3,0],[0,3,0],[0,3,3]];
else if(type==='J')return[[0,4,0],[0,4,0],[4,4,0]];
else if(type==='I')return[[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
else if(type==='S')return[[0,6,6],[6,6,0],[0,0,0]];
else if(type==='Z')return[[7,7,0],[0,7,7],[0,0,0]];}

function drawMatrix(matrix,offset){matrix.forEach((row,y)=>{row.forEach((value,x)=>{if(value!==0){context.fillStyle=value===8?'#fff':colors[value];context.fillRect(x+offset.x,y+offset.y,1,1);}});});}

function draw(){context.fillStyle='#000';context.fillRect(0,0,canvas.width,canvas.height);drawMatrix(arena,{x:0,y:0});drawMatrix(player.matrix,player.pos);}



function merge(arena,player){player.matrix.forEach((row,y)=>{row.forEach((value,x)=>{if(value!==0)arena[y+player.pos.y][x+player.pos.x]=value;});});}

function collide(arena,player){const m=player.matrix;const o=player.pos;for(let y=0;y<m.length;++y){for(let x=0;x<m[y].length;++x){if(m[y][x]!==0&&(arena[y+o.y]&&arena[y+o.y][x+o.x])!==0){return true;}}}return false;}

function arenaSweep(){let rowCount=1;outer:for(let y=arena.length-1;y>=0;--y){for(let x=0;x<arena[y].length;++x){if(arena[y][x]===0)continue outer;}let flashCount=0;const flashInterval=setInterval(()=>{for(let x=0;x<arena[y].length;x++){arena[y][x]=arena[y][x]?0:8;}draw();flashCount++;if(flashCount>5){clearInterval(flashInterval);arena.splice(y,1);arena.unshift(new Array(arena[0].length).fill(0));y++;player.score+=rowCount*10;lines+=1;rowCount*=2;updateScore();}},50);}}

function playerDrop(){player.pos.y++;if(collide(arena,player)){player.pos.y--;merge(arena,player);playerReset();arenaSweep();updateScore();}dropCounter=0;}
function playerHardDrop(){while(!collide(arena,player)){player.pos.y++;}player.pos.y--;merge(arena,player);playerReset();arenaSweep();updateScore();dropCounter=0;}
function playerMove(dir){player.pos.x+=dir;if(collide(arena,player)){player.pos.x-=dir;}}
function playerReset(){const pieces='TJLOSZI';player.matrix=createPiece(pieces[pieces.length*Math.random()|0]);player.pos.y=0;player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);canHold=true;if(collide(arena,player)){arena.forEach(row=>row.fill(0));player.score=0;lines=0;level=1;updateScore();}}
function playerRotate(dir){const pos=player.pos.x;let offset=1;rotate(player.matrix,dir);while(collide(arena,player)){player.pos.x+=offset;offset=-(offset+(offset>0?1:-1));if(offset>player.matrix[0].length){rotate(player.matrix,-dir);player.pos.x=pos;return;}}}
function rotate(matrix,dir){for(let y=0;y<matrix.length;++y){for(let x=0;x<y;++x){[matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];}}if(dir>0){matrix.forEach(row=>row.reverse());}else{matrix.reverse();}}

let dropCounter=0,dropInterval=1000,lastTime=0,paused=false,gameOver=false,level=1,score=0,lines=0,holdPiece=null,canHold=true;
const arena=createMatrix(12,20);
const player={pos:{x:0,y:0},matrix:null,score:0};

/* ===== Mobile Controls ===== */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const downBtn = document.getElementById('downBtn');
const rotateBtn = document.getElementById('rotateBtn');
const hardDropBtn = document.getElementById('hardDropBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

// Mobile button handlers
leftBtn.addEventListener('click', () => {
  playerMove(-1);
});

rightBtn.addEventListener('click', () => {
  playerMove(1);
});

downBtn.addEventListener('click', () => {
  playerDrop();
});

rotateBtn.addEventListener('click', () => {
  playerRotate(1);
});

hardDropBtn.addEventListener('click', () => {
  playerHardDrop();
});

pauseBtn.addEventListener('click', () => {
  paused = !paused;
  pauseBtn.textContent = paused ? '‚ñ∂' : '‚è∏';
  if(!paused) {
    lastTime = performance.now();
    update();
  }
});

resetBtn.addEventListener('click', () => {
  arena.forEach(row => row.fill(0));
  score = 0;
  lines = 0;
  level = 1;
  playerReset();
  updateScore();
  paused = false;
  gameOver = false;
  lastTime = performance.now();
  update();
});

// Touch support for mobile
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
  touchStartTime = Date.now();
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  const touchDuration = Date.now() - touchStartTime;
  
  // Check if it's a tap (short duration, small movement)
  if (touchDuration < 200 && Math.abs(deltaX) < 10 && Math.abs(deltaY) < 10) {
    // Tap detected - rotate the piece
    playerRotate(1);
  } else if (Math.abs(deltaX) > 30 || Math.abs(deltaY) > 30) {
    // Swipe threshold
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      // Horizontal swipe
      if (deltaX > 0) {
        playerMove(1);
      } else {
        playerMove(-1);
      }
    } else {
      // Vertical swipe
      if (deltaY > 0) {
        playerDrop();
      } else {
        playerRotate(1);
      }
    }
  }
}, { passive: false });

document.addEventListener('keydown',event=>{switch(event.code){case'ArrowLeft':playerMove(-1);break;case'ArrowRight':playerMove(1);break;case'ArrowDown':playerDrop();break;case'ArrowUp':case'KeyX':playerRotate(1);break;case'KeyZ':playerRotate(-1);break;case'Space':playerHardDrop();break;case'KeyP':paused=!paused;if(!paused){lastTime=performance.now();update();}break;case'KeyR':arena.forEach(row=>row.fill(0));score=0;lines=0;level=1;playerReset();updateScore();paused=false;gameOver=false;lastTime=performance.now();update();break;}});

function updateScore(){document.getElementById('score').textContent=player.score;document.getElementById('lines').textContent=lines;document.getElementById('level').textContent=level;}

function update(time=0){if(paused||gameOver)return;const deltaTime=time-lastTime;lastTime=time;dropCounter+=deltaTime;if(dropCounter>dropInterval)playerDrop();draw();requestAnimationFrame(update);}

playerReset();updateScore();update();
</script>
</body>
</html>
