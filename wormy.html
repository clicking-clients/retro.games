<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Worm Trail</title>
<style>
:root {
  --green: #0f0;
  --yellow: #ff0;
  --red: #f00;
  --bg: #000;
  --focus-outline: #0ff;
}

/* Accessibility and mobile improvements */
* {
  box-sizing: border-box;
}

body { 
  background: var(--bg); 
  color: var(--green); 
  font-family: monospace; 
  display: flex; 
  justify-content: center; 
  align-items: flex-start; 
  height: 100%; 
  margin: 0; 
  padding: 15px;
  font-size: 16px; /* Prevent zoom on mobile */
}

/* Focus styles for accessibility */
*:focus {
  outline: 2px solid var(--focus-outline);
  outline-offset: 2px;
}

/* Mobile-first responsive design */
#container { 
  min-height: 100vh;
  display: flex; 
  flex-direction: column;
  gap: 15px; 
  align-items: center;
  width: 100%;
  max-width: 800px;
}

  #gameNav, 
#gameNav a {
  display: block;
  margin-top: 5px;
  text-transform: uppercase;
  color: var(--green);
  text-decoration: none;
  padding: 8px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

#gameNav a:hover,
#gameNav a:focus {
  background-color: rgba(0, 255, 0, 0.1);
}

#gameNav a.active {
  color: var(--yellow);
  font-weight: bold;
  text-decoration: underline;
  background-color: rgba(255, 255, 0, 0.1);
}

#snakeGame { 
  border: 4px solid var(--green); 
  height: auto;
  width: 100%;
  max-width: 240px;
  aspect-ratio: 240/480;
  image-rendering: pixelated; 
  background: var(--bg); 
  display: block;
  border-radius: 6px;
}

#sidebar { 
  display: flex; 
  flex-direction: column; 
  gap: 15px;
  width: 100%;
  max-width: 450px;
}

#title { 
  text-transform: uppercase; 
  font-size: clamp(1.5rem, 4vw, 2rem);
  color: var(--yellow); 
  text-shadow: 0 0 8px var(--red); 
  text-align: center;
  margin: 0;
}

#scoreboard { 
  border: 2px solid var(--green); 
  padding: 12px;
  border-radius: 6px;
}

.section-title { 
  color: var(--yellow); 
  margin-bottom: 8px; 
  font-weight: bold;
}

#instructions {
  line-height: 1.4;
}

#rules { 
  color: var(--green); 
  margin-top: 12px; 
  font-size: 0.9rem;
  line-height: 1.4;
}

#easyMode {
  accent-color: var(--green);
  margin-right: 8px;
}

/* Mobile controls */
.mobile-controls {
  display: none;
  gap: 10px;
  margin-top: 15px;
  justify-content: center;
  flex-wrap: wrap;
}

.mobile-btn {
  background: rgba(0, 255, 0, 0.2);
  border: 2px solid var(--green);
  color: var(--green);
  padding: 15px;
  border-radius: 8px;
  font-size: 1.2rem;
  font-family: monospace;
  cursor: pointer;
  user-select: none;
  touch-action: manipulation;
  min-width: 60px;
  transition: all 0.2s;
}

.mobile-btn:hover,
.mobile-btn:focus,
.mobile-btn:active {
  background: rgba(0, 255, 0, 0.3);
  transform: scale(1.05);
}

/* Responsive breakpoints */
@media (min-width: 768px) {
  #container {
    flex-direction: row;
    align-items: flex-start;
    gap: 20px;
    padding: 20px;
  }
  
  #snakeGame {
    height: 80vh;
    width: 240px;
  }
  
  #sidebar {
    width: 450px;
  }
  
  .mobile-controls {
    display: none;
  }
}

@media (max-width: 767px) {
  .mobile-controls {
    display: flex;
  }
  
  body {
    padding: 10px;
  }
  
  #snakeGame {
    max-width: 100vw;
    margin: 0 auto;
  }
  
  #title {
    margin-top: 10px;
    margin-bottom: 10px;
  }
  
  #sidebar {
    order: 3;
  }
  
  #snakeGame {
    order: 2;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  :root {
    --green: #00ff00;
    --yellow: #ffff00;
    --red: #ff0000;
    --focus-outline: #ffffff;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Skip link for accessibility */
.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: var(--green);
  color: var(--bg);
  padding: 8px;
  text-decoration: none;
  border-radius: 4px;
  z-index: 1001;
  transition: top 0.3s;
}

.skip-link:focus {
  top: 6px;
}

/* Screen reader support */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}
</style>
</head>
<body>
<!-- Skip to main content link for accessibility -->
<a href="#snakeGame" class="skip-link">Skip to game</a>

<div id="container">
    <nav id="gameNav" style="padding:10px; background:#111; color:#0f0; font-family:monospace;">
    <strong>Games:</strong>
  </nav>
  <h1 id="title">Worm Trail</h1>
  <canvas id="snakeGame" width="240" height="480" role="img" aria-label="Worm Trail game area" tabindex="0"></canvas>
  <div id="sidebar">
    <div id="scoreboard" role="region" aria-label="Game Score">
      <div class="section-title">SCORE</div>
      <div id="score" aria-live="polite">0</div>
    </div>
    <div id="instructions" role="region" aria-label="Game Controls">
      <div class="section-title">CONTROLS</div>
      <div role="list">
        <div role="listitem">‚Üê / ‚Üí: Move Left/Right</div>
        <div role="listitem">‚Üë / ‚Üì: Move Up/Down</div>
        <div role="listitem">P: Pause</div>
        <div role="listitem">R: Reset</div>
      </div>
      <div id="rules" role="region" aria-label="Game Rules">
        <div class="section-title">RULES</div>
        <div role="list">
          <div role="listitem">Eat the red fruit to grow.</div>
          <div role="listitem">Avoid hitting walls or your own body.</div>
          <div role="listitem">In easy mode, you can reverse direction onto your head (not body).</div>
        </div>
      </div>
    </div>
    <div>
      <label for="easyMode"><input type="checkbox" id="easyMode" /> Easy Mode</label>
    </div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
      <button class="mobile-btn" id="leftBtn" aria-label="Move Left">‚Üê</button>
      <button class="mobile-btn" id="rightBtn" aria-label="Move Right">‚Üí</button>
      <button class="mobile-btn" id="upBtn" aria-label="Move Up">‚Üë</button>
      <button class="mobile-btn" id="downBtn" aria-label="Move Down">‚Üì</button>
      <button class="mobile-btn" id="pauseBtn" aria-label="Pause/Resume">‚è∏</button>
      <button class="mobile-btn" id="resetBtn" aria-label="Reset Game">üîÑ</button>
    </div>
  </div>
</div>
<script src="navigation.js"></script>
<script>
const canvas = document.getElementById('snakeGame');
const context = canvas.getContext('2d');
const scale = 20;
const rows = canvas.height / scale;
const cols = canvas.width / scale;
let snake;
let fruit;
let score = 0;
let paused = false;
let gameOver = false;
let easyMode = false;

class Snake {
    constructor() {
        this.body = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
        this.dx = 0;
        this.dy = 0;
        this.nextDx = 0;
        this.nextDy = 0;
    }
    update() {
        this.dx = this.nextDx;
        this.dy = this.nextDy;
        const head = {x: this.body[0].x + this.dx, y: this.body[0].y + this.dy};
        this.body.unshift(head);
        if(head.x === fruit.x && head.y === fruit.y) {
            score += 10;
            spawnFruit();
        } else {
            this.body.pop();
        }
        if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows || (!easyMode && this.body.slice(1).some(seg => seg.x === head.x && seg.y === head.y))) {
            gameOver = true;
        }
    }
    draw() {
        context.fillStyle = '#0f0';
        this.body.forEach(seg => {
            context.fillRect(seg.x, seg.y, 1, 1);
            context.strokeStyle = '#000';
            context.lineWidth = 0.05;
            context.strokeRect(seg.x, seg.y, 1, 1);
        });
    }
    setDirection(x, y) {
        if(!easyMode) {
            if(this.dx + x === 0 && this.dy + y === 0) return;
        }
        this.nextDx = x;
        this.nextDy = y;
    }
}

function spawnFruit() {
    fruit = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
}

function drawFruit() {
    context.fillStyle = '#F00';
    context.fillRect(fruit.x, fruit.y, 1, 1);
    context.strokeStyle = '#000';
    context.lineWidth = 0.05;
    context.strokeRect(fruit.x, fruit.y, 1, 1);
}

function draw() {
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.save();
    context.scale(scale, scale);
    snake.draw();
    drawFruit();
    if(gameOver) {
        context.fillStyle = '#F00';
        context.font = '1.5px monospace';
        context.textAlign = 'center';
        context.fillText('GAME OVER', cols/2, rows/2);
    }
    context.restore();
}

// Global variable to track the flash interval
let gameOverFlashInterval = null;

function update() {
    if(paused) return;
    if(!gameOver) snake.update();
    draw();
    document.getElementById('score').textContent = score;
    if(!gameOver) {
        // Clear any existing flash interval when game is not over
        if (gameOverFlashInterval) {
            clearInterval(gameOverFlashInterval);
            gameOverFlashInterval = null;
        }
        setTimeout(update, 150);
    } else {
        // Only create flash interval if one doesn't exist
        if (!gameOverFlashInterval) {
            let flash = true;
            gameOverFlashInterval = setInterval(() => {
                draw();
                context.save();
                context.scale(scale, scale);
                if(flash) {
                    context.fillStyle = '#F00';
                    context.font = '1.5px monospace';
                    context.textAlign = 'center';
                    context.fillText('GAME OVER', cols/2, rows/2);
                }
                context.restore();
                flash = !flash;
            }, 500);
        }
    }
}

/* ===== Mobile Controls ===== */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');

// Mobile button handlers
leftBtn.addEventListener('click', () => {
  snake.setDirection(-1, 0);
});

rightBtn.addEventListener('click', () => {
  snake.setDirection(1, 0);
});

upBtn.addEventListener('click', () => {
  snake.setDirection(0, -1);
});

downBtn.addEventListener('click', () => {
  snake.setDirection(0, 1);
});

pauseBtn.addEventListener('click', () => {
  paused = !paused;
  pauseBtn.textContent = paused ? '‚ñ∂' : '‚è∏';
  if(!paused) update();
});

resetBtn.addEventListener('click', () => {
  // Clear the flash interval when resetting
  if (gameOverFlashInterval) {
    clearInterval(gameOverFlashInterval);
    gameOverFlashInterval = null;
  }
  score = 0;
  snake = new Snake();
  spawnFruit();
  gameOver = false;
  paused = false;
  update();
});

// Touch support for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  const deltaX = touch.clientX - touchStartX;
  const deltaY = touch.clientY - touchStartY;
  
  // Swipe threshold
  if (Math.abs(deltaX) > 30 || Math.abs(deltaY) > 30) {
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      // Horizontal swipe
      if (deltaX > 0) {
        snake.setDirection(1, 0);
      } else {
        snake.setDirection(-1, 0);
      }
    } else {
      // Vertical swipe
      if (deltaY > 0) {
        snake.setDirection(0, 1);
      } else {
        snake.setDirection(0, -1);
      }
    }
  }
}, { passive: false });

document.getElementById('easyMode').addEventListener('change', e => easyMode = e.target.checked);

document.addEventListener('keydown', event => {
    switch(event.code) {
        case 'ArrowLeft': snake.setDirection(-1,0); break;
        case 'ArrowRight': snake.setDirection(1,0); break;
        case 'ArrowUp': snake.setDirection(0,-1); break;
        case 'ArrowDown': snake.setDirection(0,1); break;
        case 'KeyP': paused = !paused; if(!paused) update(); break;
        case 'KeyR': score = 0; snake = new Snake(); spawnFruit(); gameOver = false; paused = false; update(); break;
    }
});

snake = new Snake();
spawnFruit();
update();
</script>
</body>
</html>
