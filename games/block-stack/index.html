<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Block Stack - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with block-stack config
const gameConfig = GAME_CONFIGS['block-stack'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const BLOCK_SIZE = 20;
const BOARD_WIDTH = 12;
const BOARD_HEIGHT = 20;
const COLORS = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

// Game variables
let board = [];
let currentPiece = null;
let score = 0;
let level = 1;
let linesCleared = 0;
let gameRunning = true;
let gameOver = false;
let dropTime = 0;
let dropInterval = 1000; // milliseconds

// Initialize board
function initBoard() {
    board = [];
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        board[y] = [];
        for (let x = 0; x < BOARD_WIDTH; x++) {
            board[y][x] = 0;
        }
    }
}

// Tetromino shapes
const SHAPES = [
    // I piece
    [[1, 1, 1, 1]],
    // O piece
    [[1, 1], [1, 1]],
    // T piece
    [[0, 1, 0], [1, 1, 1]],
    // S piece
    [[0, 1, 1], [1, 1, 0]],
    // Z piece
    [[1, 1, 0], [0, 1, 1]],
    // J piece
    [[1, 0, 0], [1, 1, 1]],
    // L piece
    [[0, 0, 1], [1, 1, 1]]
];

// Create new piece
function createPiece() {
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    const shape = SHAPES[shapeIndex];
    const colorIndex = Math.floor(Math.random() * COLORS.length);
    
    return {
        shape: shape,
        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),
        y: 0,
        color: COLORS[colorIndex]
    };
}

// Check if piece can move to position
function canMove(piece, dx, dy, newShape = null) {
    const shape = newShape || piece.shape;
    
    for (let y = 0; y < shape.length; y++) {
        for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
                const newX = piece.x + x + dx;
                const newY = piece.y + y + dy;
                
                if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) {
                    return false;
                }
                
                if (newY >= 0 && board[newY][newX]) {
                    return false;
                }
            }
        }
    }
    return true;
}

// Rotate piece
function rotatePiece(piece) {
    const rotated = [];
    const rows = piece.shape.length;
    const cols = piece.shape[0].length;
    
    for (let x = 0; x < cols; x++) {
        rotated[x] = [];
        for (let y = rows - 1; y >= 0; y--) {
            rotated[x][rows - 1 - y] = piece.shape[y][x];
        }
    }
    
    if (canMove(piece, 0, 0, rotated)) {
        piece.shape = rotated;
    }
}

// Place piece on board
function placePiece(piece) {
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
                const boardY = piece.y + y;
                const boardX = piece.x + x;
                if (boardY >= 0) {
                    board[boardY][boardX] = piece.color;
                }
            }
        }
    }
}

// Clear completed lines
function clearLines() {
    let linesToClear = 0;
    
    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
        let lineFull = true;
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (!board[y][x]) {
                lineFull = false;
                break;
            }
        }
        
        if (lineFull) {
            board.splice(y, 1);
            board.unshift(new Array(BOARD_WIDTH).fill(0));
            linesToClear++;
            y++; // Check the same line again
        }
    }
    
    if (linesToClear > 0) {
        linesCleared += linesToClear;
        score += linesToClear * 100 * level;
        gameContainer.updateScore(score);
        
        // Level up every 10 lines
        if (Math.floor(linesCleared / 10) > level - 1) {
            level++;
            dropInterval = Math.max(100, dropInterval - 100);
        }
    }
}

// Check game over
function checkGameOver() {
    for (let x = 0; x < BOARD_WIDTH; x++) {
        if (board[0][x]) {
            gameOver = true;
            gameRunning = false;
            return;
        }
    }
}

// Draw functions
function drawBoard() {
    for (let y = 0; y < BOARD_HEIGHT; y++) {
        for (let x = 0; x < BOARD_WIDTH; x++) {
            if (board[y][x]) {
                ctx.fillStyle = board[y][x];
                ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
        }
    }
}

function drawPiece(piece) {
    if (!piece) return;
    
    ctx.fillStyle = piece.color;
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
                ctx.fillRect(
                    (piece.x + x) * BLOCK_SIZE,
                    (piece.y + y) * BLOCK_SIZE,
                    BLOCK_SIZE,
                    BLOCK_SIZE
                );
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(
                    (piece.x + x) * BLOCK_SIZE,
                    (piece.y + y) * BLOCK_SIZE,
                    BLOCK_SIZE,
                    BLOCK_SIZE
                );
            }
        }
    }
}

function drawUI() {
    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 20);
    ctx.fillText(`Level: ${level}`, 10, 40);
    ctx.fillText(`Lines: ${linesCleared}`, 10, 60);
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#f00';
    ctx.font = '32px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
    
    ctx.fillStyle = '#fff';
    ctx.font = '20px monospace';
    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2);
    ctx.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 50);
}

// Game loop
function gameLoop(timestamp) {
    if (!gameRunning) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw game elements
    drawBoard();
    if (currentPiece) {
        drawPiece(currentPiece);
    }
    drawUI();
    
    if (gameOver) {
        drawGameOver();
        return;
    }
    
    // Handle piece dropping
    if (timestamp - dropTime > dropInterval) {
        if (canMove(currentPiece, 0, 1)) {
            currentPiece.y++;
        } else {
            placePiece(currentPiece);
            clearLines();
            checkGameOver();
            
            if (!gameOver) {
                currentPiece = createPiece();
                if (!canMove(currentPiece, 0, 0)) {
                    gameOver = true;
                }
            }
        }
        dropTime = timestamp;
    }
    
    requestAnimationFrame(gameLoop);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    if (gameOver) {
        if (e.key === 'r' || e.key === 'R') {
            restartGame();
        }
        return;
    }
    
    if (!currentPiece) return;
    
    switch(e.key) {
        case 'ArrowLeft':
            if (canMove(currentPiece, -1, 0)) {
                currentPiece.x--;
            }
            break;
        case 'ArrowRight':
            if (canMove(currentPiece, 1, 0)) {
                currentPiece.x++;
            }
            break;
        case 'ArrowDown':
            if (canMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 1;
                gameContainer.updateScore(score);
            }
            break;
        case 'ArrowUp':
        case ' ':
            rotatePiece(currentPiece);
            break;
        case 'p':
        case 'P':
            gameRunning = !gameRunning;
            if (gameRunning) gameLoop();
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
    touchStartY = touch.clientY - rect.top;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 30) {
            // Swipe right
            if (canMove(currentPiece, 1, 0)) {
                currentPiece.x++;
            }
        } else if (deltaX < -30) {
            // Swipe left
            if (canMove(currentPiece, -1, 0)) {
                currentPiece.x--;
            }
        }
    } else {
        if (deltaY > 30) {
            // Swipe down
            if (canMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 1;
                gameContainer.updateScore(score);
            }
        } else if (deltaY < -30) {
            // Swipe up
            rotatePiece(currentPiece);
        }
    }
});

function restartGame() {
    score = 0;
    level = 1;
    linesCleared = 0;
    gameOver = false;
    gameRunning = true;
    dropInterval = 1000;
    gameContainer.updateScore(score);
    initBoard();
    currentPiece = createPiece();
    dropTime = performance.now();
    gameLoop();
}

// Initialize game
initBoard();
currentPiece = createPiece();
dropTime = performance.now();
gameLoop();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { gameRunning = false; },
    resume: () => { gameRunning = true; gameLoop(); },
    restart: restartGame
};

console.log('Block Stack game initialized with universal system');
</script>
</body>
</html>
