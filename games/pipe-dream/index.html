<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pipe Dream - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with pipe-dream config
const gameConfig = GAME_CONFIGS['pipe-dream'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const GRID_SIZE = 40;
const GRID_WIDTH = 20;
const GRID_HEIGHT = 15;

// Game state management using a more efficient approach
class GameState {
    constructor() {
        this.gameMode = 'practice'; // 'adventure', 'practice', 'timed'
        this.difficulty = 'basic'; // 'basic', 'easy', 'medium', 'hard'
        this.gridSize = '8x5'; // Default grid size
        this.operations = ['+']; // Available operations
        this.allowNegatives = false;
        this.showPrecedenceHints = true;
        
        this.level = 1;
        this.score = 0;
        this.stars = 0;
        this.pressure = 12;
        this.maxPressure = 100;
        this.gameActive = true;
        
        this.pipes = [];
        this.connectedPipes = [];
        this.draggedPipe = null;
        this.draggedPlacedPipe = null;
        this.pipeHistory = [];
        
        this.startPipe = null;
        this.answerPipes = [];
        this.obstacles = [];
        this.inventory = [];
        
        this.currentExpression = null;
        this.correctAnswer = null;
        this.decoyAnswers = [];
        
        this.pressureTimer = null;
        this.lastFrameTime = 0;
    }
    
    // Efficient configuration getter with caching
    getGameConfig() {
        const configs = {
            basic: {
                maxPathLength: 6,
                answerPipeCount: 2,
                allowCrossings: false,
                pressureRate: 0.3,
                maxNumber: 5,
                operations: ['+']
            },
            easy: {
                maxPathLength: 8,
                answerPipeCount: 3,
                allowCrossings: false,
                pressureRate: 0.5,
                maxNumber: 10,
                operations: ['+', '-']
            },
            medium: {
                maxPathLength: 12,
                answerPipeCount: 4,
                allowCrossings: false,
                pressureRate: 1.0,
                maxNumber: 15,
                operations: ['+', '-', '×']
            },
            hard: {
                maxPathLength: 16,
                answerPipeCount: 5,
                allowCrossings: true,
                pressureRate: 2.0,
                maxNumber: 20,
                operations: ['+', '-', '×', '÷']
            }
        };
        return configs[this.difficulty] || configs.basic;
    }
    
    // Reset game state efficiently
    reset() {
        this.level = 1;
        this.score = 0;
        this.stars = 0;
        this.pressure = 12;
        this.pipes = [];
        this.connectedPipes = [];
        this.pipeHistory = [];
        this.answerPipes = [];
        this.inventory = [];
        
        if (this.pressureTimer) {
            clearInterval(this.pressureTimer);
            this.pressureTimer = null;
        }
    }
}

// Math expression generator with improved efficiency
class MathExpressionGenerator {
    static generateExpression(difficulty, operations, allowNegatives) {
        const config = this.getDifficultyConfig(difficulty);
        
        if (difficulty === 'basic') {
            return this.generateBasicExpression(config);
        } else if (difficulty === 'easy') {
            return this.generateSimpleExpression(config, operations);
        } else if (difficulty === 'medium') {
            return this.generateMediumExpression(config, operations);
        } else {
            return this.generateHardExpression(config, operations);
        }
    }
    
    static getDifficultyConfig(difficulty) {
        const configs = {
            basic: { maxNumber: 5, allowNegatives: false },
            easy: { maxNumber: 10, allowNegatives: false },
            medium: { maxNumber: 15, allowNegatives: true },
            hard: { maxNumber: 20, allowNegatives: true }
        };
        return configs[difficulty] || configs.basic;
    }
    
    static generateBasicExpression(config) {
        const a = Math.floor(Math.random() * config.maxNumber) + 1;
        const b = Math.floor(Math.random() * config.maxNumber) + 1;
        return { a, b, op: '+', type: 'simple', expression: `${a} + ${b}` };
    }
    
    static generateSimpleExpression(config, operations) {
        const op = operations[Math.floor(Math.random() * operations.length)];
        const a = this.getRandomNumber(op, 0, config.maxNumber);
        const b = this.getRandomNumber(op, 0, config.maxNumber);
        return { a, b, op, type: 'simple', expression: `${a} ${op} ${b}` };
    }
    
    static generateMediumExpression(config, operations) {
        const availableOps = operations.filter(op => op !== '÷');
        if (availableOps.length < 2) {
            return this.generateSimpleExpression(config, operations);
        }
        
        const op1 = availableOps[Math.floor(Math.random() * availableOps.length)];
        const op2 = availableOps[Math.floor(Math.random() * availableOps.length)];
        const a = this.getRandomNumber(op1, 0, config.maxNumber);
        const b = this.getRandomNumber(op2, 0, config.maxNumber);
        const c = this.getRandomNumber(op2, 0, config.maxNumber);
        
        // Randomly choose expression structure
        if (Math.random() < 0.5) {
            return { a, b, c, op1, op2, type: 'compound', expression: `(${a} ${op1} ${b}) ${op2} ${c}` };
        } else {
            return { a, b, c, op1, op2, type: 'compound', expression: `${a} ${op1} (${b} ${op2} ${c})` };
        }
    }
    
    static generateHardExpression(config, operations) {
        // Complex expressions with multiple operations
        const op1 = operations[Math.floor(Math.random() * operations.length)];
        const op2 = operations[Math.floor(Math.random() * operations.length)];
        const op3 = operations[Math.floor(Math.random() * operations.length)];
        
        const a = this.getRandomNumber(op1, 0, config.maxNumber);
        const b = this.getRandomNumber(op2, 0, config.maxNumber);
        const c = this.getRandomNumber(op3, 0, config.maxNumber);
        const d = this.getRandomNumber(op3, 0, config.maxNumber);
        
        return { a, b, c, d, op1, op2, op3, type: 'complex', expression: `(${a} ${op1} ${b}) ${op2} (${c} ${op3} ${d})` };
    }
    
    static getRandomNumber(operation, min, max) {
        let num = Math.floor(Math.random() * (max - min + 1)) + min;
        
        // Ensure valid numbers for division
        if (operation === '÷' && num === 0) {
            num = Math.floor(Math.random() * (max - 1)) + 1;
        }
        
        return num;
    }
    
    static evaluateExpression(expression) {
        try {
            // Replace × with * for evaluation
            const evalExpression = expression.expression.replace(/×/g, '*').replace(/÷/g, '/');
            return eval(evalExpression);
        } catch (e) {
            console.error('Expression evaluation error:', e);
            return 0;
        }
    }
}

// Pipe system with improved efficiency
class PipeSystem {
    constructor() {
        this.pipeTypes = {
            straight: { connections: ['top', 'bottom'], rotation: 0, symbol: '│' },
            corner: { connections: ['top', 'right'], rotation: 0, symbol: '┌' },
            t: { connections: ['top', 'right', 'bottom'], rotation: 0, symbol: '├' },
            cross: { connections: ['top', 'right', 'bottom', 'left'], rotation: 0, symbol: '┼' }
        };
    }
    
    generatePipeInventory(count) {
        const inventory = [];
        const types = Object.keys(this.pipeTypes);
        
        for (let i = 0; i < count; i++) {
            const type = types[Math.floor(Math.random() * types.length)];
            const rotation = Math.floor(Math.random() * 4) * 90;
            inventory.push({ type, rotation, id: i });
        }
        
        return inventory;
    }
    
    getPipeConnections(pipeType, rotation) {
        const baseConnections = this.pipeTypes[pipeType].connections;
        const rotatedConnections = [];
        
        for (const connection of baseConnections) {
            let rotatedConnection = connection;
            
            // Apply rotation efficiently
            for (let i = 0; i < rotation / 90; i++) {
                rotatedConnection = this.rotateConnection(rotatedConnection);
            }
            
            rotatedConnections.push(rotatedConnection);
        }
        
        return rotatedConnections;
    }
    
    rotateConnection(connection) {
        const rotations = {
            'top': 'right',
            'right': 'bottom',
            'bottom': 'left',
            'left': 'top'
        };
        return rotations[connection] || connection;
    }
}

// Water flow simulation with improved physics
class WaterFlowSimulator {
    constructor() {
        this.waterParticles = [];
        this.flowSpeed = 2;
        this.particleLife = 100;
    }
    
    addWaterSource(x, y) {
        this.waterParticles.push({
            x, y, life: this.particleLife, velocity: { x: 0, y: this.flowSpeed }
        });
    }
    
    update() {
        for (let i = this.waterParticles.length - 1; i >= 0; i--) {
            const particle = this.waterParticles[i];
            
            // Update position
            particle.x += particle.velocity.x;
            particle.y += particle.velocity.y;
            particle.life--;
            
            // Remove dead particles
            if (particle.life <= 0) {
                this.waterParticles.splice(i, 1);
            }
        }
    }
    
    draw(ctx) {
        ctx.fillStyle = '#00f';
        ctx.globalAlpha = 0.7;
        
        for (const particle of this.waterParticles) {
            const alpha = particle.life / this.particleLife;
            ctx.globalAlpha = alpha * 0.7;
            
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1;
    }
}

// Main game class with improved architecture
class PipeDreamGame {
    constructor(canvas, gameContainer) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.gameContainer = gameContainer;
        
        this.gameState = new GameState();
        this.mathGenerator = new MathExpressionGenerator();
        this.pipeSystem = new PipeSystem();
        this.waterSimulator = new WaterFlowSimulator();
        
        this.grid = [];
        this.isDragging = false;
        this.dragStartPos = { x: 0, y: 0 };
        
        this.init();
    }
    
    init() {
        this.setupCanvas();
        this.createNewPuzzle();
        this.setupEventListeners();
        this.startGameLoop();
    }
    
    setupCanvas() {
        // Set canvas size based on grid
        const config = this.gameState.getGameConfig();
        this.canvas.width = config.maxPathLength * GRID_SIZE;
        this.canvas.height = config.answerPipeCount * GRID_SIZE;
    }
    
    createNewPuzzle() {
        // Generate new math problem
        this.gameState.currentExpression = this.mathGenerator.generateExpression(
            this.gameState.difficulty,
            this.gameState.operations,
            this.gameState.allowNegatives
        );
        
        this.gameState.correctAnswer = this.mathGenerator.evaluateExpression(this.gameState.currentExpression);
        this.gameState.decoyAnswers = this.generateDecoyAnswers();
        
        // Create game grid
        this.createGrid();
        this.placeStartAndAnswerPipes();
        this.generateInventory();
        
        // Start pressure timer
        this.startPressureTimer();
        
        // Update display
        this.updateDisplay();
    }
    
    generateDecoyAnswers() {
        const config = this.gameState.getGameConfig();
        const decoys = [];
        
        while (decoys.length < config.answerPipeCount - 1) {
            let decoy = Math.floor(Math.random() * config.maxNumber) + 1;
            if (decoy !== this.gameState.correctAnswer && !decoys.includes(decoy)) {
                decoys.push(decoy);
            }
        }
        
        return decoys;
    }
    
    createGrid() {
        const config = this.gameState.getGameConfig();
        this.grid = [];
        
        for (let y = 0; y < config.answerPipeCount; y++) {
            this.grid[y] = [];
            for (let x = 0; x < config.maxPathLength; x++) {
                this.grid[y][x] = { 
                    pipe: null, 
                    hasWater: false, 
                    connections: [] 
                };
            }
        }
    }
    
    placeStartAndAnswerPipes() {
        const config = this.gameState.getGameConfig();
        
        // Place start pipe on the left
        this.gameState.startPipe = { x: 0, y: Math.floor(config.answerPipeCount / 2) };
        
        // Place answer pipes on the right
        this.gameState.answerPipes = [];
        const answers = [this.gameState.correctAnswer, ...this.gameState.decoyAnswers];
        
        for (let i = 0; i < config.answerPipeCount; i++) {
            this.gameState.answerPipes.push({
                x: config.maxPathLength - 1,
                y: i,
                value: answers[i],
                isCorrect: answers[i] === this.gameState.correctAnswer
            });
        }
    }
    
    generateInventory() {
        const config = this.gameState.getGameConfig();
        const pipeCount = Math.floor(config.maxPathLength * config.answerPipeCount * 0.3);
        this.gameState.inventory = this.pipeSystem.generatePipeInventory(pipeCount);
    }
    
    startPressureTimer() {
        const config = this.gameState.getGameConfig();
        
        if (this.gameState.pressureTimer) {
            clearInterval(this.gameState.pressureTimer);
        }
        
        this.gameState.pressureTimer = setInterval(() => {
            this.gameState.pressure += config.pressureRate;
            
            if (this.gameState.pressure >= this.gameState.maxPressure) {
                this.gameOver();
            }
            
            this.updateDisplay();
        }, 1000);
    }
    
    updateDisplay() {
        // Update game container UI
        this.gameContainer.updateScore(this.gameState.score);
        this.gameContainer.updateLives(this.gameState.level);
        
        // Update pressure display (could be added to GameContainer)
        this.drawPressureGauge();
    }
    
    drawPressureGauge() {
        const pressurePercent = (this.gameState.pressure / this.gameState.maxPressure) * 100;
        
        // Draw pressure bar
        const barWidth = 200;
        const barHeight = 20;
        const x = 20;
        const y = 100;
        
        // Background
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(x, y, barWidth, barHeight);
        
        // Fill
        this.ctx.fillStyle = pressurePercent > 80 ? '#f00' : pressurePercent > 60 ? '#ff0' : '#0f0';
        this.ctx.fillRect(x, y, (barWidth * pressurePercent) / 100, barHeight);
        
        // Border
        this.ctx.strokeStyle = '#fff';
        this.ctx.strokeRect(x, y, barWidth, barHeight);
        
        // Text
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '16px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`Pressure: ${Math.round(pressurePercent)}%`, x, y - 10);
    }
    
    setupEventListeners() {
        // Mouse events for drag and drop
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        
        // Touch events for mobile
        this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
        
        // Keyboard events
        this.gameContainer.on('keydown', this.handleKeyDown.bind(this));
    }
    
    handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        this.startDrag(x, y);
    }
    
    handleMouseMove(e) {
        if (this.isDragging) {
            const rect = this.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            this.updateDrag(x, y);
        }
    }
    
    handleMouseUp(e) {
        if (this.isDragging) {
            this.endDrag();
        }
    }
    
    handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = this.canvas.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;
        
        this.startDrag(x, y);
    }
    
    handleTouchMove(e) {
        e.preventDefault();
        if (this.isDragging) {
            const touch = e.touches[0];
            const rect = this.canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            this.updateDrag(x, y);
        }
    }
    
    handleTouchEnd(e) {
        e.preventDefault();
        if (this.isDragging) {
            this.endDrag();
        }
    }
    
    startDrag(x, y) {
        // Check if clicking on inventory or placed pipe
        const inventoryItem = this.getInventoryItemAt(x, y);
        const placedPipe = this.getPlacedPipeAt(x, y);
        
        if (inventoryItem) {
            this.isDragging = true;
            this.dragStartPos = { x, y };
            this.gameState.draggedPipe = inventoryItem;
        } else if (placedPipe) {
            this.isDragging = true;
            this.dragStartPos = { x, y };
            this.gameState.draggedPlacedPipe = placedPipe;
        }
    }
    
    updateDrag(x, y) {
        if (this.gameState.draggedPipe || this.gameState.draggedPlacedPipe) {
            // Update visual feedback
            this.draw();
            this.drawDraggedPipe(x, y);
        }
    }
    
    endDrag() {
        if (this.isDragging) {
            // Place pipe or move existing pipe
            this.placePipe();
            this.isDragging = false;
            this.gameState.draggedPipe = null;
            this.gameState.draggedPlacedPipe = null;
        }
    }
    
    getInventoryItemAt(x, y) {
        // Check if click is in inventory area
        const inventoryArea = { x: 20, y: 150, width: 200, height: 100 };
        
        if (x >= inventoryArea.x && x <= inventoryArea.x + inventoryArea.width &&
            y >= inventoryArea.y && y <= inventoryArea.y + inventoryArea.height) {
            
            const itemIndex = Math.floor((y - inventoryArea.y) / 30);
            return this.gameState.inventory[itemIndex] || null;
        }
        
        return null;
    }
    
    getPlacedPipeAt(x, y) {
        // Check if click is on a placed pipe
        const gridX = Math.floor(x / GRID_SIZE);
        const gridY = Math.floor(y / GRID_SIZE);
        
        if (gridX >= 0 && gridX < this.grid[0].length && 
            gridY >= 0 && gridY < this.grid.length) {
            
            return this.grid[gridY][gridX].pipe;
        }
        
        return null;
    }
    
    placePipe() {
        // Implementation for placing pipes on the grid
        // This would include collision detection and connection logic
        console.log('Pipe placement logic would go here');
    }
    
    drawDraggedPipe(x, y) {
        if (this.gameState.draggedPipe) {
            this.ctx.save();
            this.ctx.globalAlpha = 0.7;
            this.ctx.fillStyle = '#0bb';
            this.ctx.fillRect(x - 15, y - 15, 30, 30);
            this.ctx.restore();
        }
    }
    
    handleKeyDown(e) {
        switch(e.key) {
            case 'r':
            case 'R':
                this.resetGame();
                break;
            case ' ':
                this.gameState.gameActive = !this.gameState.gameActive;
                break;
            case 'n':
            case 'N':
                this.createNewPuzzle();
                break;
        }
    }
    
    resetGame() {
        this.gameState.reset();
        this.createNewPuzzle();
    }
    
    gameOver() {
        this.gameState.gameActive = false;
        if (this.gameState.pressureTimer) {
            clearInterval(this.gameState.pressureTimer);
        }
        
        // Show game over screen
        this.drawGameOver();
    }
    
    drawGameOver() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#f00';
        this.ctx.font = '48px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '24px monospace';
        this.ctx.fillText(`Final Score: ${this.gameState.score}`, this.canvas.width / 2, this.canvas.height / 2 + 50);
        this.ctx.fillText('Press R to restart', this.canvas.width / 2, this.canvas.height / 2 + 100);
    }
    
    draw() {
        // Clear canvas
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.drawGrid();
        
        // Draw pipes
        this.drawPipes();
        
        // Draw inventory
        this.drawInventory();
        
        // Draw UI
        this.drawUI();
        
        // Draw water flow
        this.waterSimulator.draw(this.ctx);
    }
    
    drawGrid() {
        this.ctx.strokeStyle = '#0f0';
        this.ctx.lineWidth = 1;
        
        for (let y = 0; y < this.grid.length; y++) {
            for (let x = 0; x < this.grid[y].length; x++) {
                const cellX = x * GRID_SIZE;
                const cellY = y * GRID_SIZE;
                
                this.ctx.strokeRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
            }
        }
    }
    
    drawPipes() {
        // Draw start pipe
        if (this.gameState.startPipe) {
            this.ctx.fillStyle = '#0f0';
            this.ctx.fillRect(
                this.gameState.startPipe.x * GRID_SIZE + 5,
                this.gameState.startPipe.y * GRID_SIZE + 5,
                GRID_SIZE - 10,
                GRID_SIZE - 10
            );
        }
        
        // Draw answer pipes
        this.gameState.answerPipes.forEach(pipe => {
            this.ctx.fillStyle = pipe.isCorrect ? '#0f0' : '#f0f';
            this.ctx.fillRect(
                pipe.x * GRID_SIZE + 5,
                pipe.y * GRID_SIZE + 5,
                GRID_SIZE - 10,
                GRID_SIZE - 10
            );
            
            // Draw value
            this.ctx.fillStyle = '#000';
            this.ctx.font = '16px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(pipe.value, pipe.x * GRID_SIZE + GRID_SIZE/2, pipe.y * GRID_SIZE + GRID_SIZE/2 + 6);
        });
        
        // Draw placed pipes
        for (let y = 0; y < this.grid.length; y++) {
            for (let x = 0; x < this.grid[y].length; x++) {
                const cell = this.grid[y][x];
                if (cell.pipe) {
                    this.drawPipe(cell.pipe, x * GRID_SIZE, y * GRID_SIZE);
                }
            }
        }
    }
    
    drawPipe(pipe, x, y) {
        this.ctx.save();
        this.ctx.translate(x + GRID_SIZE/2, y + GRID_SIZE/2);
        this.ctx.rotate((pipe.rotation * Math.PI) / 180);
        
        this.ctx.strokeStyle = pipe.hasWater ? '#00f' : '#0f0';
        this.ctx.lineWidth = 3;
        
        const pipeType = this.pipeSystem.pipeTypes[pipe.type];
        if (pipeType) {
            this.ctx.fillStyle = '#0bb';
            this.ctx.fillRect(-15, -15, 30, 30);
            
            // Draw pipe symbol
            this.ctx.fillStyle = '#000';
            this.ctx.font = '20px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(pipeType.symbol, 0, 6);
        }
        
        this.ctx.restore();
    }
    
    drawInventory() {
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(20, 150, 200, 100);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '16px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText('Pipe Inventory:', 25, 170);
        
        this.gameState.inventory.forEach((pipe, index) => {
            const y = 190 + index * 30;
            
            this.ctx.fillStyle = '#0bb';
            this.ctx.fillRect(25, y, 25, 25);
            
            this.ctx.fillStyle = '#000';
            this.ctx.font = '14px monospace';
            this.ctx.fillText(pipe.type.charAt(0).toUpperCase(), 30, y + 17);
        });
    }
    
    drawUI() {
        // Draw math problem
        this.ctx.fillStyle = '#ffd700';
        this.ctx.font = '24px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(this.gameState.currentExpression.expression + ' = ?', this.canvas.width/2, 30);
        
        // Draw score and level
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '16px monospace';
        this.ctx.textAlign = 'left';
        this.ctx.fillText(`Score: ${this.gameState.score}`, 20, 50);
        this.ctx.fillText(`Level: ${this.gameState.level}`, 20, 70);
        this.ctx.fillText(`Stars: ${this.gameState.stars}`, 20, 90);
        
        // Draw pressure gauge
        this.drawPressureGauge();
    }
    
    startGameLoop() {
        let lastTime = 0;
        
        const gameLoop = (currentTime) => {
            if (!this.gameState.gameActive) return;
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update water simulation
            this.waterSimulator.update();
            
            // Draw everything
            this.draw();
            
            requestAnimationFrame(gameLoop);
        };
        
        gameLoop(0);
    }
}

// Initialize the game
const game = new PipeDreamGame(canvas, gameContainer);

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { game.gameState.gameActive = false; },
    resume: () => { game.gameState.gameActive = true; },
    restart: () => { game.resetGame(); }
};

console.log('REAL Pipe Dream game initialized with universal system - Full math puzzle game with improved architecture');
</script>
</body>
</html>
