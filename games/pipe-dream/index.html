<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pipe Dream - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with pipe-dream config
const gameConfig = GAME_CONFIGS['pipe-dream'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants and variables
let gameMode = 'practice'; // 'adventure', 'practice', 'timed'
let difficulty = 'basic'; // 'basic', 'easy', 'medium', 'hard'
let gridSize = '8x5'; // Default grid size
let operations = ['+']; // Available operations
let allowNegatives = false;
let showPrecedenceHints = true;

let level = 1;
let score = 0;
let stars = 0;
let pressure = 12;
let maxPressure = 100;
let gameActive = true;

let pipes = [];
let connectedPipes = [];
let draggedPipe = null;
let draggedPlacedPipe = null;
let timer = null;
let pipeHistory = [];

let startPipe = null;
let answerPipes = [];
let obstacles = [];
let inventory = [];

let currentExpression = null;
let correctAnswer = null;
let decoyAnswers = [];

// Game configuration based on difficulty
function getGameConfig() {
    const configs = {
        basic: {
            maxPathLength: 6,
            answerPipeCount: 2,
            allowCrossings: false,
            pressureRate: 0.3,
            maxNumber: 5,
            operations: ['+']
        },
        easy: {
            maxPathLength: 8,
            answerPipeCount: 3,
            allowCrossings: false,
            pressureRate: 0.5,
            maxNumber: 10,
            operations: ['+', '-']
        },
        medium: {
            maxPathLength: 12,
            answerPipeCount: 4,
            allowCrossings: false,
            pressureRate: 1.0,
            maxNumber: 15,
            operations: ['+', '-', '×']
        },
        hard: {
            maxPathLength: 16,
            answerPipeCount: 5,
            allowCrossings: true,
            pressureRate: 2.0,
            maxNumber: 20,
            operations: ['+', '-', '×', '÷']
        }
    };
    return configs[difficulty] || configs.basic;
}

// Initialize game
function init() {
    // Set up canvas
    canvas.width = 800;
    canvas.height = 600;
    
    // Initialize game state
    resetLevel();
    
    // Start game loop
    gameLoop();
}

// Reset level
function resetLevel() {
    const config = getGameConfig();
    
    // Generate new math problem
    generateMathProblem();
    
    // Reset pressure
    pressure = 12;
    
    // Clear pipes
    pipes = [];
    connectedPipes = [];
    
    // Generate new pipe layout
    generatePipeLayout();
    
    // Update UI
    updateUI();
}

// Generate math problem
function generateMathProblem() {
    const config = getGameConfig();
    const maxNum = config.maxNumber;
    
    let num1, num2, operation, result;
    
    do {
        num1 = Math.floor(Math.random() * maxNum) + 1;
        num2 = Math.floor(Math.random() * maxNum) + 1;
        operation = operations[Math.floor(Math.random() * operations.length)];
        
        switch(operation) {
            case '+':
                result = num1 + num2;
                break;
            case '-':
                result = num1 - num2;
                if (!allowNegatives && result < 0) continue;
                break;
            case '×':
                result = num1 * num2;
                break;
            case '÷':
                if (num2 === 0) continue;
                if (num1 % num2 !== 0) continue;
                result = num1 / num2;
                break;
        }
    } while (result > maxNum || result < 0);
    
    currentExpression = `${num1} ${operation} ${num2}`;
    correctAnswer = result;
    
    // Generate decoy answers
    decoyAnswers = [];
    while (decoyAnswers.length < 3) {
        let decoy = Math.floor(Math.random() * maxNum) + 1;
        if (decoy !== correctAnswer && !decoyAnswers.includes(decoy)) {
            decoyAnswers.push(decoy);
        }
    }
}

// Generate pipe layout
function generatePipeLayout() {
    const config = getGameConfig();
    
    // Clear existing layout
    startPipe = null;
    answerPipes = [];
    obstacles = [];
    
    // Create start pipe
    startPipe = {
        x: 100,
        y: 300,
        type: 'start',
        connections: ['right']
    };
    
    // Create answer pipes
    for (let i = 0; i < config.answerPipeCount; i++) {
        answerPipes.push({
            x: 600 + i * 80,
            y: 200 + i * 100,
            type: 'answer',
            value: i === 0 ? correctAnswer : decoyAnswers[i - 1],
            connections: ['left']
        });
    }
    
    // Create some obstacles
    for (let i = 0; i < 5; i++) {
        obstacles.push({
            x: 200 + Math.random() * 400,
            y: 100 + Math.random() * 400,
            type: 'obstacle'
        });
    }
}

// Update UI
function updateUI() {
    // Update score and level in game container
    gameContainer.updateScore(score);
    gameContainer.updateLives(level);
    
    // Update pressure display
    const pressurePercent = Math.round((pressure / maxPressure) * 100);
    // Note: We'll need to add pressure display to the GameContainer or handle it separately
}

// Game loop
function gameLoop() {
    if (!gameActive) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw game elements
    drawGame();
    
    // Update pressure
    updatePressure();
    
    requestAnimationFrame(gameLoop);
}

// Draw game
function drawGame() {
    // Draw background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw math problem
    ctx.fillStyle = '#ffd700';
    ctx.font = '32px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(currentExpression + ' = ?', canvas.width / 2, 50);
    
    // Draw start pipe
    drawPipe(startPipe);
    
    // Draw answer pipes
    answerPipes.forEach(pipe => drawPipe(pipe));
    
    // Draw obstacles
    obstacles.forEach(obstacle => drawObstacle(obstacle));
    
    // Draw placed pipes
    pipes.forEach(pipe => drawPlacedPipe(pipe));
    
    // Draw UI
    drawUI();
}

// Draw pipe
function drawPipe(pipe) {
    if (pipe.type === 'start') {
        ctx.fillStyle = '#0f0';
        ctx.fillRect(pipe.x - 20, pipe.y - 20, 40, 40);
        ctx.fillStyle = '#000';
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('START', pipe.x, pipe.y + 6);
    } else if (pipe.type === 'answer') {
        ctx.fillStyle = '#f0f';
        ctx.fillRect(pipe.x - 20, pipe.y - 20, 40, 40);
        ctx.fillStyle = '#000';
        ctx.font = '16px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(pipe.value, pipe.x, pipe.y + 6);
    }
}

// Draw obstacle
function drawObstacle(obstacle) {
    ctx.fillStyle = '#f00';
    ctx.fillRect(obstacle.x - 15, obstacle.y - 15, 30, 30);
}

// Draw placed pipe
function drawPlacedPipe(pipe) {
    ctx.fillStyle = '#0bb';
    ctx.fillRect(pipe.x - 15, pipe.y - 15, 30, 30);
    
    // Draw pipe connections
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    pipe.connections.forEach(connection => {
        let startX = pipe.x, startY = pipe.y, endX = pipe.x, endY = pipe.y;
        
        switch(connection) {
            case 'top':
                endY = pipe.y - 20;
                break;
            case 'bottom':
                endY = pipe.y + 20;
                break;
            case 'left':
                endX = pipe.x - 20;
                break;
            case 'right':
                endX = pipe.x + 20;
                break;
        }
        
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
    });
}

// Draw UI
function drawUI() {
    ctx.fillStyle = '#0f0';
    ctx.font = '20px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 20, 30);
    ctx.fillText(`Level: ${level}`, 20, 60);
    ctx.fillText(`Pressure: ${Math.round((pressure / maxPressure) * 100)}%`, 20, 90);
}

// Update pressure
function updatePressure() {
    const config = getGameConfig();
    pressure += config.pressureRate;
    
    if (pressure >= maxPressure) {
        gameOver();
    }
}

// Game over
function gameOver() {
    gameActive = false;
    // Handle game over logic
}

// Event listeners
gameContainer.on('keydown', (e) => {
    switch(e.key) {
        case 'r':
        case 'R':
            resetLevel();
            break;
        case ' ':
            gameActive = !gameActive;
            if (gameActive) gameLoop();
            break;
    }
});

// Touch controls for mobile
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    
    // Handle touch input for pipe placement
    handleTouchInput(touchX, touchY);
});

function handleTouchInput(x, y) {
    // Simple touch handling - could be expanded for drag and drop
    console.log('Touch at:', x, y);
}

// Initialize game
init();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { gameActive = false; },
    resume: () => { gameActive = true; gameLoop(); },
    restart: resetLevel
};

console.log('REAL Pipe Dream game initialized with universal system');
</script>
</body>
</html>
