<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Pipe Dream - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
<style>
/* Pipe Dream specific styles */
.game-title {
    text-transform: uppercase;
    font-size: 2rem;
    color: #ffd700;
    text-shadow: 0 0 8px #f00;
    text-align: center;
    margin-bottom: 20px;
}

.game-description {
    color: #0f0;
    text-align: center;
    margin-bottom: 20px;
}

.math-problem {
    font-size: 1.5rem;
    color: #ffd700;
    margin: 20px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    text-align: center;
}

.pipe-inventory {
    margin: 20px 0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    border: 2px solid #0f0;
    min-height: 120px;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    justify-content: center;
}

.pipe-piece {
    width: 60px;
    height: 60px;
    background: #1a1a2e;
    border: 2px solid #0f0;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: grab;
    user-select: none;
    position: relative;
    transition: all 0.2s ease;
}

.pipe-piece:hover {
    border-color: #ff0;
    transform: scale(1.05);
}

.pipe-piece:active {
    cursor: grabbing;
}

.pipe-piece svg {
    width: 100%;
    height: 100%;
}

.pipe-stroke {
    stroke: #0f0;
    stroke-width: 4;
    fill: none;
    stroke-linecap: round;
}

.pipe-stroke.glow {
    stroke: #ff0;
    filter: drop-shadow(0 0 5px #ff0);
}

.pipe-inner {
    stroke: #00f;
    stroke-width: 2;
    fill: none;
    stroke-linecap: round;
}

.pipe-endcap {
    fill: #0f0;
}

.pipe-piece[data-type="number"] {
    background: #0f0;
    color: #000;
    font-weight: bold;
    font-size: 24px;
}

.pipe-piece[data-type="operator"] {
    background: #ff8c00;
    color: #000;
    font-weight: bold;
    font-size: 24px;
}

.play-area {
    margin: 20px 0;
    min-height: 400px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 8px;
    border: 2px solid #0f0;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
}

.game-grid {
    display: grid;
    gap: 2px;
    background: #0f0;
    padding: 10px;
    border-radius: 5px;
}

.grid-cell {
    width: 40px;
    height: 40px;
    background: #1a1a2e;
    border: 1px solid #0f0;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.grid-cell:hover {
    background: #2a2a3e;
}

.grid-cell.start-pipe {
    background: #0f0;
    color: #000;
    font-weight: bold;
}

.grid-cell.answer-pipe {
    background: #00f;
    color: #fff;
    font-weight: bold;
}

.grid-cell.has-pipe {
    background: #0bb;
    border-color: #ff0;
}

.game-controls {
    margin: 20px 0;
}

.control-row {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 10px 0;
}

.control-btn {
    padding: 10px 20px;
    background: #0f0;
    color: #000;
    border: 2px solid #fff;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s ease;
}

.control-btn:hover {
    background: #0a0;
    transform: scale(1.05);
}

.water-btn {
    background: #00f;
    color: #fff;
}

.section-title {
    color: #ffd700;
    font-weight: 700;
    margin-bottom: 10px;
    font-size: 16px;
}

.score-display {
    border: 2px solid #0f0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    text-align: center;
}

.pressure-gauge {
    margin: 15px 0;
}

.pressure-bar {
    width: 100%;
    height: 20px;
    background: #333;
    border: 2px solid #0f0;
    border-radius: 10px;
    overflow: hidden;
}

.pressure-fill {
    height: 100%;
    background: linear-gradient(90deg, #0f0, #ff0, #f00);
    transition: width 0.3s ease;
}

.settings-section {
    border: 2px solid #0f0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
}

.settings-section label {
    display: block;
    margin-bottom: 5px;
    color: #0f0;
}

.settings-section select,
.settings-section input[type="checkbox"] {
    width: 100%;
    padding: 8px;
    background: #1a1a2e;
    color: #0f0;
    border: 2px solid #0f0;
    border-radius: 5px;
    margin-bottom: 10px;
}

.operations-section {
    margin: 15px 0;
}

.operations-grid {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    margin-bottom: 10px;
}

.operations-grid label {
    display: flex;
    align-items: center;
    gap: 5px;
    color: #0f0;
}

.rules-section {
    border: 2px solid #0f0;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
}

.rules-text {
    font-size: 14px;
    line-height: 1.4;
}

.rules-text p {
    margin: 5px 0;
    color: #0f0;
}

/* SVG Pipe Styles */
.pipe-piece {
    display: inline-block;
    width: 60px;
    height: 60px;
    margin: 5px;
    cursor: grab;
    user-select: none;
    position: relative;
    border: 2px solid #0f0;
    border-radius: 8px;
    background: #1a1a2e;
    transition: all 0.2s ease;
}

.pipe-piece:hover {
    border-color: #ff0;
    transform: scale(1.05);
}

.pipe-piece.dragging {
    opacity: 0.7;
    transform: scale(1.1);
    cursor: grabbing;
}

.pipe-piece svg {
    width: 100%;
    height: 100%;
    display: block;
}

.pipe-stroke {
    stroke: #0f0;
    stroke-width: 4;
    fill: none;
    stroke-linecap: round;
}

.pipe-stroke.glow {
    stroke: #ff0;
    filter: drop-shadow(0 0 4px #ff0);
}

.pipe-inner {
    stroke: #00f;
    stroke-width: 2;
    fill: none;
    stroke-linecap: round;
}

.pipe-endcap {
    fill: #0f0;
}

.pipe-endcap.glow {
    fill: #ff0;
    filter: drop-shadow(0 0 4px #ff0);
}

/* Grid Styles */
.game-grid {
    display: grid;
    gap: 2px;
    padding: 20px;
    background: #1a1a2e;
    border: 2px solid #0f0;
    border-radius: 8px;
    margin: 20px 0;
}

.grid-cell {
    width: 40px;
    height: 40px;
    border: 1px solid #0f0;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.grid-cell.drag-over {
    background: #ff0;
    border-color: #ff0;
    transform: scale(1.1);
}

.grid-cell.start-pipe {
    background: #0f0;
    color: #000;
    font-weight: bold;
}

.grid-cell.answer-pipe {
    background: #00f;
    color: #fff;
    font-weight: bold;
}

.grid-cell.placed-pipe {
    background: #0bb;
    border-color: #0bb;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .game-content {
        flex-direction: column;
        padding: 10px;
    }
    
    .game-grid {
        transform: scale(0.8);
    }
    
    .game-sidebar-rhs {
        width: 100%;
        order: 3;
    }
    
    .game-area-lhs {
        order: 2;
    }
}
</style>
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<div class="game-content">
    <div class="game-area-lhs">
        <div class="game-header">
            <h1 class="game-title">ðŸš° Pipe Dream</h1>
            <p class="game-description">Connect pipes to solve math problems and watch the water flow!</p>
        </div>
        
        <div class="math-problem" id="mathProblem" role="heading" aria-level="2">
            5 + 3 = ?
        </div>
        
        <div class="pipe-inventory" id="pipeInventory">
            <!-- SVG pipe pieces will be generated here -->
        </div>
        
        <div class="play-area" id="playArea">
            <div class="game-grid" id="gameGrid">
                <!-- Grid cells will be generated here -->
            </div>
        </div>
        
        <div class="game-controls">
            <div class="control-row">
                <button class="control-btn water-btn" id="flowTestBtn" aria-label="Start water flow">
                    <span class="tap-icon">ðŸ’§</span>
                    Start Tap
                </button>
            </div>
            <div class="control-row">
                <button class="control-btn" id="newLevelBtn" aria-label="Start new level">New Level</button>
                <button class="control-btn" id="resetBtn" aria-label="Reset current level">Reset</button>
                <button class="control-btn" id="undoBtn" aria-label="Undo last pipe placement">Undo</button>
                <button class="control-btn" id="hintBtn" aria-label="Get a hint for current problem">Hint</button>
            </div>
        </div>
    </div>
    
    <div class="game-sidebar-rhs">
        <div class="score-display">
            <div class="section-title">SCORE</div>
            <div style="margin-bottom: 8px;">
                <strong>Level:</strong> <span id="level">1</span>
            </div>
            <div style="margin-bottom: 8px;">
                <strong>Score:</strong> <span id="score">0</span>
            </div>
            <div style="margin-bottom: 8px;">
                <strong>Stars:</strong> <span id="stars">0</span>
            </div>
        </div>
        
        <div class="pressure-gauge">
            <div class="section-title">PRESSURE</div>
            <strong>Pressure:</strong> <span id="pressure">0</span>%
            <div class="pressure-bar">
                <div class="pressure-fill" id="pressureFill"></div>
            </div>
        </div>
        
        <div class="settings-section">
            <div class="section-title">SETTINGS</div>
            <div style="margin-bottom: 15px;">
                <label>Game Mode:</label>
                <select id="gameMode">
                    <option value="practice">Practice (Free Build)</option>
                    <option value="adventure">Adventure (Levels)</option>
                    <option value="timed">Timed Rush</option>
                </select>
                
                <label>Difficulty:</label>
                <select id="difficulty">
                    <option value="basic">Basic (Ages 5-7)</option>
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard">Hard</option>
                </select>
                
                <label>Grid Size:</label>
                <select id="gridSize">
                    <option value="5x5">5Ã—5 Grid</option>
                    <option value="6x4">6Ã—4 Grid</option>
                    <option value="7x5">7Ã—5 Grid</option>
                    <option value="8x5">8Ã—5 Grid</option>
                </select>
            </div>
            
            <div class="operations-section">
                <div class="section-title">OPERATIONS</div>
                <div class="operations-grid">
                    <label>
                        <input type="checkbox" id="opAdd" checked> +
                    </label>
                    <label>
                        <input type="checkbox" id="opSub"> âˆ’
                    </label>
                    <label>
                        <input type="checkbox" id="opMul"> Ã—
                    </label>
                    <label>
                        <input type="checkbox" id="opDiv"> Ã·
                    </label>
                </div>
            </div>
            
            <button class="control-btn" id="applySettings">Apply Settings</button>
        </div>
        
        <div class="rules-section">
            <div class="section-title">RULES</div>
            <div class="rules-text">
                <p>â€¢ Connect pipes from start to answer</p>
                <p>â€¢ Use inventory pieces efficiently</p>
                <p>â€¢ Watch the pressure gauge</p>
                <p>â€¢ Solve math problems to advance</p>
            </div>
        </div>
    </div>
</div>

<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with pipe-dream config
const gameConfig = GAME_CONFIGS['pipe-dream'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// REAL Pipe Dream Game Class with SVG and Drag & Drop
class PipeDream {
    constructor() {
        this.gameMode = 'practice';
        this.difficulty = 'basic';
        this.isMobile = window.innerWidth <= 768;
        this.gridSize = this.isMobile ? '5x5' : '8x5';
        
        const validGridSizes = ['5x5', '6x4', '7x5', '8x5'];
        if (!validGridSizes.includes(this.gridSize)) {
            this.gridSize = '8x5';
        }
        
        this.operations = ['+'];
        this.allowNegatives = false;
        this.showPrecedenceHints = true;
        
        this.level = 1;
        this.score = 0;
        this.stars = 0;
        this.pressure = 12;
        this.maxPressure = 100;
        this.gameActive = true;
        
        this.pipes = [];
        this.connectedPipes = [];
        this.draggedPipe = null;
        this.draggedPlacedPipe = null;
        this.timer = null;
        this.pipeHistory = [];
        
        this.startPipe = null;
        this.answerPipes = [];
        this.obstacles = [];
        this.inventory = [];
        
        this.currentExpression = null;
        this.correctAnswer = null;
        this.decoyAnswers = [];
        
        this.grid = [];
        this.gridElement = null;
        
        this.init();
    }
    
    getGameConfig() {
        const configs = {
            basic: {
                maxPathLength: 6,
                answerPipeCount: 2,
                allowCrossings: false,
                pressureRate: 0.3,
                maxNumber: 5,
                operations: ['+']
            },
            easy: {
                maxPathLength: 8,
                answerPipeCount: 3,
                allowCrossings: false,
                pressureRate: 0.5,
                maxNumber: 10,
                operations: ['+', '-']
            },
            medium: {
                maxPathLength: 12,
                answerPipeCount: 4,
                allowCrossings: false,
                pressureRate: 1.0,
                maxNumber: 15,
                operations: ['+', '-', 'Ã—']
            },
            hard: {
                maxPathLength: 16,
                answerPipeCount: 5,
                allowCrossings: true,
                pressureRate: 2.0,
                maxNumber: 20,
                operations: ['+', '-', 'Ã—', 'Ã·']
            }
        };
        return configs[this.difficulty] || configs.basic;
    }
    
    getPipeTypes() {
        return [
            // Numbers
            { type: 'number', value: 1, symbol: '1' },
            { type: 'number', value: 2, symbol: '2' },
            { type: 'number', value: 3, symbol: '3' },
            { type: 'number', value: 4, symbol: '4' },
            { type: 'number', value: 5, symbol: '5' },
            { type: 'number', value: 6, symbol: '6' },
            { type: 'number', value: 7, symbol: '7' },
            { type: 'number', value: 8, symbol: '8' },
            { type: 'number', value: 9, symbol: '9' },
            { type: 'number', value: 10, symbol: '10' },
            
            // Operators
            { type: 'operator', operation: '+', symbol: '+' },
            { type: 'operator', operation: '-', symbol: 'âˆ’' },
            { type: 'operator', operation: 'Ã—', symbol: 'Ã—' },
            { type: 'operator', operation: 'Ã·', symbol: 'Ã·' },
            
            // Connector pipes
            { type: 'connector', pipeType: 'straight-h', symbol: 'â–¶' },
            { type: 'connector', pipeType: 'straight-v', symbol: 'â–¼' },
            { type: 'connector', pipeType: 'elbow', symbol: 'â”Œ' },
            { type: 'connector', pipeType: 'tee', symbol: 'â”œ' },
            { type: 'connector', pipeType: 'cross', symbol: 'âŠ•' }
        ];
    }
    
    init() {
        this.setupEventListeners();
        this.createGrid();
        this.createNewPuzzle();
        this.startPressureTimer();
        this.updateDisplay();
    }
    
    setupEventListeners() {
        // Game control buttons
        document.getElementById('flowTestBtn').addEventListener('click', () => this.testWaterFlow());
        document.getElementById('newLevelBtn').addEventListener('click', () => this.createNewPuzzle());
        document.getElementById('resetBtn').addEventListener('click', () => this.resetLevel());
        document.getElementById('undoBtn').addEventListener('click', () => this.undoLastMove());
        document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
        document.getElementById('applySettings').addEventListener('click', () => this.applySettings());
        
        // Settings change handlers
        document.getElementById('gameMode').addEventListener('change', (e) => this.gameMode = e.target.value);
        document.getElementById('difficulty').addEventListener('change', (e) => this.difficulty = e.target.value);
        document.getElementById('gridSize').addEventListener('change', (e) => this.gridSize = e.target.value);
        
        // Operations checkboxes
        document.getElementById('opAdd').addEventListener('change', (e) => this.updateOperations());
        document.getElementById('opSub').addEventListener('change', (e) => this.updateOperations());
        document.getElementById('opMul').addEventListener('change', (e) => this.updateOperations());
        document.getElementById('opDiv').addEventListener('change', (e) => this.updateOperations());
        
        // Setup drag and drop
        this.setupDragAndDrop();
    }
    
    setupDragAndDrop() {
        const inventory = document.getElementById('pipeInventory');
        const grid = document.getElementById('gameGrid');
        
        // Inventory drag events
        inventory.addEventListener('dragstart', (e) => this.handleDragStart(e));
        inventory.addEventListener('dragend', (e) => this.handleDragEnd(e));
        
        // Grid drop events
        grid.addEventListener('dragover', (e) => this.handleDragOver(e));
        grid.addEventListener('drop', (e) => this.handleDrop(e));
        grid.addEventListener('dragleave', (e) => this.handleDragLeave(e));
    }
    
    handleDragStart(e) {
        const pipeElement = e.target.closest('.pipe-piece');
        if (!pipeElement) return;
        
        const pipeData = JSON.parse(pipeElement.dataset.pipeType);
        e.dataTransfer.setData('text/plain', JSON.stringify(pipeData));
        e.dataTransfer.effectAllowed = 'copy';
        
        pipeElement.classList.add('dragging');
        this.draggedPipe = pipeData;
    }
    
    handleDragEnd(e) {
        const pipeElement = e.target.closest('.pipe-piece');
        if (pipeElement) {
            pipeElement.classList.remove('dragging');
        }
        this.draggedPipe = null;
    }
    
    handleDragOver(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        
        const cell = e.target.closest('.grid-cell');
        if (cell && !cell.classList.contains('start-pipe') && !cell.classList.contains('answer-pipe')) {
            cell.classList.add('drag-over');
        }
    }
    
    handleDragLeave(e) {
        const cell = e.target.closest('.grid-cell');
        if (cell) {
            cell.classList.remove('drag-over');
        }
    }
    
    handleDrop(e) {
        e.preventDefault();
        
        const cell = e.target.closest('.grid-cell');
        if (!cell || !this.draggedPipe) return;
        
        cell.classList.remove('drag-over');
        
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);
        
        this.placePipe(x, y, this.draggedPipe);
    }
    
    updateOperations() {
        this.operations = [];
        if (document.getElementById('opAdd').checked) this.operations.push('+');
        if (document.getElementById('opSub').checked) this.operations.push('-');
        if (document.getElementById('opMul').checked) this.operations.push('Ã—');
        if (document.getElementById('opDiv').checked) this.operations.push('Ã·');
        
        if (this.operations.length === 0) {
            this.operations = ['+']; // Default to addition
            document.getElementById('opAdd').checked = true;
        }
    }
    
    createGrid() {
        const config = this.getGameConfig();
        this.gridElement = document.getElementById('gameGrid');
        this.gridElement.innerHTML = '';
        
        const [cols, rows] = this.gridSize.split('x').map(Number);
        this.grid = [];
        
        this.gridElement.style.gridTemplateColumns = `repeat(${cols}, 40px)`;
        this.gridElement.style.gridTemplateRows = `repeat(${rows}, 40px)`;
        
        for (let y = 0; y < rows; y++) {
            this.grid[y] = [];
            for (let x = 0; x < cols; x++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                
                this.grid[y][x] = { 
                    pipe: null, 
                    hasWater: false, 
                    connections: [] 
                };
                
                this.gridElement.appendChild(cell);
            }
        }
    }
    
    createNewPuzzle() {
        this.currentExpression = this.generateExpression();
        this.correctAnswer = this.evaluateExpression(this.currentExpression);
        this.decoyAnswers = this.generateDecoyAnswers();
        this.placeStartAndAnswerPipes();
        this.generateInventory();
        this.updateDisplay();
    }
    
    generateExpression() {
        const config = this.getGameConfig();
        let expression;
        
        if (this.difficulty === 'basic') {
            const a = Math.floor(Math.random() * config.maxNumber) + 1;
            const b = Math.floor(Math.random() * config.maxNumber) + 1;
            expression = { a, b, op: '+', type: 'simple', text: `${a} + ${b}` };
        } else if (this.difficulty === 'easy') {
            const op = this.operations[Math.floor(Math.random() * this.operations.length)];
            const a = this.getRandomNumber(op, 0, config.maxNumber);
            const b = this.getRandomNumber(op, 0, config.maxNumber);
            expression = { a, b, op, type: 'simple', text: `${a} ${op} ${b}` };
        } else {
            // Medium and hard expressions
            const op1 = this.operations[Math.floor(Math.random() * this.operations.length)];
            const op2 = this.operations[Math.floor(Math.random() * this.operations.length)];
            const a = this.getRandomNumber(op1, 0, config.maxNumber);
            const b = this.getRandomNumber(op2, 0, config.maxNumber);
            const c = this.getRandomNumber(op2, 0, config.maxNumber);
            expression = { a, b, c, op1, op2, type: 'compound', text: `${a} ${op1} ${b} ${op2} ${c}` };
        }
        
        return expression;
    }
    
    getRandomNumber(operation, min, max) {
        let num = Math.floor(Math.random() * (max - min + 1)) + min;
        if (operation === 'Ã·' && num === 0) {
            num = Math.floor(Math.random() * (max - 1)) + 1;
        }
        return num;
    }
    
    evaluateExpression(expression) {
        try {
            const evalText = expression.text.replace(/Ã—/g, '*').replace(/Ã·/g, '/');
            return eval(evalText);
        } catch (e) {
            console.error('Expression evaluation error:', e);
            return 0;
        }
    }
    
    generateDecoyAnswers() {
        const config = this.getGameConfig();
        const decoys = [];
        
        while (decoys.length < config.answerPipeCount - 1) {
            let decoy = Math.floor(Math.random() * config.maxNumber) + 1;
            if (decoy !== this.correctAnswer && !decoys.includes(decoy)) {
                decoys.push(decoy);
            }
        }
        
        return decoys;
    }
    
    placeStartAndAnswerPipes() {
        const config = this.getGameConfig();
        const [cols, rows] = this.gridSize.split('x').map(Number);
        
        // Place start pipe on the left
        const startY = Math.floor(rows / 2);
        this.startPipe = { x: 0, y: startY };
        
        const startCell = this.gridElement.children[startY * cols];
        startCell.classList.add('start-pipe');
        startCell.textContent = this.currentExpression.a;
        
        // Place answer pipes on the right
        this.answerPipes = [];
        const answers = [this.correctAnswer, ...this.decoyAnswers];
        
        for (let i = 0; i < config.answerPipeCount; i++) {
            const y = Math.floor(rows / 2) - Math.floor(config.answerPipeCount / 2) + i;
            if (y >= 0 && y < rows) {
                this.answerPipes.push({
                    x: cols - 1,
                    y: y,
                    value: answers[i],
                    isCorrect: answers[i] === this.correctAnswer
                });
                
                const answerCell = this.gridElement.children[y * cols + (cols - 1)];
                answerCell.classList.add('answer-pipe');
                answerCell.textContent = answers[i];
            }
        }
    }
    
    generateInventory() {
        const inventory = document.getElementById('pipeInventory');
        inventory.innerHTML = '';
        
        const config = this.getGameConfig();
        const pipeTypes = this.getPipeTypes();
        const pipes = [];
        
        // Add numbers from the expression
        if (this.currentExpression.type === 'simple') {
            pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
        }
        
        // Ensure the answer is available
        if (!pipes.some(p => p.value === this.correctAnswer)) {
            pipes.push(pipeTypes.find(p => p.value === this.correctAnswer));
        }
        
        // Add some extra numbers
        const extraNumbers = [2, 3, 4, 6, 7, 8, 9].filter(num => 
            num !== this.currentExpression.a && num !== this.currentExpression.b
        );
        
        // Add 2-3 random extra numbers
        const extraCount = Math.min(3, extraNumbers.length);
        for (let i = 0; i < extraCount; i++) {
            const randomIndex = Math.floor(Math.random() * extraNumbers.length);
            const extraNum = extraNumbers.splice(randomIndex, 1)[0];
            pipes.push(pipeTypes.find(p => p.value === extraNum));
        }
        
        // Add operators
        pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op));
        
        // Add connector pipes
        const connectors = pipeTypes.filter(p => p.type === 'connector');
        const connectorCount = Math.min(8, connectors.length);
        for (let i = 0; i < connectorCount; i++) {
            pipes.push(connectors[i]);
        }
        
        // Filter out undefined pipes and shuffle
        const validPipes = pipes.filter(pipe => pipe !== undefined);
        const shuffledPipes = validPipes.sort(() => Math.random() - 0.5);
        
        shuffledPipes.forEach(pipe => {
            const pipeElement = document.createElement('div');
            pipeElement.className = 'pipe-piece';
            pipeElement.draggable = true;
            pipeElement.dataset.pipeType = JSON.stringify(pipe);
            
            if (pipe.type === 'number') {
                pipeElement.textContent = pipe.symbol;
                pipeElement.dataset.type = 'number';
            } else if (pipe.type === 'operator') {
                pipeElement.textContent = pipe.symbol;
                pipeElement.dataset.type = 'operator';
            } else if (pipe.type === 'connector') {
                pipeElement.innerHTML = this.svgForPipe(pipe.pipeType, 0, false);
            }
            
            inventory.appendChild(pipeElement);
        });
    }
    
    getPipeTypes() {
        return [
            // Numbers
            { type: 'number', value: 1, symbol: '1', id: 'num1' },
            { type: 'number', value: 2, symbol: '2', id: 'num2' },
            { type: 'number', value: 3, symbol: '3', id: 'num3' },
            { type: 'number', value: 4, symbol: '4', id: 'num4' },
            { type: 'number', value: 5, symbol: '5', id: 'num5' },
            { type: 'number', value: 6, symbol: '6', id: 'num6' },
            { type: 'number', value: 7, symbol: '7', id: 'num7' },
            { type: 'number', value: 8, symbol: '8', id: 'num8' },
            { type: 'number', value: 9, symbol: '9', id: 'num9' },
            
            // Operators
            { type: 'operator', operation: '+', symbol: '+', id: 'opAdd' },
            { type: 'operator', operation: '-', symbol: 'âˆ’', id: 'opSub' },
            { type: 'operator', operation: 'Ã—', symbol: 'Ã—', id: 'opMul' },
            { type: 'operator', operation: 'Ã·', symbol: 'Ã·', id: 'opDiv' },
            
            // Connector pipes
            { type: 'connector', pipeType: 'straight-h', rotation: 0, id: 'pipe1' },
            { type: 'connector', pipeType: 'straight-v', rotation: 0, id: 'pipe2' },
            { type: 'connector', pipeType: 'elbow', rotation: 0, id: 'pipe3' },
            { type: 'connector', pipeType: 'tee', rotation: 0, id: 'pipe4' },
            { type: 'connector', pipeType: 'cross', rotation: 0, id: 'pipe5' }
        ];
    }
    
    svgForPipe(type = 'straight-h', rot = 0, active = false) {
        const strokeClass = 'pipe-stroke' + (active ? ' glow' : '');
        const paths = {
            'straight-h': `<path class="${strokeClass}" d="M12 50 H88"/>`,
            'straight-v': `<path class="${strokeClass}" d="M50 12 V88"/>`,
            'elbow': `<path class="${strokeClass}" d="M12 50 H50 V12"/>`,
            'tee': `
                <path class="${strokeClass}" d="M12 50 H88"/>
                <path class="${strokeClass}" d="M50 50 V12"/>`,
            'cross': `
                <path class="${strokeClass}" d="M12 50 H88"/>
                <path class="${strokeClass}" d="M50 12 V88"/>`
        };
        const inner = {
            'straight-h': `<path class="pipe-inner" d="M12 50 H88"/>`,
            'straight-v': `<path class="pipe-inner" d="M50 12 V88"/>`,
            'elbow': `<path class="pipe-inner" d="M12 50 H50 V12"/>`,
            'tee': `
                <path class="pipe-inner" d="M12 50 H88"/>
                <path class="pipe-inner" d="M50 50 V12"/>`,
            'cross': `
                <path class="pipe-inner" d="M12 50 H88"/>
                <path class="pipe-inner" d="M50 12 V88"/>`
        };
        const endcaps = {
            'straight-h': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/>`,
            'straight-v': `<circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`,
            'elbow': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
            'tee': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
            'cross': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`
        };
        return `
        <svg viewBox="0 0 100 100">
            <g transform="rotate(${rot} 50 50)">
                ${paths[type] || paths['straight-h']}
                ${inner[type] || ''}
                ${endcaps[type] || ''}
            </g>
        </svg>`;
    }
    
    placePipe(x, y, pipeData) {
        if (!pipeData) return;
        
        // Check if position is valid (not start/answer pipes)
        const cell = this.grid[y][x];
        if (cell.pipe) {
            console.log('Position already occupied');
            return;
        }
        
        // Place pipe
        cell.pipe = { ...pipeData };
        this.pipeHistory.push({ x, y, pipe: { ...pipeData } });
        
        // Update visual
        const cellElement = this.gridElement.children[y * this.gridElement.style.gridTemplateColumns.split(' ').length + x];
        cellElement.classList.add('has-pipe');
        
        if (pipeData.type === 'number') {
            cellElement.textContent = pipeData.symbol;
        } else if (pipeData.type === 'operator') {
            cellElement.textContent = pipeData.symbol;
        } else if (pipeData.type === 'connector') {
            cellElement.innerHTML = this.svgForPipe(pipeData.pipeType, 0, false);
        }
        
        console.log(`Pipe placed at (${x}, ${y}):`, pipeData);
        
        // Remove from inventory
        this.removeFromInventory(pipeData);
    }
    
    removeFromInventory(pipeData) {
        const inventory = document.getElementById('pipeInventory');
        const pipeElements = inventory.querySelectorAll('.pipe-piece');
        
        for (const element of pipeElements) {
            const elementData = JSON.parse(element.dataset.pipeType);
            if (this.pipesEqual(elementData, pipeData)) {
                element.remove();
                break;
            }
        }
    }
    
    pipesEqual(pipe1, pipe2) {
        if (pipe1.type !== pipe2.type) return false;
        
        if (pipe1.type === 'number') return pipe1.value === pipe2.value;
        if (pipe1.type === 'operator') return pipe1.operation === pipe2.operation;
        if (pipe1.type === 'connector') return pipe1.pipeType === pipe2.pipeType;
        
        return false;
    }
    
    testWaterFlow() {
        console.log('Testing water flow...');
        // Water flow simulation would go here
    }
    
    resetLevel() {
        this.pipes = [];
        this.connectedPipes = [];
        this.pipeHistory = [];
        this.pressure = 12;
        this.createGrid();
        this.createNewPuzzle();
    }
    
    undoLastMove() {
        if (this.pipeHistory.length > 0) {
            const lastMove = this.pipeHistory.pop();
            const cell = this.grid[lastMove.y][lastMove.x];
            cell.pipe = null;
            
            const cellElement = this.gridElement.children[lastMove.y * this.gridElement.style.gridTemplateColumns.split(' ').length + lastMove.x];
            cellElement.classList.remove('has-pipe');
            cellElement.innerHTML = '';
            
            console.log('Undoing last move:', lastMove);
        }
    }
    
    showHint() {
        console.log('Showing hint...');
        // Hint logic would go here
    }
    
    applySettings() {
        this.updateOperations();
        this.createNewPuzzle();
        alert('Settings applied! New game started.');
    }
    
    startPressureTimer() {
        if (this.timer) {
            clearInterval(this.timer);
        }
        
        this.timer = setInterval(() => {
            const config = this.getGameConfig();
            this.pressure += config.pressureRate;
            
            if (this.pressure >= this.maxPressure) {
                this.gameOver();
            }
            
            this.updateDisplay();
        }, 1000);
    }
    
    updateDisplay() {
        // Update math problem
        document.getElementById('mathProblem').textContent = this.currentExpression.text + ' = ?';
        
        // Update score display
        document.getElementById('level').textContent = this.level;
        document.getElementById('score').textContent = this.score;
        document.getElementById('stars').textContent = this.stars;
        document.getElementById('pressure').textContent = Math.round((this.pressure / this.maxPressure) * 100);
        
        // Update pressure bar
        const pressureFill = document.getElementById('pressureFill');
        const pressurePercent = (this.pressure / this.maxPressure) * 100;
        pressureFill.style.width = pressurePercent + '%';
        
        // Update game container
        gameContainer.updateScore(this.score);
        gameContainer.updateLives(this.level);
    }
    
    gameOver() {
        this.gameActive = false;
        if (this.timer) {
            clearInterval(this.timer);
        }
        alert('Game Over! Pressure too high.');
    }
    
    placePipe(x, y, pipeData) {
        if (!pipeData) return;
        
        // Check if position is valid (not start/answer pipes)
        if ((x === 0 && y === 0) || (x === 9 && (y === 0 || y === 1 || y === 2))) {
            console.log('Cannot place pipe on start/answer positions');
            return;
        }
        
        // Place pipe
        this.grid[y][x].pipe = { ...pipeData };
        this.pipeHistory.push({ x, y, pipe: { ...pipeData } });
        
        // Remove from inventory
        const inventoryIndex = this.inventory.findIndex(p => p.id === pipeData.id);
        if (inventoryIndex !== -1) {
            this.inventory.splice(inventoryIndex, 1);
            this.updateInventoryDisplay();
        }
        
        // Update grid display
        this.updateGridDisplay();
        
        console.log(`Pipe placed at (${x}, ${y})`);
    }
    
    updateGridDisplay() {
        const grid = document.getElementById('gameGrid');
        if (!grid) return;
        
        // Clear existing grid
        grid.innerHTML = '';
        
        // Create grid cells
        for (let y = 0; y < this.grid.length; y++) {
            for (let x = 0; x < this.grid[y].length; x++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.x = x;
                cell.dataset.y = y;
                
                // Check if this is a special cell
                if (x === 0 && y === 2) {
                    cell.classList.add('start-pipe');
                    cell.textContent = 'S';
                } else if (x === 9 && (y === 0 || y === 1 || y === 2)) {
                    cell.classList.add('answer-pipe');
                    const answers = [this.correctAnswer, ...this.decoyAnswers];
                    cell.textContent = answers[y] || '?';
                } else if (this.grid[y][x].pipe) {
                    cell.classList.add('placed-pipe');
                    if (this.grid[y][x].pipe.type === 'connector') {
                        cell.innerHTML = this.svgForPipe(this.grid[y][x].pipe.pipeType, this.grid[y][x].pipe.rotation, true);
                    } else {
                        cell.textContent = this.grid[y][x].pipe.type === 'number' ? this.grid[y][x].pipe.value : this.grid[y][x].pipe.operation;
                    }
                }
                
                grid.appendChild(cell);
            }
        }
    }
}

// Initialize the REAL Pipe Dream game
const game = new PipeDream();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { game.gameActive = false; },
    resume: () => { game.gameActive = true; },
    restart: () => { game.resetLevel(); }
};

console.log('REAL Pipe Dream game initialized with universal system - Full SVG inventory and drag & drop restored');
</script>
</body>
</html>
