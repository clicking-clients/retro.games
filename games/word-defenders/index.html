<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Word Defenders - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with word-defenders config
const gameConfig = GAME_CONFIGS['word-defenders'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
let W = canvas.width, H = canvas.height;
let lanes = 4, playerLane = 0; // Start in leftmost lane
let laneW = W/lanes, floorY = H-48;

// Game variables
let score = 0, lives = 3, running = true, gameOver = false;
let speedValue = 2/4; // Default speed
let words = [], wordsLeft = 0, totalWordsInLevel = 20, spawnedCount = 0;
let rocketLaunched = false, lastOutcomeSuccess = false;
let startTime, timerDuration = 180;
let level = 1;

// Word lists data
const wordListsData = [
    {name:"Beginner 0 (2 letter)", words:["an", "as", "at", "in", "is", "it" ]},
    {name:"Beginner 1 (3 letter)", words:["ant", "nan", "nap", "nip", "nit", "pan", "pat", "pin", "pip", "pit", "sat", "sip", "sit", "tan", "tap", "tin", "tip" ]},
    {name:"Easy 2", words:["fish","frog","tree","milk","bird"]},
    {name:"Medium 3", words:["apple","chair","train","horse","glass"]},
    {name:"Hard 4", words:["banana","school","friend","planet","happy"]},
    {name:"Expert 5", words:["elephant","computer","kangaroo","mountain","diamond"]}
];

let wordBank = [...wordListsData[0].words];

// Quotes for encouragement
const QUOTES = ["You are brave and strong!","Trust yourselfâ€”you can do it!","Your kindness makes magic!","Every step shows courage!","You are unstoppable!","Believe in yourself!","Your heart is full of power!","You are wise and brave!","Shine with your own light!","You make the world brighter!"];
let quoteIndex = 0;

// Random spawn timing
let nextSpawnAt = 0;

// Utility functions
function laneX(l) { return l*laneW+laneW/2; }
function randWord() { return wordBank[Math.floor(Math.random()*wordBank.length)]; }
function randColor() { 
    const colors = ["#0f0","#0ff","#ff0","#f0f","#f60","#0fa","#ff3","#f3f","#3ff","#f06","#f33","#33f","#fff"];
    return colors[Math.floor(Math.random()*colors.length)];
}

function scheduleNextSpawn() {
    nextSpawnAt = Date.now() + 350 + Math.random()*1100;
}

function spawnWord() {
    if(wordsLeft <= 0 || spawnedCount >= totalWordsInLevel) return;
    if(Date.now() < nextSpawnAt) return;
    
    const l = Math.floor(Math.random()*lanes);
    const crowded = words.some(w => w.lane === l && w.y < 80 && !w.fly);
    
    if(!crowded) {
        const text = randWord();
        words.push({
            text, lane: l, y: -10, progress: 0, done: false, 
            speed: speedValue, color: randColor(), fly: false, alpha: 1
        });
        spawnedCount++;
    }
    scheduleNextSpawn();
}

function drawWord(w) {
    if(w.done) return;
    
    ctx.save();
    ctx.globalAlpha = w.alpha;
    
    // Draw word background
    ctx.fillStyle = w.color;
    ctx.fillRect(laneX(w.lane) - 40, w.y - 8, 80, 20);
    
    // Draw word text
    ctx.fillStyle = "#000";
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(w.text, laneX(w.lane), w.y + 6);
    
    // Draw progress indicator
    if(w.progress > 0) {
        ctx.fillStyle = "#fff";
        ctx.fillRect(laneX(w.lane) - 40, w.y - 8, (w.progress / w.text.length) * 80, 20);
        ctx.fillStyle = "#000";
        ctx.fillText(w.text.substring(0, w.progress), laneX(w.lane), w.y + 6);
    }
    
    ctx.restore();
}

function draw() {
    // Clear canvas
    ctx.fillStyle = "#000"; 
    ctx.fillRect(0, 0, W, H);
    
    // Draw lane dividers
    ctx.strokeStyle = "#0f0"; 
    ctx.lineWidth = 1;
    for(let l = 1; l < lanes; l++) {
        ctx.beginPath(); 
        ctx.moveTo(l*laneW+0.5, 0); 
        ctx.lineTo(l*laneW+0.5, H); 
        ctx.stroke();
    }
    
    // Draw floor
    ctx.beginPath(); 
    ctx.moveTo(0, floorY+12); 
    ctx.lineTo(W, floorY+12); 
    ctx.stroke();
    
    // Draw words
    for(const w of words) drawWord(w);
    
    // Draw UI
    ctx.fillStyle = "#0f0"; 
    ctx.font = '16px monospace'; 
    ctx.textAlign = 'left'; 
    ctx.fillText(`LIVES: ${lives}`, 8, 16);
    
    // Draw player
    ctx.textAlign = 'center';
    ctx.fillStyle = "#ff0"; 
    ctx.fillRect(laneX(playerLane)-15, floorY-12, 30, 12);
    
    // Draw status
    ctx.fillStyle = "#0f0"; 
    ctx.textAlign = 'right'; 
    ctx.fillText(running ? 'RUN' : 'PAUSE', W-8, 16);
}

function step() {
    if(!running) { 
        draw(); 
        requestAnimationFrame(step); 
        return; 
    }
    
    spawnWord();
    
    // Move words down
    for(const w of words) { 
        if(!w.done && !w.fly) w.y += speedValue; 
    }
    
    // Check for missed words
    for(const w of words) {
        if(!w.done && !w.fly && w.y >= floorY) {
            lives--; 
            w.done = true; 
            wordsLeft = Math.max(0, wordsLeft-1);
            
            if(lives <= 0) {
                gameOver = true; 
                running = false; 
                lastOutcomeSuccess = false;
            }
        }
    }
    
    // Check level completion
    if(!gameOver && wordsLeft === 0) {
        running = false;
        lastOutcomeSuccess = (lives > 0);
        if(lastOutcomeSuccess) {
            // Level complete!
            level++;
            gameContainer.updateLives(level);
        }
    }
    
    // Update score
    gameContainer.updateScore(score);
    
    draw();
    requestAnimationFrame(step);
}

function wordInPlayerLane() {
    const candidates = words.filter(w => !w.done && !w.fly && w.lane === playerLane);
    candidates.sort((a,b) => b.y - a.y);
    return candidates[0] || null;
}

function resetLevel() {
    words = [];
    wordsLeft = totalWordsInLevel;
    spawnedCount = 0;
    running = true;
    gameOver = false;
    rocketLaunched = false;
    startTime = Date.now();
    scheduleNextSpawn();
}

// Event listeners
gameContainer.on('keydown', (e) => {
    if(e.key === '1' || e.key === 'ArrowLeft') {
        playerLane = Math.max(0, playerLane-1);
        return;
    }
    if(e.key === '2' || e.key === 'ArrowRight') {
        playerLane = Math.min(lanes-1, playerLane+1);
        return;
    }
    if(e.code === 'Space') {
        running = !running;
        return;
    }
    if(e.key === '0') {
        resetLevel();
        return;
    }
    
    // Handle letter input
    if(e.key.length === 1 && /[a-z]/i.test(e.key)) {
        const target = wordInPlayerLane();
        if(!target) return;
        
        const expected = target.text[target.progress] || '';
        if(e.key.toLowerCase() === expected) {
            target.progress++;
            if(target.progress >= target.text.length) {
                target.fly = true; 
                target.done = true; 
                wordsLeft = Math.max(0, wordsLeft-1);
                score += target.text.length;
            }
        }
    }
});

// Touch controls for mobile
let touchStartX = 0;
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    
    // Move player based on touch position
    const touchLane = Math.floor((touchX / W) * lanes);
    playerLane = Math.max(0, Math.min(lanes-1, touchLane));
});

// Initialize game
resetLevel();
step();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { running = false; },
    resume: () => { running = true; },
    restart: resetLevel
};

console.log('Word Defenders game initialized with universal system');
</script>
</body>
</html>
