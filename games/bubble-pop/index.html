<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Bubble Pop - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with bubble-pop config
const gameConfig = GAME_CONFIGS['bubble-pop'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Add custom paddle speed controls to the sidebar
const sidebar = gameContainer.elements.sidebar;
if (sidebar) {
    const speedControl = document.createElement('div');
    speedControl.className = 'sidebar-section';
    speedControl.innerHTML = `
        <div class="section-title">PADDLE SPEED</div>
        <div style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
            <input type="range" id="paddleSpeedSlider" min="0.5" max="3.0" step="0.1" value="1.0" 
                   style="flex: 1; accent-color: var(--retro-green);">
            <span id="paddleSpeedValue" style="color: var(--retro-green); font-weight: bold;">1.0</span>
        </div>
        <div style="font-size: 12px; color: var(--retro-green); opacity: 0.8;">
            Adjust paddle movement speed
        </div>
    `;
    
    // Insert after the first section (scoreboard)
    const firstSection = sidebar.querySelector('.sidebar-section');
    if (firstSection) {
        sidebar.insertBefore(speedControl, firstSection.nextSibling);
    }
    
    // Add event listener for speed control
    const speedSlider = document.getElementById('paddleSpeedSlider');
    const speedValue = document.getElementById('paddleSpeedValue');
    
    speedSlider.addEventListener('input', (e) => {
        paddleSpeed = parseFloat(e.target.value);
        speedValue.textContent = paddleSpeed.toFixed(1);
    });
}

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const scale = 20;
const rows = canvas.height / scale;
const cols = canvas.width / scale;

// Game variables
let score = 0;
let lives = 3;
let level = 1;
let paused = false;
let respawning = false;
let paddleSpeed = 1.0; // Increased default speed and made adjustable

// Game objects
const paddle = { 
    width: 6, 
    height: 1, 
    x: Math.floor(cols/2 - 3), 
    y: rows - 2 
};

const ball = { 
    x: cols/2, 
    y: rows-3, 
    dx: 0.15, 
    dy: -0.15, 
    size: 1 
};

const brickRows = 6;
const brickCols = 10;
const bricks = [];
const brickColors = ['#ff0000', '#ff8000', '#ffff00', '#00ff00', '#00ffff', '#ff00ff'];

// Initialize bricks
function initBricks() {
    bricks.length = 0;
    for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
            bricks.push({ 
                x: 2 + c * 4, 
                y: 2 + r * 2, 
                w: 3, 
                h: 1, 
                alive: true, 
                color: brickColors[r % brickColors.length] 
            });
        }
    }
}

// Draw function
function draw() {
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.scale(scale, scale);

    // Draw paddle
    ctx.fillStyle = '#0f0';
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

    // Draw ball
    ctx.fillStyle = '#ff0';
    ctx.fillRect(ball.x, ball.y, ball.size, ball.size);

    // Draw bricks
    bricks.forEach(b => {
        if (b.alive) {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, b.y, b.w, b.h);
        }
    });

    ctx.restore();
    
    // Update game container UI
    gameContainer.updateScore(score);
    gameContainer.updateLives(lives);
}

// Update function
function update() {
    if (paused || respawning) { 
        requestAnimationFrame(update); 
        return; 
    }

    updatePaddle();
    updateBall();
    checkCollisions();
    checkLevelComplete();

    draw();
    requestAnimationFrame(update);
}

// Update paddle
function updatePaddle() {
    // Paddle movement will be handled by input events
}

// Update ball
function updateBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;
}

// Check collisions
function checkCollisions() {
    // Wall collisions
    if (ball.x < 0 || ball.x + ball.size > cols) {
        ball.dx *= -1;
    }
    if (ball.y < 0) {
        ball.dy *= -1;
    }

    // Paddle collision
    if (ball.y + ball.size >= paddle.y && 
        ball.x + ball.size >= paddle.x && 
        ball.x <= paddle.x + paddle.width) {
        ball.dy *= -1;
        let hitPos = (ball.x - paddle.x) / paddle.width - 0.5;
        ball.dx = hitPos * 0.4;
    }

    // Brick collisions
    bricks.forEach(b => {
        if (b.alive &&
            ball.x < b.x + b.w &&
            ball.x + ball.size > b.x &&
            ball.y < b.y + b.h &&
            ball.y + ball.size > b.y) {
            b.alive = false;
            ball.dy *= -1;
            score += 10;
        }
    });

    // Ball out of bounds
    if (ball.y > rows) {
        lives--;
        if (lives <= 0) {
            gameOver();
        } else {
            respawnBall();
        }
    }
}

// Check level complete
function checkLevelComplete() {
    if (!bricks.some(b => b.alive)) {
        level++;
        gameContainer.updateLives(level);
        initBricks();
        respawnBall();
    }
}

// Respawn ball
function respawnBall() {
    ball.x = cols/2;
    ball.y = rows-3;
    ball.dx = 0.15;
    ball.dy = -0.15;
    respawning = false;
}

// Game over
function gameOver() {
    paused = true;
    // Could add game over screen here
}

// Reset game
function resetGame() {
    score = 0;
    level = 1;
    lives = 3;
    paused = false;
    respawning = false;
    
    paddle.x = Math.floor(cols/2 - 3);
    paddle.y = rows - 2;
    
    ball.x = cols/2;
    ball.y = rows-3;
    ball.dx = 0.15;
    ball.dy = -0.15;
    
    initBricks();
    
    gameContainer.updateScore(score);
    gameContainer.updateLives(level);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    switch(e.key) {
        case 'ArrowLeft':
        case 'a':
        case 'A':
            if (paddle.x > 0) {
                paddle.x -= paddleSpeed;
            }
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            if (paddle.x + paddle.width < cols) {
                paddle.x += paddleSpeed;
            }
            break;
        case ' ':
            paused = !paused;
            if (!paused) {
                update();
            }
            break;
        case 'r':
        case 'R':
            resetGame();
            update();
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
});

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    
    // Move paddle based on touch position
    const paddleX = (touchX / canvas.width) * cols - paddle.width / 2;
    paddle.x = Math.max(0, Math.min(cols - paddle.width, paddleX));
});

// Initialize game
initBricks();
update();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { paused = true; },
    resume: () => { paused = false; update(); },
    restart: resetGame
};

console.log('REAL Bubble Pop (Wall Breaker) game initialized with universal system');
</script>
</body>
</html>
