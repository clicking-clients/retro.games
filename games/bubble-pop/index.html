<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Bubble Pop - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with bubble-pop config
const gameConfig = GAME_CONFIGS['bubble-pop'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game variables
let bubbles = [];
let score = 0;
let gameRunning = true;
let mouseX = 0;
let mouseY = 0;

// Bubble class
class Bubble {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 30 + 20;
        this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
        this.velocity = {
            x: (Math.random() - 0.5) * 2,
            y: (Math.random() - 0.5) * 2
        };
        this.gravity = 0.1;
        this.bounce = 0.8;
        this.popped = false;
    }

    update() {
        if (this.popped) return;

        // Apply gravity
        this.velocity.y += this.gravity;

        // Update position
        this.x += this.velocity.x;
        this.y += this.velocity.y;

        // Bounce off walls
        if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
            this.velocity.x *= -this.bounce;
            this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
        }

        if (this.y + this.radius >= canvas.height) {
            this.velocity.y *= -this.bounce;
            this.y = canvas.height - this.radius;
        }

        // Bounce off ceiling
        if (this.y - this.radius <= 0) {
            this.velocity.y *= -this.bounce;
            this.y = this.radius;
        }

        // Add some air resistance
        this.velocity.x *= 0.99;
        this.velocity.y *= 0.99;
    }

    draw() {
        if (this.popped) return;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Add highlight
        ctx.beginPath();
        ctx.arc(this.x - this.radius * 0.3, this.y - this.radius * 0.3, this.radius * 0.2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.fill();
    }

    isClicked(x, y) {
        const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
        return distance <= this.radius;
    }

    pop() {
        this.popped = true;
        score += Math.floor(this.radius);
        gameContainer.updateScore(score);
        
        // Create pop effect
        createPopEffect(this.x, this.y, this.color);
    }
}

// Pop effect
function createPopEffect(x, y, color) {
    const particles = [];
    const particleCount = 8;
    
    for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2;
        const speed = Math.random() * 3 + 2;
        
        particles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1,
            color: color
        });
    }

    // Animate particles
    function animateParticles() {
        particles.forEach((particle, index) => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 0.02;
            particle.vy += 0.1; // gravity

            if (particle.life <= 0) {
                particles.splice(index, 1);
            }
        });

        // Draw particles
        particles.forEach(particle => {
            ctx.save();
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });

        if (particles.length > 0) {
            requestAnimationFrame(animateParticles);
        }
    }

    animateParticles();
}

// Create initial bubbles
function createBubbles() {
    for (let i = 0; i < 15; i++) {
        bubbles.push(new Bubble(
            Math.random() * canvas.width,
            Math.random() * canvas.height
        ));
    }
}

// Game loop
function gameLoop() {
    if (!gameRunning) return;

    // Clear canvas
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Update and draw bubbles
    bubbles.forEach(bubble => {
        bubble.update();
        bubble.draw();
    });

    // Remove popped bubbles
    bubbles = bubbles.filter(bubble => !bubble.popped);

    // Add new bubbles if needed
    if (bubbles.length < 10) {
        bubbles.push(new Bubble(
            Math.random() * canvas.width,
            Math.random() * canvas.height
        ));
    }

    // Draw score
    ctx.fillStyle = '#fff';
    ctx.font = '24px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 20, 40);

    requestAnimationFrame(gameLoop);
}

// Event listeners
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});

canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;

    // Check if any bubble was clicked
    bubbles.forEach(bubble => {
        if (bubble.isClicked(clickX, clickY)) {
            bubble.pop();
        }
    });
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;

    bubbles.forEach(bubble => {
        if (bubble.isClicked(touchX, touchY)) {
            bubble.pop();
        }
    });
});

// Initialize game
createBubbles();
gameLoop();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { gameRunning = false; },
    resume: () => { gameRunning = true; gameLoop(); },
    restart: () => {
        score = 0;
        gameContainer.updateScore(score);
        bubbles = [];
        createBubbles();
        gameRunning = true;
        gameLoop();
    }
};

console.log('Bubble Pop game initialized with universal system');
</script>
</body>
</html>
