<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Road Dash - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with road-dash config
const gameConfig = GAME_CONFIGS['road-dash'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const scale = 20;
const rows = canvas.height / scale; // 24
const cols = canvas.width / scale;  // 48

// Game variables
let paused = false;
let score = 0;
let level = 1;
let baseCarSpeed = 0.12; // tiles per frame at level 1
let respawning = false;
let respawnTimerId = null;
let fadeIntervalId = null;

// Game objects
const frog = {x: Math.floor(cols/2), y: rows-1, alpha: 1};
const cars = [];
const carRows = [3, 5, 7, 9]; // lanes
const CARS_PER_LANE = 3;

// Utility functions
function randInt(min, max) { 
    return Math.floor(Math.random() * (max - min + 1)) + min; 
}

function randFloat(min, max) { 
    return Math.random() * (max - min) + min; 
}

// Spawn car
function spawnCar(laneIndex) {
    const y = carRows[laneIndex];
    const dir = (laneIndex % 2 === 0) ? 1 : -1; // alternate directions per lane
    const len = randInt(2, 5); // 2..5 tiles
    const speedMag = baseCarSpeed * level * randFloat(0.8, 1.4);
    const speed = dir * speedMag;
    const startOffset = randInt(0, cols); // random off-screen distance
    let x;
    
    if (dir > 0) {
        x = -startOffset - len; // start left off-screen
    } else {
        x = cols + startOffset; // start right off-screen
    }
    
    return { x, y, len, speed, dir };
}

// Respawn car
function respawnCar(car) {
    const gap = randInt(2, 15);   // varied off-screen gap
    car.len = randInt(2, 5);       // new random length
    const speedMag = baseCarSpeed * level * randFloat(0.8, 1.4); // new random speed
    car.speed = car.dir * speedMag;
    
    if (car.dir > 0) {
        car.x = -car.len - gap;
    } else {
        car.x = cols + gap;
    }
}

// Initialize cars
function initCars() {
    cars.length = 0;
    for (let i = 0; i < carRows.length; i++) {
        for (let k = 0; k < CARS_PER_LANE; k++) {
            const car = spawnCar(i);
            // Stagger cars within lane for spacing
            const spacing = Math.floor(cols / CARS_PER_LANE) + randInt(2, 8);
            if (car.dir > 0) {
                car.x -= k * spacing;
            } else {
                car.x += k * spacing;
            }
            cars.push(car);
        }
    }
}

// Draw function
function draw() {
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.save();
    ctx.scale(scale, scale);

    // Draw frog with alpha for fade-in
    ctx.globalAlpha = frog.alpha;
    ctx.fillStyle = '#0f0';
    ctx.fillRect(frog.x, frog.y, 1, 1);
    ctx.globalAlpha = 1;

    // Draw cars (snap to integer tile for crisp pixels)
    ctx.fillStyle = '#f00';
    cars.forEach(car => {
        const baseX = Math.floor(car.x);
        for (let i = 0; i < car.len; i++) {
            ctx.fillRect(baseX + i, car.y, 1, 1);
        }
    });

    ctx.restore();
    
    // Update game container UI
    gameContainer.updateScore(score);
    gameContainer.updateLives(level);
}

// Update function
function update() {
    if (paused) { 
        requestAnimationFrame(update); 
        return; 
    }

    if (!respawning) {
        // Move cars & handle respawn
        cars.forEach(car => {
            car.x += car.speed;
            if (car.dir > 0 && car.x - car.len > cols) {
                respawnCar(car);
            } else if (car.dir < 0 && car.x + car.len < 0) {
                respawnCar(car);
            }
        });

        // Collision check (tile-accurate)
        for (const car of cars) {
            const carStart = Math.floor(car.x);
            const carEnd = carStart + car.len; // exclusive
            if (frog.y === car.y && frog.x >= carStart && frog.x < carEnd) {
                dramaticHit();
                break;
            }
        }

        // Goal reached
        if (frog.y === 0) {
            score++;
            level++;
            frog.y = rows - 1;
            frog.x = Math.floor(cols/2);
            gameContainer.updateScore(score);
            gameContainer.updateLives(level);
        }
    }

    draw();
    requestAnimationFrame(update);
}

// Dramatic hit effect
function dramaticHit() {
    respawning = true;
    
    // Reset frog position
    frog.x = Math.floor(cols/2);
    frog.y = rows - 1;
    frog.alpha = 0.3;
    
    // Fade in effect
    if (fadeIntervalId) clearInterval(fadeIntervalId);
    fadeIntervalId = setInterval(() => {
        frog.alpha = Math.min(1, frog.alpha + 0.1);
        if (frog.alpha >= 1) {
            clearInterval(fadeIntervalId);
            respawning = false;
        }
    }, 50);
}

// Reset game
function resetGame() {
    score = 0;
    level = 1;
    paused = false;
    respawning = false;
    
    frog.x = Math.floor(cols/2);
    frog.y = rows - 1;
    frog.alpha = 1;
    
    if (respawnTimerId) clearTimeout(respawnTimerId);
    if (fadeIntervalId) clearInterval(fadeIntervalId);
    
    initCars();
    
    gameContainer.updateScore(score);
    gameContainer.updateLives(level);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    if (respawning) return;
    
    switch(e.key) {
        case 'ArrowUp':
            if (frog.y > 0) frog.y--;
            break;
        case 'ArrowDown':
            if (frog.y < rows - 1) frog.y++;
            break;
        case 'ArrowLeft':
            if (frog.x > 0) frog.x--;
            break;
        case 'ArrowRight':
            if (frog.x < cols - 1) frog.x++;
            break;
        case 'p':
        case 'P':
            paused = !paused;
            if (!paused) {
                update();
            }
            break;
        case 'r':
        case 'R':
            resetGame();
            update();
            break;
        case ' ':
            if (respawning) {
                respawning = false;
                frog.alpha = 1;
                if (fadeIntervalId) clearInterval(fadeIntervalId);
            }
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
    touchStartY = touch.clientY - rect.top;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    
    // Determine swipe direction
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0 && frog.x < cols - 1) {
            frog.x++;
        } else if (deltaX < 0 && frog.x > 0) {
            frog.x--;
        }
    } else {
        if (deltaY > 0 && frog.y < rows - 1) {
            frog.y++;
        } else if (deltaY < 0 && frog.y > 0) {
            frog.y--;
        }
    }
});

// Initialize game
initCars();
update();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { paused = true; },
    resume: () => { paused = false; update(); },
    restart: resetGame
};

console.log('REAL Road Dash game initialized with universal system');
</script>
</body>
</html>
