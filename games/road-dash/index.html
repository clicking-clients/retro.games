<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Road Dash - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with road-dash config
const gameConfig = GAME_CONFIGS['road-dash'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game variables
let frog = { x: canvas.width / 2, y: canvas.height - 50, size: 20 };
let cars = [];
let logs = [];
let score = 0;
let lives = 3;
let gameRunning = true;
let gameOver = false;
let level = 1;

// Game settings
const carSpeed = 2;
const logSpeed = 1.5;
const frogSpeed = 30;

// Initialize game objects
function initGame() {
    // Create cars
    cars = [];
    for (let i = 0; i < 5; i++) {
        cars.push({
            x: Math.random() * canvas.width,
            y: 100 + i * 80,
            width: 40,
            height: 20,
            speed: carSpeed + Math.random() * 2,
            direction: Math.random() < 0.5 ? 1 : -1
        });
    }

    // Create logs
    logs = [];
    for (let i = 0; i < 3; i++) {
        logs.push({
            x: Math.random() * canvas.width,
            y: 200 + i * 80,
            width: 60,
            height: 30,
            speed: logSpeed + Math.random() * 1,
            direction: Math.random() < 0.5 ? 1 : -1
        });
    }
}

// Draw functions
function drawFrog() {
    ctx.fillStyle = '#0f0';
    ctx.fillRect(frog.x - frog.size/2, frog.y - frog.size/2, frog.size, frog.size);
    
    // Eyes
    ctx.fillStyle = '#000';
    ctx.fillRect(frog.x - 8, frog.y - 8, 4, 4);
    ctx.fillRect(frog.x + 4, frog.y - 8, 4, 4);
}

function drawCars() {
    cars.forEach(car => {
        ctx.fillStyle = '#f00';
        ctx.fillRect(car.x, car.y, car.width, car.height);
        
        // Car details
        ctx.fillStyle = '#800';
        ctx.fillRect(car.x + 5, car.y + 5, car.width - 10, car.height - 10);
    });
}

function drawLogs() {
    logs.forEach(log => {
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(log.x, log.y, log.width, log.height);
        
        // Log texture
        ctx.fillStyle = '#654321';
        ctx.fillRect(log.x + 5, log.y + 5, log.width - 10, log.height - 10);
    });
}

function drawRoad() {
    // Road background
    ctx.fillStyle = '#333';
    ctx.fillRect(0, 50, canvas.width, 200);
    
    // Lane dividers
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    for (let i = 0; i < 4; i++) {
        const y = 100 + i * 50;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawRiver() {
    // River background
    ctx.fillStyle = '#0066cc';
    ctx.fillRect(0, 250, canvas.width, 150);
    
    // River texture
    ctx.strokeStyle = '#004499';
    ctx.lineWidth = 1;
    for (let i = 0; i < 10; i++) {
        const y = 260 + i * 15;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawSafeZone() {
    ctx.fillStyle = '#0a5';
    ctx.fillRect(0, 400, canvas.width, 50);
}

function drawUI() {
    ctx.fillStyle = '#fff';
    ctx.font = '20px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 20, 30);
    ctx.fillText(`Lives: ${lives}`, 20, 55);
    ctx.fillText(`Level: ${level}`, 20, 80);
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#f00';
    ctx.font = '48px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
    
    ctx.fillStyle = '#fff';
    ctx.font = '24px monospace';
    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
    ctx.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 100);
}

// Update functions
function updateCars() {
    cars.forEach(car => {
        car.x += car.speed * car.direction;
        
        // Wrap around screen
        if (car.x > canvas.width + car.width) {
            car.x = -car.width;
        } else if (car.x < -car.width) {
            car.x = canvas.width + car.width;
        }
    });
}

function updateLogs() {
    logs.forEach(log => {
        log.x += log.speed * log.direction;
        
        // Wrap around screen
        if (log.x > canvas.width + log.width) {
            log.x = -log.width;
        } else if (log.x < -log.width) {
            log.x = canvas.width + log.width;
        }
    });
}

function checkCollisions() {
    // Check car collisions
    cars.forEach(car => {
        if (frog.x + frog.size/2 > car.x && 
            frog.x - frog.size/2 < car.x + car.width &&
            frog.y + frog.size/2 > car.y && 
            frog.y - frog.size/2 < car.y + car.height) {
            lives--;
            gameContainer.updateLives(lives);
            resetFrog();
            
            if (lives <= 0) {
                gameOver = true;
                gameRunning = false;
            }
        }
    });
    
    // Check log collisions (for safe crossing)
    let onLog = false;
    logs.forEach(log => {
        if (frog.x + frog.size/2 > log.x && 
            frog.x - frog.size/2 < log.x + log.width &&
            frog.y + frog.size/2 > log.y && 
            frog.y - frog.size/2 < log.y + log.height) {
            onLog = true;
            // Move frog with log
            frog.x += log.speed * log.direction;
        }
    });
    
    // If frog is in river but not on log, lose life
    if (frog.y > 250 && frog.y < 400 && !onLog) {
        lives--;
        gameContainer.updateLives(lives);
        resetFrog();
        
        if (lives <= 0) {
            gameOver = true;
            gameRunning = false;
        }
    }
}

function resetFrog() {
    frog.x = canvas.width / 2;
    frog.y = canvas.height - 50;
}

function checkWin() {
    if (frog.y <= 50) {
        score += 100;
        level++;
        gameContainer.updateScore(score);
        resetFrog();
        
        // Increase difficulty
        cars.forEach(car => car.speed += 0.5);
        logs.forEach(log => log.speed += 0.3);
    }
}

// Main game loop
function gameLoop() {
    if (!gameRunning) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw game elements
    drawRoad();
    drawRiver();
    drawSafeZone();
    drawCars();
    drawLogs();
    drawFrog();
    drawUI();
    
    // Update game objects
    updateCars();
    updateLogs();
    
    // Check collisions and win condition
    checkCollisions();
    checkWin();
    
    // Keep frog on screen
    frog.x = Math.max(frog.size/2, Math.min(canvas.width - frog.size/2, frog.x));
    frog.y = Math.max(frog.size/2, Math.min(canvas.height - frog.size/2, frog.y));
    
    requestAnimationFrame(gameLoop);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    if (gameOver) {
        if (e.key === 'r' || e.key === 'R') {
            restartGame();
        }
        return;
    }
    
    switch(e.key) {
        case 'ArrowLeft':
            frog.x -= frogSpeed;
            break;
        case 'ArrowRight':
            frog.x += frogSpeed;
            break;
        case 'ArrowUp':
            frog.y -= frogSpeed;
            break;
        case 'ArrowDown':
            frog.y += frogSpeed;
            break;
        case ' ':
            gameRunning = !gameRunning;
            if (gameRunning) gameLoop();
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const deltaX = touch.clientX - touchStartX;
    const deltaY = touch.clientY - touchStartY;
    
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 20) frog.x += frogSpeed;
        else if (deltaX < -20) frog.x -= frogSpeed;
    } else {
        if (deltaY > 20) frog.y += frogSpeed;
        else if (deltaY < -20) frog.y -= frogSpeed;
    }
});

function restartGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameOver = false;
    gameRunning = true;
    gameContainer.updateScore(score);
    gameContainer.updateLives(lives);
    resetFrog();
    initGame();
    gameLoop();
}

// Initialize game
initGame();
gameLoop();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { gameRunning = false; },
    resume: () => { gameRunning = true; gameLoop(); },
    restart: restartGame
};

console.log('Road Dash game initialized with universal system');
</script>
</body>
</html>
