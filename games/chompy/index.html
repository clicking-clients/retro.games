<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Chompy - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with chompy config
const gameConfig = GAME_CONFIGS['chompy'];
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const TILE = 20;
const COLS = 28;
const ROWS = 32;
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;

// Game variables
let score = 0;
let level = 1;
let lives = 3;
let paused = false;
let gameEnded = false;
let lastFrame = performance.now();
// Maps
const MAPS = [
    // Classic map
    ["############################",
     "#............##............#",
     "#.####.#####.##.#####.####.#",
     "#o####.#####.##.#####.####o#",
     "#.####.#####.##.#####.####.#",
     "#..........................#",
     "#.####.##.########.##.####.#",
     "#.####.##.########.##.####.#",
     "#......##....##....##......#",
     "######.##### ## #####.######",
     "     #.##### ## #####.#     ",
     "     #.##          ##.#     ",
     "######.## ###HH### ##.######",
     "      .   #HHHHHH#   .      ",
     "######.## ######## ##.######",
     "     #.##          ##.#     ",
     "     #.## ######## ##.#     ",
     "######.## ######## ##.######",
     "#............##............#",
     "#.####.#####.##.#####.####.#",
     "#o..##.....o..##..o.....##o#",
     "###.##.##.########.##.##.###",
     "#......##....##....##......#",
     "#.##########.##.##########.#",
     "#..........................#",
     "#.####.#####.##.#####.####.#",
     "#o####.#####.##.#####.####o#",
     "#.####.#####.##.#####.####.#",
     "#..........................#",
     "#............##............#",
     "############################"]
];

let currentMapIndex = 0;
let board = []; // Declare board globally

// Player (Pac-Man)
const pac = {
    x: 14,
    y: 23,
    vx: 0,
    vy: 0,
    nextVX: 0,
    nextVY: 0,
    baseSpeed: 0.15,
    speed: 0.15,
    mouth: 0
};

// Ghosts
const ghosts = [
    { x: 13, y: 11, vx: 0, vy: 0, baseSpeed: 0.12, color: '#ff0000' },
    { x: 14, y: 11, vx: 0, vy: 0, baseSpeed: 0.12, color: '#ffb8ff' },
    { x: 15, y: 11, vx: 0, vy: 0, baseSpeed: 0.12, color: '#00ffff' },
    { x: 16, y: 11, vx: 0, vy: 0, baseSpeed: 0.12, color: '#ffb852' }
];

let frightenedTimer = 0;

// Game functions
function loadBoard() {
    board = MAPS[currentMapIndex].map(row => row.split(''));
}

function isCenter(entity) {
    return Math.abs(entity.x - Math.round(entity.x)) < 0.1 && 
           Math.abs(entity.y - Math.round(entity.y)) < 0.1;
}

function canMoveInt(x, y, vx, vy, isPac) {
    const newX = x + vx;
    const newY = y + vy;
    
    if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) return false;
    
    const tile = board[Math.round(newY)][Math.round(newX)];
    return tile !== '#' && tile !== 'H';
}

function moveEntity(entity, isPac) {
    entity.x += entity.vx * entity.speed;
    entity.y += entity.vy * entity.speed;
    
    // Wrap around tunnel
    if (entity.x < 0) entity.x = COLS - 1;
    if (entity.x >= COLS) entity.x = 0;
}

function update() {
    if (paused) return;
    
    const now = performance.now();
    const dt = Math.min(50, now - lastFrame);
    lastFrame = now;
    
    // Update Pac-Man speed based on level
    pac.speed = Math.min(0.22, pac.baseSpeed + (level - 1) * 0.01);
    ghosts.forEach(g => g.speed = Math.min(0.28, g.baseSpeed * (1 + (level - 1) * 0.04)));
    
    // Update Pac-Man mouth animation
    pac.mouth += 0.28 * (dt / 16);
    
    // Handle Pac-Man movement
    if (isCenter(pac) && canMoveInt(Math.round(pac.x), Math.round(pac.y), pac.nextVX, pac.nextVY, true)) {
        pac.vx = pac.nextVX;
        pac.vy = pac.nextVY;
    }
    
    moveEntity(pac, true);
    
    // Eat pellets
    if (isCenter(pac)) {
        const cx = Math.round(pac.x);
        const cy = Math.round(pac.y);
        const tile = board[cy][cx];
        
        if (tile === '.') {
            board[cy][cx] = ' ';
            score += 10;
            gameContainer.updateScore(score);
        } else if (tile === 'o') {
            board[cy][cx] = ' ';
            score += 50;
            frightenedTimer = Math.max(frightenedTimer, 60 * 6);
            gameContainer.updateScore(score);
        }
    }
    
    // Update ghosts
    updateGhosts();
    
    // Check level completion
    if (!board.some(row => row.includes('.') || row.includes('o'))) {
        level++;
        gameContainer.updateLives(level);
        loadBoard();
    }
}

function updateGhosts() {
    ghosts.forEach(g => {
        if (isCenter(g)) {
            const cx = Math.round(g.x);
            const cy = Math.round(g.y);
            const DIRS = [{vx: 1, vy: 0}, {vx: -1, vy: 0}, {vx: 0, vy: 1}, {vx: 0, vy: -1}];
            let valid = DIRS.filter(d => canMoveInt(cx, cy, d.vx, d.vy, false));
            
            if (valid.length > 0) {
                let choice;
                if (frightenedTimer > 0) {
                    // Frightened mode - random movement
                    choice = valid[Math.floor(Math.random() * valid.length)];
                } else {
                    // Chase mode - move towards Pac-Man
                    valid.sort((a, b) => {
                        const ax = cx + a.vx - pac.x;
                        const ay = cy + a.vy - pac.y;
                        const bx = cx + b.vx - pac.x;
                        const by = cy + b.vy - pac.y;
                        return (ax * ax + ay * ay) - (bx * bx + by * by);
                    });
                    choice = valid[0];
                }
                
                g.vx = choice.vx;
                g.vy = choice.vy;
            }
        }
        
        moveEntity(g, false);
    });
    
    // Update frightened timer
    if (frightenedTimer > 0) {
        frightenedTimer--;
    }
}

function draw() {
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw board
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            const tile = board[y][x];
            const drawX = x * TILE;
            const drawY = y * TILE;
            
            if (tile === '#') {
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(drawX, drawY, TILE, TILE);
            } else if (tile === '.') {
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(drawX + TILE/2 - 2, drawY + TILE/2 - 2, 4, 4);
            } else if (tile === 'o') {
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.arc(drawX + TILE/2, drawY + TILE/2, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    // Draw Pac-Man
    drawPacMan();
    
    // Draw ghosts
    drawGhosts();
    
    // Draw UI
    drawUI();
}

function drawPacMan() {
    ctx.save();
    ctx.translate(pac.x * TILE + TILE/2, pac.y * TILE + TILE/2);
    
    // Rotate based on direction
    if (pac.vx > 0) ctx.rotate(0);
    else if (pac.vx < 0) ctx.rotate(Math.PI);
    else if (pac.vy > 0) ctx.rotate(Math.PI/2);
    else if (pac.vy < 0) ctx.rotate(-Math.PI/2);
    
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(0, 0, TILE/2, pac.mouth, 2*Math.PI - pac.mouth);
    ctx.lineTo(0, 0);
    ctx.fill();
    
    ctx.restore();
}

function drawGhosts() {
    ghosts.forEach(g => {
        ctx.save();
        ctx.translate(g.x * TILE + TILE/2, g.y * TILE + TILE/2);
        
        // Ghost body
        ctx.fillStyle = frightenedTimer > 0 ? '#0000ff' : g.color;
        ctx.beginPath();
        ctx.arc(0, 0, TILE/2, 0, Math.PI);
        ctx.rect(-TILE/2, 0, TILE, TILE/2);
        ctx.fill();
        
        // Ghost eyes
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-TILE/4, -TILE/6, TILE/8, TILE/8);
        ctx.fillRect(TILE/8, -TILE/6, TILE/8, TILE/8);
        
        ctx.restore();
    });
}

function drawUI() {
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 20);
    ctx.fillText(`Level: ${level}`, 10, 40);
    ctx.fillText(`Lives: ${lives}`, 10, 60);
    
    if (paused) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '24px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    const k = e.key;
    
    switch(k) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            pac.nextVX = 0;
            pac.nextVY = -1;
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            pac.nextVX = 0;
            pac.nextVY = 1;
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            pac.nextVX = -1;
            pac.nextVY = 0;
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            pac.nextVX = 1;
            pac.nextVY = 0;
            break;
        case 'p':
        case 'P':
            if (!gameEnded) {
                paused = !paused;
            }
            break;
        case 'r':
        case 'R':
            // Reset game
            score = 0;
            level = 1;
            lives = 3;
            paused = false;
            gameEnded = false;
            frightenedTimer = 0;
            pac.x = 14;
            pac.y = 23;
            pac.vx = 0;
            pac.vy = 0;
            pac.nextVX = 0;
            pac.nextVY = 0;
            loadBoard();
            gameContainer.updateScore(score);
            gameContainer.updateLives(level);
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
    touchStartY = touch.clientY - rect.top;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    
    // Determine swipe direction
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 0) {
            pac.nextVX = 1;
            pac.nextVY = 0;
        } else {
            pac.nextVX = -1;
            pac.nextVY = 0;
        }
    } else {
        if (deltaY > 0) {
            pac.nextVX = 0;
            pac.nextVY = 1;
        } else {
            pac.nextVX = 0;
            pac.nextVY = -1;
        }
    }
});

// Initialize game
loadBoard();

// Ensure board is properly loaded before starting game loop
if (!board || board.length === 0) {
    console.error('Board failed to load, attempting recovery...');
    loadBoard(); // Try again
    
    if (!board || board.length === 0) {
        console.error('Board still not loaded, creating emergency board');
        board = MAPS[0].map(row => row.split(''));
    }
}

// Verify board dimensions
if (board && board.length > 0) {
    console.log(`Board loaded: ${board.length} rows x ${board[0].length} columns`);
} else {
    console.error('CRITICAL: Board still not loaded!');
}

gameLoop();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { paused = true; },
    resume: () => { paused = false; },
    restart: () => {
        score = 0;
        level = 1;
        lives = 3;
        paused = false;
        gameEnded = false;
        frightenedTimer = 0;
        pac.x = 14;
        pac.y = 23;
        pac.vx = 0;
        pac.vy = 0;
        pac.nextVX = 0;
        pac.nextVY = 0;
        loadBoard();
        gameContainer.updateScore(score);
        gameContainer.updateLives(level);
    }
};

console.log('REAL Chompy (Dot Eater) game initialized with universal system');
</script>
</body>
</html>
