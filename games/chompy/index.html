<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Chompy - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with chompy config
const gameConfig = GAME_CONFIGS.chompy;
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const ctx = canvas.getContext('2d');

// Game constants
const CELL_SIZE = 20;
const MAZE_WIDTH = 28;
const MAZE_HEIGHT = 31;

// Game variables
let score = 0;
let lives = 3;
let gameRunning = true;
let gameOver = false;
let level = 1;

// Game objects
let player = { x: 14, y: 23, direction: 'right', nextDirection: 'right' };
let ghosts = [];
let dots = [];
let powerPellets = [];
let maze = [];

// Initialize maze layout (simplified Pac-Man style)
function initMaze() {
    // Create empty maze
    maze = [];
    for (let y = 0; y < MAZE_HEIGHT; y++) {
        maze[y] = [];
        for (let x = 0; x < MAZE_WIDTH; x++) {
            maze[y][x] = 0; // 0 = empty, 1 = wall
        }
    }
    
    // Add walls around edges
    for (let x = 0; x < MAZE_WIDTH; x++) {
        maze[0][x] = 1;
        maze[MAZE_HEIGHT - 1][x] = 1;
    }
    for (let y = 0; y < MAZE_HEIGHT; y++) {
        maze[y][0] = 1;
        maze[y][MAZE_WIDTH - 1] = 1;
    }
    
    // Add some internal walls
    for (let x = 5; x < 23; x++) {
        maze[5][x] = 1;
        maze[25][x] = 1;
    }
    for (let y = 5; y < 26; y++) {
        maze[y][5] = 1;
        maze[y][22] = 1;
    }
    
    // Add dots
    dots = [];
    for (let y = 1; y < MAZE_HEIGHT - 1; y++) {
        for (let x = 1; x < MAZE_WIDTH - 1; x++) {
            if (maze[y][x] === 0) {
                dots.push({ x, y });
            }
        }
    }
    
    // Add power pellets at corners
    powerPellets = [
        { x: 1, y: 1 },
        { x: MAZE_WIDTH - 2, y: 1 },
        { x: 1, y: MAZE_HEIGHT - 2 },
        { x: MAZE_WIDTH - 2, y: MAZE_HEIGHT - 2 }
    ];
}

// Initialize ghosts
function initGhosts() {
    ghosts = [
        { x: 14, y: 11, direction: 'left', color: '#ff0000', mode: 'chase' },
        { x: 13, y: 14, direction: 'up', color: '#ffb8ff', mode: 'chase' },
        { x: 14, y: 14, direction: 'down', color: '#00ffff', mode: 'chase' },
        { x: 15, y: 14, direction: 'right', color: '#ffb852', mode: 'chase' }
    ];
}

// Check if position is valid
function isValidPosition(x, y) {
    return x >= 0 && x < MAZE_WIDTH && y >= 0 && y < MAZE_HEIGHT && maze[y][x] === 0;
}

// Move player
function movePlayer() {
    const directions = {
        'up': { dx: 0, dy: -1 },
        'down': { dx: 0, dy: 1 },
        'left': { dx: -1, dy: 0 },
        'right': { dx: 1, dy: 0 }
    };
    
    // Try to change direction
    if (player.nextDirection !== player.direction) {
        const newDir = directions[player.nextDirection];
        if (isValidPosition(player.x + newDir.dx, player.y + newDir.dy)) {
            player.direction = player.nextDirection;
        }
    }
    
    // Move in current direction
    const dir = directions[player.direction];
    if (isValidPosition(player.x + dir.dx, player.y + dir.dy)) {
        player.x += dir.dx;
        player.y += dir.dy;
    }
    
    // Wrap around edges
    if (player.x < 0) player.x = MAZE_WIDTH - 1;
    if (player.x >= MAZE_WIDTH) player.x = 0;
}

// Move ghosts
function moveGhosts() {
    ghosts.forEach(ghost => {
        const directions = ['up', 'down', 'left', 'right'];
        const validDirections = [];
        
        directions.forEach(dir => {
            const dx = dir === 'left' ? -1 : dir === 'right' ? 1 : 0;
            const dy = dir === 'up' ? -1 : dir === 'down' ? 1 : 0;
            
            if (isValidPosition(ghost.x + dx, ghost.y + dy)) {
                validDirections.push(dir);
            }
        });
        
        if (validDirections.length > 0) {
            // Simple ghost AI - move randomly
            const randomDir = validDirections[Math.floor(Math.random() * validDirections.length)];
            ghost.direction = randomDir;
            
            const dx = randomDir === 'left' ? -1 : randomDir === 'right' ? 1 : 0;
            const dy = randomDir === 'up' ? -1 : randomDir === 'down' ? 1 : 0;
            
            ghost.x += dx;
            ghost.y += dy;
        }
        
        // Wrap around edges
        if (ghost.x < 0) ghost.x = MAZE_WIDTH - 1;
        if (ghost.x >= MAZE_WIDTH) ghost.x = 0;
    });
}

// Check collisions
function checkCollisions() {
    // Check dot collisions
    dots = dots.filter(dot => {
        if (dot.x === player.x && dot.y === player.y) {
            score += 10;
            gameContainer.updateScore(score);
            return false;
        }
        return true;
    });
    
    // Check power pellet collisions
    powerPellets = powerPellets.filter(pellet => {
        if (pellet.x === player.x && pellet.y === player.y) {
            score += 50;
            gameContainer.updateScore(score);
            // Make ghosts vulnerable
            ghosts.forEach(ghost => {
                ghost.mode = 'vulnerable';
                ghost.color = '#0000ff';
                setTimeout(() => {
                    ghost.mode = 'chase';
                    ghost.color = ghost.originalColor || '#ff0000';
                }, 5000);
            });
            return false;
        }
        return true;
    });
    
    // Check ghost collisions
    ghosts.forEach(ghost => {
        if (ghost.x === player.x && ghost.y === player.y) {
            if (ghost.mode === 'vulnerable') {
                // Eat ghost
                score += 200;
                gameContainer.updateScore(score);
                ghost.x = 14;
                ghost.y = 14;
                ghost.mode = 'chase';
                ghost.color = ghost.originalColor || '#ff0000';
            } else {
                // Lose life
                lives--;
                gameContainer.updateLives(lives);
                if (lives <= 0) {
                    gameOver = true;
                    gameRunning = false;
                } else {
                    // Reset player position
                    player.x = 14;
                    player.y = 23;
                    player.direction = 'right';
                    player.nextDirection = 'right';
                }
            }
        }
    });
    
    // Check win condition
    if (dots.length === 0 && powerPellets.length === 0) {
        level++;
        initMaze();
        initGhosts();
        player.x = 14;
        player.y = 23;
    }
}

// Draw functions
function drawMaze() {
    for (let y = 0; y < MAZE_HEIGHT; y++) {
        for (let x = 0; x < MAZE_WIDTH; x++) {
            if (maze[y][x] === 1) {
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
        }
    }
}

function drawDots() {
    ctx.fillStyle = '#ffff00';
    dots.forEach(dot => {
        ctx.beginPath();
        ctx.arc(
            dot.x * CELL_SIZE + CELL_SIZE / 2,
            dot.y * CELL_SIZE + CELL_SIZE / 2,
            2,
            0,
            Math.PI * 2
        );
        ctx.fill();
    });
}

function drawPowerPellets() {
    ctx.fillStyle = '#ffff00';
    powerPellets.forEach(pellet => {
        ctx.beginPath();
        ctx.arc(
            pellet.x * CELL_SIZE + CELL_SIZE / 2,
            pellet.y * CELL_SIZE + CELL_SIZE / 2,
            6,
            0,
            Math.PI * 2
        );
        ctx.fill();
    });
}

function drawPlayer() {
    ctx.fillStyle = '#ffff00';
    ctx.beginPath();
    ctx.arc(
        player.x * CELL_SIZE + CELL_SIZE / 2,
        player.y * CELL_SIZE + CELL_SIZE / 2,
        CELL_SIZE / 2,
        0,
        Math.PI * 2
    );
    ctx.fill();
    
    // Draw mouth
    ctx.fillStyle = '#000';
    const mouthAngle = Math.PI / 4;
    const startAngle = {
        'right': 0,
        'left': Math.PI,
        'up': -Math.PI / 2,
        'down': Math.PI / 2
    }[player.direction];
    
    ctx.beginPath();
    ctx.arc(
        player.x * CELL_SIZE + CELL_SIZE / 2,
        player.y * CELL_SIZE + CELL_SIZE / 2,
        CELL_SIZE / 3,
        startAngle - mouthAngle,
        startAngle + mouthAngle
    );
    ctx.lineTo(
        player.x * CELL_SIZE + CELL_SIZE / 2,
        player.y * CELL_SIZE + CELL_SIZE / 2
    );
    ctx.fill();
}

function drawGhosts() {
    ghosts.forEach(ghost => {
        ctx.fillStyle = ghost.color;
        ctx.beginPath();
        ctx.arc(
            ghost.x * CELL_SIZE + CELL_SIZE / 2,
            ghost.y * CELL_SIZE + CELL_SIZE / 2,
            CELL_SIZE / 2,
            Math.PI,
            0
        );
        ctx.lineTo(
            ghost.x * CELL_SIZE + CELL_SIZE / 2,
            ghost.y * CELL_SIZE + CELL_SIZE / 2 + CELL_SIZE / 2
        );
        ctx.fill();
        
        // Draw eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(
            ghost.x * CELL_SIZE + CELL_SIZE / 3,
            ghost.y * CELL_SIZE + CELL_SIZE / 3,
            3,
            0,
            Math.PI * 2
        );
        ctx.arc(
            ghost.x * CELL_SIZE + (CELL_SIZE * 2) / 3,
            ghost.y * CELL_SIZE + CELL_SIZE / 3,
            3,
            0,
            Math.PI * 2
        );
        ctx.fill();
        
        // Draw pupils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(
            ghost.x * CELL_SIZE + CELL_SIZE / 3,
            ghost.y * CELL_SIZE + CELL_SIZE / 3,
            1.5,
            0,
            Math.PI * 2
        );
        ctx.arc(
            ghost.x * CELL_SIZE + (CELL_SIZE * 2) / 3,
            ghost.y * CELL_SIZE + CELL_SIZE / 3,
            1.5,
            0,
            Math.PI * 2
        );
        ctx.fill();
    });
}

function drawUI() {
    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${score}`, 10, 20);
    ctx.fillText(`Lives: ${lives}`, 10, 40);
    ctx.fillText(`Level: ${level}`, 10, 60);
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#f00';
    ctx.font = '32px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
    
    ctx.fillStyle = '#fff';
    ctx.font = '20px monospace';
    ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2);
    ctx.fillText('Press R to restart', canvas.width / 2, canvas.height / 2 + 50);
}

// Game loop
function gameLoop() {
    if (!gameRunning) return;
    
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update game state
    movePlayer();
    moveGhosts();
    checkCollisions();
    
    // Draw game elements
    drawMaze();
    drawDots();
    drawPowerPellets();
    drawPlayer();
    drawGhosts();
    drawUI();
    
    if (gameOver) {
        drawGameOver();
        return;
    }
    
    requestAnimationFrame(gameLoop);
}

// Event listeners
gameContainer.on('keydown', (e) => {
    if (gameOver) {
        if (e.key === 'r' || e.key === 'R') {
            restartGame();
        }
        return;
    }
    
    switch(e.key) {
        case 'ArrowUp':
            player.nextDirection = 'up';
            break;
        case 'ArrowDown':
            player.nextDirection = 'down';
            break;
        case 'ArrowLeft':
            player.nextDirection = 'left';
            break;
        case 'ArrowRight':
            player.nextDirection = 'right';
            break;
        case ' ':
            gameRunning = !gameRunning;
            if (gameRunning) gameLoop();
            break;
    }
});

// Touch controls for mobile
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    touchStartX = touch.clientX - rect.left;
    touchStartY = touch.clientY - rect.top;
});

canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const touchX = touch.clientX - rect.left;
    const touchY = touch.clientY - rect.top;
    
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
        if (deltaX > 30) {
            player.nextDirection = 'right';
        } else if (deltaX < -30) {
            player.nextDirection = 'left';
        }
    } else {
        if (deltaY > 30) {
            player.nextDirection = 'down';
        } else if (deltaY < -30) {
            player.nextDirection = 'up';
        }
    }
});

function restartGame() {
    score = 0;
    lives = 3;
    level = 1;
    gameOver = false;
    gameRunning = true;
    gameContainer.updateScore(score);
    gameContainer.updateLives(lives);
    initMaze();
    initGhosts();
    player.x = 14;
    player.y = 23;
    player.direction = 'right';
    player.nextDirection = 'right';
    gameLoop();
}

// Initialize game
initMaze();
initGhosts();
gameLoop();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { gameRunning = false; },
    resume: () => { gameRunning = true; gameLoop(); },
    restart: restartGame
};

console.log('Chompy game initialized with universal system');
</script>
</body>
</html>
