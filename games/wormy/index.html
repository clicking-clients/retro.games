<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Wormy - Retro Games Collection</title>
<link rel="stylesheet" href="../../core/base.css">
<link rel="stylesheet" href="../../core/components.css">
<link rel="stylesheet" href="../../core/responsive.css">
</head>
<body>
<!-- Enhanced Navigation will be automatically inserted here -->
<script type="module">
import { EnhancedNavigation } from '../../core/navigation.js';
import { GameContainer } from '../../components/GameContainer.js';
import { GAME_CONFIGS } from '../../config/games.js';

// Initialize enhanced navigation
const navigation = new EnhancedNavigation();

// Initialize game container with wormy config
const gameConfig = GAME_CONFIGS.wormy;
const gameContainer = new GameContainer(gameConfig);

// Initialize the container
gameContainer.init();

// Get the canvas from the container
const canvas = gameContainer.getCanvas();
const context = canvas.getContext('2d');

// Game logic
const scale = 20;
const rows = canvas.height / scale;
const cols = canvas.width / scale;
let snake;
let fruit;
let score = 0;
let paused = false;
let gameOver = false;
let easyMode = false;

class Snake {
    constructor() {
        this.body = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
        this.dx = 0;
        this.dy = 0;
        this.nextDx = 0;
        this.nextDy = 0;
    }
    
    update() {
        this.dx = this.nextDx;
        this.dy = this.nextDy;
        const head = {x: this.body[0].x + this.dx, y: this.body[0].y + this.dy};
        this.body.unshift(head);
        
        if(head.x === fruit.x && head.y === fruit.y) {
            score += 10;
            gameContainer.updateScore(score);
            spawnFruit();
        } else {
            this.body.pop();
        }
        
        if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows || 
           (!easyMode && this.body.slice(1).some(seg => seg.x === head.x && seg.y === head.y))) {
            gameOver = true;
        }
    }
    
    draw() {
        context.fillStyle = '#0f0';
        this.body.forEach(seg => {
            context.fillRect(seg.x, seg.y, 1, 1);
            context.strokeStyle = '#000';
            context.lineWidth = 0.05;
            context.strokeRect(seg.x, seg.y, 1, 1);
        });
    }
    
    setDirection(x, y) {
        if(!easyMode) {
            if(this.dx + x === 0 && this.dy + y === 0) return;
        }
        this.nextDx = x;
        this.nextDy = y;
    }
}

function spawnFruit() {
    fruit = {x: Math.floor(Math.random() * cols), y: Math.floor(Math.random() * rows)};
}

function drawFruit() {
    context.fillStyle = '#F00';
    context.fillRect(fruit.x, fruit.y, 1, 1);
    context.strokeStyle = '#000';
    context.lineWidth = 0.05;
    context.strokeRect(fruit.x, fruit.y, 1, 1);
}

function draw() {
    context.fillStyle = '#000';
    context.fillRect(0, 0, canvas.width, canvas.height);
    context.save();
    context.scale(scale, scale);
    snake.draw();
    drawFruit();
    
    if(gameOver) {
        context.fillStyle = '#F00';
        context.font = '1.5px monospace';
        context.textAlign = 'center';
        context.fillText('GAME OVER', cols/2, rows/2);
    }
    context.restore();
}

function update() {
    if(paused) return;
    if(!gameOver) snake.update();
    draw();
    
    if(!gameOver) {
        setTimeout(update, 150);
    } else {
        let flash = true;
        window.flashInterval = setInterval(() => {
            draw();
            context.save();
            context.scale(scale, scale);
            if(flash) {
                context.fillStyle = '#F00';
                context.font = '1.5px monospace';
                context.textAlign = 'center';
                context.fillText('GAME OVER', cols/2, rows/2);
            }
            context.restore();
            flash = !flash;
        }, 500);
    }
}

// Setup event listeners
gameContainer.on('keydown', (e) => {
    switch(e.key) {
        case 'ArrowLeft': snake.setDirection(-1,0); break;
        case 'ArrowRight': snake.setDirection(1,0); break;
        case 'ArrowUp': snake.setDirection(0,-1); break;
        case 'ArrowDown': snake.setDirection(0,1); break;
        case 'p':
        case 'P': 
            paused = !paused; 
            if(!paused) update(); 
            break;
        case 'r':
        case 'R': 
            score = 0; 
            gameContainer.updateScore(score);
            snake = new Snake(); 
            spawnFruit(); 
            gameOver = false; 
            paused = false; 
            if (window.flashInterval) {
                clearInterval(window.flashInterval);
                window.flashInterval = null;
            }
            update(); 
            break;
    }
});

// Initialize game
snake = new Snake();
spawnFruit();
update();

// Update game container with game instance
gameContainer.gameInstance = {
    pause: () => { paused = true; },
    resume: () => { paused = false; update(); },
    restart: () => {
        score = 0;
        gameContainer.updateScore(score);
        snake = new Snake();
        spawnFruit();
        gameOver = false;
        paused = false;
        if (window.flashInterval) {
            clearInterval(window.flashInterval);
            window.flashInterval = null;
        }
        update();
    }
};

console.log('Wormy game initialized with universal system');
</script>
</body>
</html>
