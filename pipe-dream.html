<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Dream - Retro Games Collection</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .game-container {
            background: #1a1a2e;
            border: 3px solid #0f0;
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            text-align: center;
        }

        .game-header {
            margin-bottom: 20px;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
            border: 2px solid #0f0;
        }

        .math-problem {
            font-size: 2rem;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin: 20px 0;
        }

        .pipe-inventory {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 255, 0, 0.05);
            border-radius: 10px;
            border: 1px solid #0f0;
        }

        .pipe-piece {
            width: 80px;
            height: 40px;
            background: linear-gradient(135deg, #8b8b8b, #a0a0a0);
            border: 4px solid #666;
            border-radius: 20px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #333;
            font-weight: bold;
            text-shadow: 1px 1px 2px #fff;
            transition: all 0.3s ease;
            user-select: none;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            touch-action: manipulation;
            position: relative;
            transform-style: preserve-3d;
        }

        .pipe-piece::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.4) 20%, 
                rgba(255, 255, 255, 0.6) 50%, 
                rgba(255, 255, 255, 0.4) 80%, 
                transparent 100%);
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .pipe-piece:hover::before {
            opacity: 1;
        }

        .pipe-piece::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 60%;
            background: linear-gradient(135deg, #6b6b6b, #8b8b8b);
            border-radius: 15px;
            top: 20%;
            left: 5%;
            z-index: -1;
        }

        .pipe-piece::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(0, 255, 0, 0.3) 50%, transparent 100%);
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .pipe-piece:hover::before {
            opacity: 1;
        }

        .pipe-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #0f0;
        }

        .pipe-piece.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
        }

        .play-area {
            width: 100%;
            height: 400px;
            background: #16213e;
            border: 3px solid #0f0;
            border-radius: 15px;
            position: relative;
            margin: 20px 0;
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 80px 80px;
        }

        .placed-pipe {
            position: absolute;
            width: 80px;
            height: 40px;
            background: linear-gradient(135deg, #8b8b8b, #a0a0a0);
            border: 4px solid #666;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #333;
            font-weight: bold;
            text-shadow: 1px 1px 2px #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
            transform-style: preserve-3d;
        }

        .placed-pipe::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 60%;
            background: linear-gradient(135deg, #6b6b6b, #8b8b8b);
            border-radius: 15px;
            top: 20%;
            left: 5%;
            z-index: -1;
        }

        .placed-pipe.connected {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border-color: #2E7D32;
            box-shadow: 
                0 0 20px #4CAF50,
                0 0 40px rgba(76, 175, 80, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
            animation: pipeConnect 0.6s ease-out;
        }

        @keyframes pipeConnect {
            0% { 
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 0px #4CAF50;
            }
            25% { 
                transform: scale(1.1) rotate(2deg);
                box-shadow: 0 0 30px #4CAF50;
            }
            50% { 
                transform: scale(1.05) rotate(-1deg);
                box-shadow: 0 0 25px #4CAF50;
            }
            100% { 
                transform: scale(1.05) rotate(0deg);
                box-shadow: 0 0 20px #4CAF50;
            }
        }

        .placed-pipe.connecting {
            background: linear-gradient(135deg, #FFD700, #FFED4E);
            border-color: #FF8C00;
            box-shadow: 
                0 0 15px #FFD700,
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            animation: connectingPulse 1.5s ease-in-out infinite;
        }

        @keyframes connectingPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 15px #FFD700, 0 0 30px rgba(255, 215, 0, 0.3);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 20px #FFD700, 0 0 40px rgba(255, 215, 0, 0.5);
            }
        }

        .grid-highlight {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px dashed #0f0;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 1;
            animation: gridPulse 2s infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .placed-pipe.filled {
            background: linear-gradient(45deg, #0066cc, #0099ff);
            border-color: #0099ff;
            box-shadow: 0 0 20px #0099ff;
        }

        .start-pipe {
            position: absolute;
            width: 80px;
            height: 40px;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border: 4px solid #2E7D32;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(76, 175, 80, 0.5);
            animation: startPipeGlow 2s ease-in-out infinite;
        }

        .start-pipe::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 60%;
            background: linear-gradient(135deg, #388E3C, #4CAF50);
            border-radius: 15px;
            top: 20%;
            left: 5%;
            z-index: -1;
        }

        @keyframes startPipeGlow {
            0%, 100% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 20px rgba(76, 175, 80, 0.5);
            }
            50% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 30px rgba(76, 175, 80, 0.8);
            }
        }

        .answer-pipe {
            position: absolute;
            width: 80px;
            height: 40px;
            border: 4px solid #666;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }

        .answer-pipe::after {
            content: '';
            position: absolute;
            width: 90%;
            height: 60%;
            background: linear-gradient(135deg, #6b6b6b, #8b8b8b);
            border-radius: 15px;
            top: 20%;
            left: 5%;
            z-index: -1;
        }

        .answer-pipe.correct {
            background: linear-gradient(135deg, #F44336, #EF5350);
            border-color: #D32F2F;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(244, 67, 54, 0.5);
        }

        .answer-pipe.decoy {
            background: linear-gradient(135deg, #2196F3, #42A5F5);
            border-color: #1976D2;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(33, 150, 243, 0.5);
        }

        .grid-cell {
            background: rgba(0, 255, 0, 0.05);
        }

        .connection-spark {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #FFD700, #FFA500, transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: sparkEffect 0.6s ease-out forwards;
        }

        @keyframes sparkEffect {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
                box-shadow: 0 0 0px #FFD700;
            }
            25% { 
                transform: scale(2) rotate(90deg);
                opacity: 1;
                box-shadow: 0 0 20px #FFD700;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
                box-shadow: 0 0 15px #FFD700;
            }
            100% { 
                transform: scale(0) rotate(360deg);
                opacity: 0;
                box-shadow: 0 0 0px #FFD700;
            }
        }

        .water-flow {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #4FC3F7, #29B6F6, #0288D1);
            border-radius: 50%;
            pointer-events: none;
            animation: waterFlow 2s linear infinite;
            box-shadow: 0 0 8px #4FC3F7;
        }

        @keyframes waterFlow {
            0% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
            25% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            50% { 
                transform: scale(1); 
                opacity: 1; 
                box-shadow: 0 0 8px #4FC3F7;
            }
            75% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            100% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
        }

        .splash {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #0099ff, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: splash 1s ease-out forwards;
        }

        @keyframes splash {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .game-controls {
            margin: 20px 0;
        }

        .control-btn {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 12px 25px;
            margin: 0 10px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .control-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .score-display {
            font-size: 1.2rem;
            color: #ffd700;
            margin: 15px 0;
        }

        .pressure-gauge {
            font-size: 1.2rem;
            color: #ff6b6b;
            font-weight: bold;
        }

        .pressure-bar {
            width: 100px;
            height: 20px;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .pressure-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffd700;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            text-align: center;
            z-index: 1000;
        }

        .success-message {
            color: #0f0;
            font-size: 1.5rem;
            margin: 20px 0;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .game-container {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings > div {
                grid-template-columns: 1fr !important;
            }
            
            .play-area {
                height: 300px;
            }
            
            .pipe-inventory {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }
            
            .pipe-piece {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .math-problem {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-nav">
        <strong>🎮 Pipe Dream</strong>
        <a href="index.html">← Back to Games</a>
        <a href="chompy.html">Chompy</a>
        <a href="block-stack.html">Block Stack</a>
        <a href="wormy.html">Wormy</a>
        <a href="bubble-pop.html">Bubble Pop</a>
        <a href="road-dash.html">Road Dash</a>
        <a href="paddle-ball.html">Paddle Ball</a>
        <a href="number-defenders.html">Number Defenders</a>
        <a href="word-defenders.html">Word Defenders</a>
    </div>

    <div class="game-settings" style="background: rgba(0, 255, 0, 0.1); padding: 20px; border-radius: 15px; margin: 20px auto; max-width: 800px; border: 2px solid #0f0;">
        <h3 style="color: #ffd700; margin-bottom: 15px;">⚙️ Game Settings</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div>
                <h4 style="color: #0f0; margin-bottom: 10px;">🎮 Game Mode</h4>
                <select id="gameMode" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px;">
                    <option value="practice">Practice (Free Build)</option>
                    <option value="adventure">Adventure (Levels)</option>
                    <option value="timed">Timed Rush</option>
                </select>
            </div>
            
            <div>
                <h4 style="color: #0f0; margin-bottom: 10px;">📊 Difficulty</h4>
                <select id="difficulty" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px;">
                    <option value="easy">Easy (5×5 grid, simple)</option>
                    <option value="medium">Medium (7×7 grid, grouped)</option>
                    <option value="hard">Hard (9×9 grid, precedence)</option>
                </select>
            </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
            <div>
                <h4 style="color: #0f0; margin-bottom: 10px;">🔢 Operations</h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="opAdd" checked style="accent-color: #0f0;"> +
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="opSub" style="accent-color: #0f0;"> −
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="opMul" style="accent-color: #0f0;"> ×
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="opDiv" style="accent-color: #0f0;"> ÷
                    </label>
                </div>
            </div>
            
            <div>
                <h4 style="color: #0f0; margin-bottom: 10px;">🎯 Options</h4>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="allowNegatives" style="accent-color: #0f0;"> Allow Negatives
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                        <input type="checkbox" id="showPrecedenceHints" checked style="accent-color: #0f0;"> Show Hints
                    </label>
                </div>
            </div>
        </div>
        
        <button id="applySettings" style="background: #0f0; color: #000; border: none; padding: 12px 25px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1.1rem;">
            Apply Settings & New Game
        </button>
    </div>

    <div class="game-container">
        <div class="game-header">
            <h1>🚰 Pipe Dream</h1>
            <p>Connect pipes to solve math problems and watch the water flow!</p>
            
            <div style="background: rgba(0, 255, 0, 0.1); padding: 20px; border-radius: 15px; margin: 20px 0; border: 2px solid #0f0;">
                <h3 style="color: #ffd700; margin-bottom: 15px;">🎯 Game Objective</h3>
                <p style="margin-bottom: 15px; line-height: 1.6;">
                    <strong>Your goal:</strong> Build a pipe network that routes water from the start pipe (green) to the correct answer pipe (red) while solving math expressions step by step.
                </p>
                
                <h4 style="color: #0f0; margin: 15px 0 10px 0;">📋 How to Play:</h4>
                <ol style="text-align: left; margin-left: 20px; line-height: 1.8;">
                    <li><strong>Start pipe (green)</strong> emits the first number in the expression</li>
                    <li><strong>Drag pipes from inventory</strong> to build your network on the grid</li>
                    <li><strong>Use operator pipes</strong> (+, −, ×, ÷) to perform calculations</li>
                    <li><strong>Connect with pipes</strong> (┌, ┐, └, ┘, ─, │) to route water flow</li>
                    <li><strong>Route to correct answer</strong> (red pipe) while avoiding decoys (blue)</li>
                    <li><strong>Press "Flow Test"</strong> to see water flow through your network</li>
                    <li><strong>Watch pressure gauge</strong> - leaks and wrong answers increase pressure!</li>
                </ol>
                
                <h4 style="color: #0f0; margin: 15px 0 10px 0;">🔧 Pipe Types:</h4>
                <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
                    <li><strong>Number pipes (1-9):</strong> Supply values for calculations</li>
                    <li><strong>Operator pipes (+, −, ×, ÷):</strong> Perform math operations on water flow</li>
                    <li><strong>Connector pipes:</strong> Route water without changing values</li>
                    <li><strong>Special pipes:</strong> Splitters (Y), valves (▶), crossovers (⊕) for advanced puzzles</li>
                </ul>
                
                <h4 style="color: #0f0; margin: 15px 0 10px 0;">🎮 Game Mechanics:</h4>
                <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
                    <li><strong>Grid-based placement:</strong> Pipes snap to 80x80 grid positions</li>
                    <li><strong>Pressure system:</strong> Time pressure increases, correct connections reduce it</li>
                    <li><strong>Multiple answers:</strong> One correct (red), others are decoys (blue)</li>
                    <li><strong>Flow testing:</strong> See water flow step-by-step with calculations</li>
                    <li><strong>Precedence matters:</strong> × ÷ happen before + − in complex expressions</li>
                </ul>
                
                <div style="background: rgba(255, 215, 0, 0.1); padding: 15px; border-radius: 10px; margin: 15px 0; border: 1px solid #ffd700;">
                    <strong>💡 Example:</strong> For "5 + 3 × 2 = ?", start with 5, route through + and 3, then × and 2. The correct answer is 11 (5 + (3 × 2)), not 16 ((5 + 3) × 2)!
                </div>
            </div>
        </div>

        <div class="level-info">
            <div class="score-display">
                <strong>Level:</strong> <span id="level">1</span>
                <strong>Score:</strong> <span id="score">0</span>
                <strong>Stars:</strong> <span id="stars">0</span>
            </div>
            <div class="pressure-gauge">
                <strong>Pressure:</strong> <span id="pressure">0</span>%
                <div class="pressure-bar">
                    <div class="pressure-fill" id="pressureFill"></div>
                </div>
            </div>
        </div>

        <div class="math-problem" id="mathProblem" role="heading" aria-level="2">
            5 + 3 = ?
        </div>

        <div class="pipe-inventory" id="pipeInventory">
            <!-- Pipe pieces will be generated here -->
        </div>

        <div class="play-area" id="playArea">
            <!-- Placed pipes will appear here -->
        </div>

        <div class="game-controls">
            <button class="control-btn" id="newLevelBtn" aria-label="Start new level">New Level</button>
            <button class="control-btn" id="resetBtn" aria-label="Reset current level">Reset</button>
            <button class="control-btn" id="undoBtn" aria-label="Undo last pipe placement">Undo</button>
            <button class="control-btn" id="flowTestBtn" aria-label="Test water flow">Flow Test</button>
            <button class="control-btn" id="hintBtn" aria-label="Get a hint for current problem">Hint</button>
        </div>
    </div>

    <script>
        class PipeDream {
            constructor() {
                this.gameMode = 'practice'; // 'adventure', 'practice', 'timed'
                this.difficulty = 'easy'; // 'easy', 'medium', 'hard', 'custom'
                this.operations = ['+']; // Available operations - default to addition only
                this.allowNegatives = false;
                this.showPrecedenceHints = true;
                
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 0;
                this.maxPressure = 100;
                this.gameActive = true;
                
                this.pipes = [];
                this.connectedPipes = [];
                this.draggedPipe = null;
                this.timer = null;
                this.pipeHistory = [];
                
                this.gridSize = 7; // 7x7 for medium
                this.startPipe = null;
                this.answerPipes = [];
                this.obstacles = [];
                this.inventory = [];
                
                this.currentExpression = null;
                this.correctAnswer = null;
                this.decoyAnswers = [];
                
                this.init();
            }
            
            // Game configuration based on difficulty
            getGameConfig() {
                const configs = {
                    easy: {
                        gridSize: 5,
                        maxPathLength: 8,
                        answerPipeCount: 3,
                        allowCrossings: false,
                        pressureRate: 0.5
                    },
                    medium: {
                        gridSize: 7,
                        maxPathLength: 12,
                        answerPipeCount: 4,
                        allowCrossings: false,
                        pressureRate: 1.0
                    },
                    hard: {
                        gridSize: 9,
                        maxPathLength: 16,
                        answerPipeCount: 5,
                        allowCrossings: true,
                        pressureRate: 2.0
                    }
                };
                return configs[this.difficulty] || configs.medium;
            }
            
            // Enhanced pipe types with operators and special pieces
            getPipeTypes() {
                const basePipes = [
                    // Numbers
                    { symbol: '1', value: 1, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '2', value: 2, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '3', value: 3, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '4', value: 4, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '5', value: 5, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '6', value: 6, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '7', value: 7, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '8', value: 8, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '9', value: 9, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Operators
                    { symbol: '+', value: 0, type: 'operator', operation: '+', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '−', value: 0, type: 'operator', operation: '-', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '×', value: 0, type: 'operator', operation: '×', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '÷', value: 0, type: 'operator', operation: '÷', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Connectors
                    { symbol: '┌', value: 0, type: 'connector', connections: ['top', 'right'] },
                    { symbol: '┐', value: 0, type: 'connector', connections: ['top', 'left'] },
                    { symbol: '└', value: 0, type: 'connector', connections: ['bottom', 'right'] },
                    { symbol: '┘', value: 0, type: 'connector', connections: ['bottom', 'left'] },
                    { symbol: '─', value: 0, type: 'connector', connections: ['left', 'right'] },
                    { symbol: '│', value: 0, type: 'connector', connections: ['top', 'bottom'] }
                ];
                
                // Add special pieces for medium+ difficulty
                if (this.difficulty !== 'easy') {
                    basePipes.push(
                        { symbol: 'Y', value: 0, type: 'splitter', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: '▶', value: 0, type: 'valve', connections: ['left', 'right'] }
                    );
                }
                
                // Add advanced pieces for hard difficulty
                if (this.difficulty === 'hard') {
                    basePipes.push(
                        { symbol: '⊕', value: 0, type: 'crossover', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: '⚡', value: 0, type: 'pressureValve', connections: ['top', 'bottom', 'left', 'right'] }
                    );
                }
                
                return basePipes;
            }
            
            init() {
                this.pipeHistory = [];
                this.gridSize = this.getGameConfig().gridSize;
                this.createNewPuzzle();
                this.setupEventListeners();
                this.startPressureTimer();
                this.updateDisplay();
                this.updateUndoButton();
                this.setupSettingsUI();
            }
            
            setupSettingsUI() {
                // Set initial UI values
                document.getElementById('gameMode').value = this.gameMode;
                document.getElementById('difficulty').value = this.difficulty;
                document.getElementById('opAdd').checked = this.operations.includes('+');
                document.getElementById('opSub').checked = this.operations.includes('-');
                document.getElementById('opMul').checked = this.operations.includes('×');
                document.getElementById('opDiv').checked = this.operations.includes('÷');
                document.getElementById('allowNegatives').checked = this.allowNegatives;
                document.getElementById('showPrecedenceHints').checked = this.showPrecedenceHints;
                
                // Add event listener for apply settings button
                document.getElementById('applySettings').addEventListener('click', () => this.applySettings());
            }
            
            applySettings() {
                // Update game settings from UI
                this.gameMode = document.getElementById('gameMode').value;
                this.difficulty = document.getElementById('difficulty').value;
                
                // Update operations
                this.operations = [];
                if (document.getElementById('opAdd').checked) this.operations.push('+');
                if (document.getElementById('opSub').checked) this.operations.push('-');
                if (document.getElementById('opMul').checked) this.operations.push('×');
                if (document.getElementById('opDiv').checked) this.operations.push('÷');
                
                // Ensure at least one operation is selected
                if (this.operations.length === 0) {
                    this.operations = ['+'];
                    document.getElementById('opAdd').checked = true;
                    alert('At least one operation must be selected. Defaulting to addition.');
                }
                
                // Update other settings
                this.allowNegatives = document.getElementById('allowNegatives').checked;
                this.showPrecedenceHints = document.getElementById('showPrecedenceHints').checked;
                
                // Reset game with new settings
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
                
                alert('Settings applied! New game started.');
            }
            
            createNewPuzzle() {
                this.currentExpression = this.generateExpression();
                this.correctAnswer = this.evaluateExpression(this.currentExpression);
                this.decoyAnswers = this.generateDecoyAnswers();
                this.createGrid();
                this.placeStartAndAnswerPipes();
                this.generateInventory();
                this.updateDisplay();
            }
            
            generateExpression() {
                const config = this.getGameConfig();
                let expression;
                
                if (this.difficulty === 'easy') {
                    // Simple: a ⊕ b
                    const op = this.operations[Math.floor(Math.random() * this.operations.length)];
                    const a = this.getRandomNumber(op, 0, 10);
                    const b = this.getRandomNumber(op, 0, 10);
                    expression = { a, b, op, type: 'simple' };
                } else if (this.difficulty === 'medium') {
                    // Medium: (a ⊕ b) ⊗ c or a ⊕ (b ⊗ c)
                    // Only use operations that are available
                    const availableOps = this.operations.filter(op => op !== '÷'); // Avoid division in medium for now
                    if (availableOps.length < 2) {
                        // Fall back to simple if not enough operations
                        const op = this.operations[0];
                        const a = this.getRandomNumber(op, 0, 15);
                        const b = this.getRandomNumber(op, 0, 15);
                        expression = { a, b, op, type: 'simple' };
                    } else {
                        const op1 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const op2 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const a = this.getRandomNumber(op1, 0, 20);
                        const b = this.getRandomNumber(op1, 0, 20);
                        const c = this.getRandomNumber(op2, 0, 10);
                        
                        if (Math.random() > 0.5) {
                            expression = { a, b, c, op1, op2, type: 'leftGrouped' };
                        } else {
                            expression = { a, b, c, op1, op2, type: 'rightGrouped' };
                        }
                    }
                } else {
                    // Hard: a ⊕ b ⊗ c ⊖ d with precedence
                    // Only use available operations
                    const addOps = this.operations.filter(op => op === '+' || op === '-');
                    const mulOps = this.operations.filter(op => op === '×' || op === '÷');
                    
                    if (addOps.length === 0) addOps.push('+');
                    if (mulOps.length === 0) mulOps.push('×');
                    
                    const a = this.getRandomNumber(addOps[0], 0, 50);
                    const b = this.getRandomNumber(mulOps[0], 0, 12);
                    const c = this.getRandomNumber(mulOps[0], 0, 12);
                    const d = this.getRandomNumber(addOps[0], 0, 50);
                    expression = { a, b, c, d, type: 'precedence' };
                }
                
                return expression;
            }
            
            getRandomNumber(operation, min, max) {
                let num;
                do {
                    num = Math.floor(Math.random() * (max - min + 1)) + min;
                } while (!this.allowNegatives && operation === '-' && num === 0);
                return num;
            }
            
            evaluateExpression(expr) {
                if (expr.type === 'simple') {
                    return this.applyOperation(expr.a, expr.b, expr.op);
                } else if (expr.type === 'leftGrouped') {
                    const first = this.applyOperation(expr.a, expr.b, expr.op1);
                    return this.applyOperation(first, expr.c, expr.op2);
                } else if (expr.type === 'rightGrouped') {
                    const second = this.applyOperation(expr.b, expr.c, expr.op2);
                    return this.applyOperation(expr.a, second, expr.op1);
                } else if (expr.type === 'precedence') {
                    // Follow order of operations: × ÷ before + −
                    const product = this.applyOperation(expr.b, expr.c, '×');
                    const sum = this.applyOperation(expr.a, product, '+');
                    return this.applyOperation(sum, expr.d, '-');
                }
                return 0;
            }
            
            applyOperation(a, b, op) {
                switch (op) {
                    case '+': return a + b;
                    case '-': return a - b;
                    case '×': return a * b;
                    case '÷': return Math.floor(a / b);
                    default: return a;
                }
            }
            
            generateDecoyAnswers() {
                const config = this.getGameConfig();
                const decoys = [];
                const correct = this.correctAnswer;
                
                // Generate plausible wrong answers
                const decoyTypes = [
                    correct + 1, // off-by-one
                    correct - 1,
                    correct * 2, // operation confusion
                    correct / 2,
                    Math.abs(correct), // sign error
                    -correct
                ];
                
                // Filter valid decoys
                decoyTypes.forEach(decoy => {
                    if (decoy !== correct && 
                        decoy >= (this.allowNegatives ? -100 : 0) && 
                        decoy <= 100 &&
                        !decoys.includes(decoy)) {
                        decoys.push(decoy);
                    }
                });
                
                // Fill remaining slots with random plausible values
                while (decoys.length < config.answerPipeCount - 1) {
                    const randomDecoy = Math.floor(Math.random() * 50) - (this.allowNegatives ? 25 : 0);
                    if (randomDecoy !== correct && !decoys.includes(randomDecoy)) {
                        decoys.push(randomDecoy);
                    }
                }
                
                return decoys.slice(0, config.answerPipeCount - 1);
            }
            
            createGrid() {
                const playArea = document.getElementById('playArea');
                playArea.innerHTML = '';
                
                // Set grid size
                const config = this.getGameConfig();
                this.gridSize = config.gridSize;
                
                // Update grid background
                playArea.style.backgroundSize = `${80}px ${80}px`;
                
                // Create grid cells for visual reference
                for (let x = 0; x < this.gridSize; x++) {
                    for (let y = 0; y < this.gridSize; y++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.style.position = 'absolute';
                        cell.style.left = (x * 80) + 'px';
                        cell.style.top = (y * 80) + 'px';
                        cell.style.width = '80px';
                        cell.style.height = '80px';
                        cell.style.border = '1px solid rgba(0, 255, 0, 0.2)';
                        cell.style.pointerEvents = 'none';
                        cell.style.zIndex = '1';
                        playArea.appendChild(cell);
                    }
                }
            }
            
            placeStartAndAnswerPipes() {
                const playArea = document.getElementById('playArea');
                const config = this.getGameConfig();
                
                // Place start pipe on left side
                const startY = Math.floor(this.gridSize / 2);
                this.startPipe = {
                    x: 0,
                    y: startY,
                    value: this.currentExpression.a,
                    type: 'start'
                };
                
                // Create start pipe element
                const startElement = document.createElement('div');
                startElement.className = 'start-pipe';
                startElement.textContent = this.currentExpression.a;
                startElement.style.left = '0px';
                startElement.style.top = (startY * 80) + 'px';
                playArea.appendChild(startElement);
                
                // Place answer pipes along right and bottom edges
                const allAnswers = [this.correctAnswer, ...this.decoyAnswers];
                const shuffledAnswers = allAnswers.sort(() => Math.random() - 0.5);
                
                shuffledAnswers.forEach((answer, index) => {
                    let x, y;
                    
                    if (index < this.gridSize - 1) {
                        // Place along right edge
                        x = this.gridSize - 1;
                        y = index;
                    } else {
                        // Place along bottom edge
                        x = index - (this.gridSize - 1);
                        y = this.gridSize - 1;
                    }
                    
                    const answerPipe = {
                        x: x,
                        y: y,
                        value: answer,
                        type: 'answer',
                        isCorrect: answer === this.correctAnswer
                    };
                    
                    this.answerPipes.push(answerPipe);
                    
                    // Create answer pipe element
                    const answerElement = document.createElement('div');
                    answerElement.className = `answer-pipe ${answer === this.correctAnswer ? 'correct' : 'decoy'}`;
                    answerElement.textContent = answer;
                    answerElement.style.left = (x * 80) + 'px';
                    answerElement.style.top = (y * 80) + 'px';
                    playArea.appendChild(answerElement);
                });
            }
            
            generateInventory() {
                const inventory = document.getElementById('pipeInventory');
                inventory.innerHTML = '';
                
                const config = this.getGameConfig();
                const pipeTypes = this.getPipeTypes();
                const pipes = [];
                
                // Add numbers from the expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'precedence') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.d));
                }
                
                // Add operators - only use the ones in the current expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'precedence') {
                    // For precedence, we need specific operations
                    if (this.operations.includes('+')) pipes.push(pipeTypes.find(p => p.operation === '+'));
                    if (this.operations.includes('×')) pipes.push(pipeTypes.find(p => p.operation === '×'));
                    if (this.operations.includes('-')) pipes.push(pipeTypes.find(p => p.operation === '-'));
                }
                
                // Add connector pipes - ensure we have enough for the grid
                const connectors = pipeTypes.filter(p => p.type === 'connector');
                const connectorCount = Math.min(12, connectors.length); // More connectors for better gameplay
                for (let i = 0; i < connectorCount; i++) {
                    pipes.push(connectors[i]);
                }
                
                // Filter out undefined pipes and shuffle
                const validPipes = pipes.filter(pipe => pipe !== undefined);
                const shuffledPipes = validPipes.sort(() => Math.random() - 0.5);
                
                shuffledPipes.forEach(pipe => {
                    const pipeElement = document.createElement('div');
                    pipeElement.className = 'pipe-piece';
                    pipeElement.textContent = pipe.symbol;
                    pipeElement.draggable = true;
                    pipeElement.dataset.pipeType = JSON.stringify(pipe);
                    
                    pipeElement.addEventListener('dragstart', (e) => this.handleDragStart(e, pipe));
                    pipeElement.addEventListener('dragend', () => this.handleDragEnd());
                    
                    inventory.appendChild(pipeElement);
                });
            }
            
            setupEventListeners() {
                const playArea = document.getElementById('playArea');
                
                // Desktop drag and drop
                playArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                
                playArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                // Mobile touch support
                let touchStartX, touchStartY;
                let currentPipe = null;
                
                playArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    // Check if touching a pipe piece in inventory
                    const element = document.elementFromPoint(touchStartX, touchStartY);
                    if (element && element.classList.contains('pipe-piece')) {
                        currentPipe = JSON.parse(element.dataset.pipeType);
                        element.style.opacity = '0.7';
                    }
                });
                
                playArea.addEventListener('touchend', (e) => {
                    if (currentPipe) {
                        const touch = e.changedTouches[0];
                        const rect = playArea.getBoundingClientRect();
                        const rawX = touch.clientX - rect.left;
                        const rawY = touch.clientY - rect.top;
                        
                        // Snap to grid
                        const gridSize = 80;
                        const x = Math.floor(rawX / gridSize) * gridSize;
                        const y = Math.floor(rawY / gridSize) * gridSize;
                        
                        // Ensure pipe stays within bounds
                        const maxX = rect.width - gridSize;
                        const maxY = rect.height - gridSize;
                        const clampedX = Math.max(0, Math.min(x, maxX));
                        const clampedY = Math.max(0, Math.min(y, maxY));
                        
                        if (clampedX >= 0 && clampedY >= 0 && clampedX <= maxX && clampedY <= maxY) {
                            this.placePipe(currentPipe, clampedX, clampedY);
                        }
                        
                        // Reset inventory pipe opacity
                        document.querySelectorAll('.pipe-piece').forEach(p => p.style.opacity = '1');
                        currentPipe = null;
                    }
                });
                
                document.getElementById('newLevelBtn').addEventListener('click', () => this.nextLevel());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetLevel());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoLastPipe());
                document.getElementById('flowTestBtn').addEventListener('click', () => this.testFlow());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
            }
            
            handleDragStart(e, pipe) {
                this.draggedPipe = pipe;
                e.target.classList.add('dragging');
                e.dataTransfer.setData('text/plain', JSON.stringify(pipe));
                
                // Show grid highlights
                this.showGridHighlights();
            }
            
            handleDragEnd() {
                document.querySelectorAll('.pipe-piece').forEach(p => p.classList.remove('dragging'));
                this.draggedPipe = null;
                
                // Clear grid highlights
                this.clearGridHighlights();
            }
            
            handleDrop(e) {
                e.preventDefault();
                if (!this.draggedPipe) return;
                
                const rect = e.currentTarget.getBoundingClientRect();
                const rawX = e.clientX - rect.left;
                const rawY = e.clientY - rect.top;
                
                // Snap to grid
                const gridSize = 80;
                const x = Math.floor(rawX / gridSize) * gridSize;
                const y = Math.floor(rawY / gridSize) * gridSize;
                
                // Ensure pipe stays within bounds
                const maxX = rect.width - gridSize;
                const maxY = rect.height - gridSize;
                const clampedX = Math.max(0, Math.min(x, maxX));
                const clampedY = Math.max(0, Math.min(y, maxY));
                
                this.placePipe(this.draggedPipe, clampedX, clampedY);
            }
            
            placePipe(pipeData, x, y) {
                const playArea = document.getElementById('playArea');
                const pipeElement = document.createElement('div');
                
                pipeElement.className = 'placed-pipe';
                pipeElement.textContent = pipeData.symbol;
                pipeElement.style.left = x + 'px';
                pipeElement.style.top = y + 'px';
                pipeElement.dataset.pipeData = JSON.stringify(pipeData);
                pipeElement.dataset.x = x;
                pipeElement.dataset.y = y;
                
                // Remove click event - pipes will connect automatically when placed correctly
                
                playArea.appendChild(pipeElement);
                
                const pipeInfo = {
                    element: pipeElement,
                    data: pipeData,
                    x: x,
                    y: y,
                    connected: false,
                    timestamp: Date.now()
                };
                
                this.pipes.push(pipeInfo);
                
                // Store in history for undo
                if (!this.pipeHistory) this.pipeHistory = [];
                this.pipeHistory.push(pipeInfo);
                
                this.checkConnections();
            }
            
            checkConnections() {
                // Clear all previous connections and connecting states
                this.pipes.forEach(pipe => {
                    pipe.connected = false;
                    pipe.element.classList.remove('connected', 'connecting');
                });
                this.connectedPipes = [];
                
                // Create a grid-based connection system for more logical gameplay
                const gridSize = 80; // Match pipe width
                const tolerance = 20; // Allow some positioning flexibility
                
                // Group pipes by grid position
                const gridPipes = {};
                this.pipes.forEach(pipe => {
                    const gridX = Math.floor(pipe.x / gridSize);
                    const gridY = Math.floor(pipe.y / gridSize);
                    const key = `${gridX},${gridY}`;
                    
                    if (!gridPipes[key]) gridPipes[key] = [];
                    gridPipes[key].push(pipe);
                });
                
                // Check for logical connections based on grid adjacency
                Object.keys(gridPipes).forEach(key => {
                    const [gridX, gridY] = key.split(',').map(Number);
                    const currentPipes = gridPipes[key];
                    
                    // Check adjacent grid cells
                    const adjacentKeys = [
                        `${gridX-1},${gridY}`, // left
                        `${gridX+1},${gridY}`, // right
                        `${gridX},${gridY-1}`, // top
                        `${gridX},${gridY+1}`  // bottom
                    ];
                    
                    adjacentKeys.forEach(adjKey => {
                        if (gridPipes[adjKey]) {
                            const adjacentPipes = gridPipes[adjKey];
                            
                            // Try to connect pipes between adjacent cells
                            currentPipes.forEach(pipe => {
                                adjacentPipes.forEach(adjPipe => {
                                    if (!pipe.connected && !adjPipe.connected) {
                                        // Check if these pipes can logically connect
                                        if (this.canPipesConnect(pipe, adjPipe)) {
                                            this.connectPipes(pipe, adjPipe);
                                        }
                                    }
                                });
                            });
                        }
                    });
                });
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            canPipesConnect(pipe1, pipe2) {
                // Only number pipes can connect to other number pipes
                // Connector pipes can connect to any pipe
                if (pipe1.data.value > 0 && pipe2.data.value > 0) {
                    // Two number pipes - check if they can form a valid math expression
                    return this.isValidMathConnection(pipe1, pipe2);
                } else if (pipe1.data.value === 0 || pipe2.data.value === 0) {
                    // At least one connector pipe - always allow connection
                    return true;
                }
                return false;
            }
            
            isValidMathConnection(pipe1, pipe2) {
                // Check if connecting these two number pipes would help solve the problem
                const total = pipe1.data.value + pipe2.data.value;
                
                if (this.currentProblem.operator === '+') {
                    return total === this.currentProblem.answer;
                } else if (this.currentProblem.operator === '×') {
                    return total === this.currentProblem.answer;
                } else if (this.currentProblem.operator === '-') {
                    // For subtraction, we need the larger number minus smaller
                    const larger = Math.max(pipe1.data.value, pipe2.data.value);
                    const smaller = Math.min(pipe1.data.value, pipe2.data.value);
                    return (larger - smaller) === this.currentProblem.answer;
                }
                return false;
            }
            
            connectPipes(pipe1, pipe2) {
                pipe1.connected = true;
                pipe2.connected = true;
                pipe1.element.classList.add('connected');
                pipe2.element.classList.add('connected');
                
                // Add satisfying "click" effect
                this.createConnectionEffect(pipe1, pipe2);
                
                this.connectedPipes.push(pipe1, pipe2);
                this.animateWaterFlow(pipe1, pipe2);
            }
            
            createConnectionEffect(pipe1, pipe2) {
                const playArea = document.getElementById('playArea');
                
                // Create connection spark effect
                const spark = document.createElement('div');
                spark.className = 'connection-spark';
                spark.style.left = ((pipe1.x + pipe2.x) / 2 + 40) + 'px';
                spark.style.top = ((pipe1.y + pipe2.y) / 2 + 20) + 'px';
                playArea.appendChild(spark);
                
                // Remove spark after animation
                setTimeout(() => {
                    if (spark.parentNode) {
                        spark.parentNode.removeChild(spark);
                    }
                }, 600);
            }
            
            animateWaterFlow(pipe1, pipe2) {
                // Create water flow animation between connected pipes
                const playArea = document.getElementById('playArea');
                
                // Create multiple water droplets for better effect
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const flow = document.createElement('div');
                        flow.className = 'water-flow';
                        flow.style.left = (pipe1.x + 40 + (Math.random() - 0.5) * 20) + 'px';
                        flow.style.top = (pipe1.y + 20 + (Math.random() - 0.5) * 20) + 'px';
                        
                        playArea.appendChild(flow);
                        
                        // Animate water flow towards pipe2
                        const startX = parseFloat(flow.style.left);
                        const startY = parseFloat(flow.style.top);
                        const endX = pipe2.x + 40;
                        const endY = pipe2.y + 20;
                        
                        let progress = 0;
                        const animate = () => {
                            progress += 0.02;
                            if (progress <= 1) {
                                flow.style.left = (startX + (endX - startX) * progress) + 'px';
                                flow.style.top = (startY + (endY - startY) * progress) + 'px';
                                requestAnimationFrame(animate);
                            } else {
                                flow.remove();
                            }
                        };
                        animate();
                    }, i * 200);
                }
                
                // Check win condition after animation
                setTimeout(() => {
                    this.checkWinCondition();
                }, 1500);
            }
            
            checkWinCondition() {
                // This method is no longer used in the new flow-based system
                // Win condition is now checked during flow testing
                return;
            }
            
            celebrateWin() {
                this.score += 100 * this.level;
                this.updateDisplay();
                
                // Create splash effect
                const playArea = document.getElementById('playArea');
                const splash = document.createElement('div');
                splash.className = 'splash';
                splash.style.left = '50%';
                splash.style.top = '50%';
                splash.style.transform = 'translate(-50%, -50%)';
                
                playArea.appendChild(splash);
                
                // Show success message
                const success = document.createElement('div');
                success.className = 'success-message';
                success.textContent = '🎉 Water flowing! 🎉';
                success.style.position = 'absolute';
                success.style.top = '20%';
                success.style.left = '50%';
                success.style.transform = 'translateX(-50%)';
                success.style.zIndex = '1000';
                
                playArea.appendChild(success);
                
                setTimeout(() => {
                    splash.remove();
                    success.remove();
                    this.nextLevel();
                }, 2000);
            }
            
            nextLevel() {
                this.level++;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            generateNewProblem() {
                const operators = ['+', '-', '×'];
                const operator = operators[Math.floor(Math.random() * operators.length)];
                let num1, num2, answer;
                
                switch (operator) {
                    case '+':
                        num1 = Math.floor(Math.random() * 10) + 1;
                        num2 = Math.floor(Math.random() * 10) + 1;
                        answer = num1 + num2;
                        break;
                    case '-':
                        num1 = Math.floor(Math.random() * 15) + 5;
                        num2 = Math.floor(Math.random() * num1) + 1;
                        answer = num1 - num2;
                        break;
                    case '×':
                        num1 = Math.floor(Math.random() * 6) + 2;
                        num2 = Math.floor(Math.random() * 6) + 2;
                        answer = num1 * num2;
                        break;
                }
                
                this.currentProblem = { num1, num2, operator, answer };
                document.getElementById('mathProblem').textContent = 
                    `${num1} ${operator} ${num2} = ?`;
            }
            
            clearPlayArea() {
                document.getElementById('playArea').innerHTML = '';
            }
            
            resetLevel() {
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            undoLastPipe() {
                if (!this.pipeHistory || this.pipeHistory.length === 0) {
                    alert('No pipes to undo!');
                    return;
                }
                
                const lastPipe = this.pipeHistory.pop();
                
                // Remove from pipes array
                const index = this.pipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (index > -1) {
                    this.pipes.splice(index, 1);
                }
                
                // Remove from connected pipes if it was connected
                const connectedIndex = this.connectedPipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (connectedIndex > -1) {
                    this.connectedPipes.splice(connectedIndex, 1);
                }
                
                // Remove the DOM element
                if (lastPipe.element && lastPipe.element.parentNode) {
                    lastPipe.element.parentNode.removeChild(lastPipe.element);
                }
                
                // Recheck connections since we removed a pipe
                this.checkConnections();
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (this.pipeHistory && this.pipeHistory.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                }
            }
            
            showGridHighlights() {
                const playArea = document.getElementById('playArea');
                const rect = playArea.getBoundingClientRect();
                const gridSize = 80;
                
                // Clear existing highlights
                this.clearGridHighlights();
                
                // Create grid highlights
                for (let x = 0; x < rect.width; x += gridSize) {
                    for (let y = 0; y < rect.height; y += gridSize) {
                        const highlight = document.createElement('div');
                        highlight.className = 'grid-highlight';
                        highlight.style.left = x + 'px';
                        highlight.style.top = y + 'px';
                        playArea.appendChild(highlight);
                    }
                }
            }
            
            clearGridHighlights() {
                const highlights = document.querySelectorAll('.grid-highlight');
                highlights.forEach(h => h.remove());
            }
            
            showHint() {
                // More helpful hint system for the new expression system
                let hint = '';
                if (this.currentExpression.type === 'simple') {
                    hint = `You need to route from the start pipe (${this.currentExpression.a}) through the ${this.currentExpression.op} operator and the number ${this.currentExpression.b}. The answer should be ${this.correctAnswer}.`;
                } else if (this.currentExpression.type === 'leftGrouped') {
                    hint = `First calculate (${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}), then apply ${this.currentExpression.op2} ${this.currentExpression.c}. Remember: ${this.currentExpression.op1} happens first!`;
                } else if (this.currentExpression.type === 'rightGrouped') {
                    hint = `First calculate (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}), then apply ${this.currentExpression.a} ${this.currentExpression.op1}. Remember: ${this.currentExpression.op2} happens first!`;
                } else if (this.currentExpression.type === 'precedence') {
                    hint = `Remember order of operations: × and ÷ happen before + and −. So calculate ${this.currentExpression.b} × ${this.currentExpression.c} first, then add ${this.currentExpression.a}, then subtract ${this.currentExpression.d}.`;
                }
                alert(hint);
            }
            
            startPressureTimer() {
                if (this.timer) clearInterval(this.timer);
                
                const config = this.getGameConfig();
                this.timer = setInterval(() => {
                    this.pressure += config.pressureRate;
                    this.updateDisplay();
                    
                    if (this.pressure >= this.maxPressure) {
                        this.gameOver();
                    }
                }, 1000);
            }
            
            testFlow() {
                if (this.pipes.length === 0) {
                    alert('Place some pipes first!');
                    return;
                }
                
                // Simulate water flow through the pipe network
                this.animateFlow();
            }
            
            animateFlow() {
                const playArea = document.getElementById('playArea');
                
                // Find the path from start to answer pipes
                const path = this.findFlowPath();
                
                if (!path) {
                    this.showFlowError('No valid path found!');
                    return;
                }
                
                // Animate water flow step by step
                let currentValue = this.startPipe.value;
                let step = 0;
                
                const animateStep = () => {
                    if (step >= path.length) {
                        this.checkFlowResult(currentValue);
                        return;
                    }
                    
                    const pipe = path[step];
                    const flowElement = this.createFlowElement(pipe.x, pipe.y);
                    playArea.appendChild(flowElement);
                    
                    // Apply operation if it's an operator
                    if (pipe.data && pipe.data.type === 'operator') {
                        const nextPipe = path[step + 1];
                        if (nextPipe && nextPipe.data && nextPipe.data.type === 'number') {
                            currentValue = this.applyOperation(currentValue, nextPipe.data.value, pipe.data.operation);
                            step++; // Skip the number pipe since we processed it
                        }
                    }
                    
                    step++;
                    
                    setTimeout(() => {
                        flowElement.remove();
                        animateStep();
                    }, 500);
                };
                
                animateStep();
            }
            
            findFlowPath() {
                // Simple pathfinding from start to answer pipes
                // This is a simplified version - in a full implementation you'd want proper pathfinding
                const path = [];
                const visited = new Set();
                
                const dfs = (x, y, targetX, targetY) => {
                    if (x === targetX && y === targetY) return true;
                    if (x < 0 || y < 0 || x >= this.gridSize || y >= this.gridSize) return false;
                    
                    const key = `${x},${y}`;
                    if (visited.has(key)) return false;
                    visited.add(key);
                    
                    // Check if there's a pipe here
                    const pipe = this.pipes.find(p => Math.floor(p.x / 80) === x && Math.floor(p.y / 80) === y);
                    if (pipe) {
                        path.push(pipe);
                        
                        // Try adjacent cells
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            if (dfs(x + dx, y + dy, targetX, targetY)) return true;
                        }
                        
                        path.pop();
                    }
                    
                    return false;
                };
                
                // Try to find path to correct answer
                const correctAnswer = this.answerPipes.find(p => p.isCorrect);
                if (correctAnswer && dfs(1, Math.floor(this.gridSize / 2), correctAnswer.x, correctAnswer.y)) {
                    return path;
                }
                
                return null;
            }
            
            createFlowElement(x, y) {
                const flow = document.createElement('div');
                flow.className = 'water-flow';
                flow.style.left = (x + 40) + 'px';
                flow.style.top = (y + 20) + 'px';
                return flow;
            }
            
            checkFlowResult(finalValue) {
                const correctAnswer = this.answerPipes.find(p => p.isCorrect);
                
                if (finalValue === correctAnswer.value) {
                    this.celebrateWin();
                } else {
                    this.showFlowError(`Flow reached value ${finalValue}, but correct answer is ${correctAnswer.value}`);
                }
            }
            
            showFlowError(message) {
                this.pressure += 20; // Increase pressure for failed attempt
                alert(message);
                this.updateDisplay();
            }
            
            gameOver() {
                clearInterval(this.timer);
                this.gameActive = false;
                
                const gameOver = document.createElement('div');
                gameOver.className = 'game-over';
                gameOver.innerHTML = `
                    <h2>Pressure Too High!</h2>
                    <p>Final Score: ${this.score}</p>
                    <p>Level Reached: ${this.level}</p>
                    <p>Stars Earned: ${this.stars}</p>
                    <button class="control-btn" onclick="location.reload()">Play Again</button>
                `;
                
                document.getElementById('playArea').appendChild(gameOver);
            }
            
            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('stars').textContent = this.stars;
                document.getElementById('pressure').textContent = Math.round(this.pressure);
                
                // Update pressure bar
                const pressureFill = document.getElementById('pressureFill');
                if (pressureFill) {
                    pressureFill.style.width = (this.pressure / this.maxPressure * 100) + '%';
                }
                
                // Update expression display
                if (this.currentExpression) {
                    let expressionText = '';
                    if (this.currentExpression.type === 'simple') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op} ${this.currentExpression.b} = ?`;
                    } else if (this.currentExpression.type === 'leftGrouped') {
                        expressionText = `(${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}) ${this.currentExpression.op2} ${this.currentExpression.c} = ?`;
                    } else if (this.currentExpression.type === 'rightGrouped') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op1} (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}) = ?`;
                    } else if (this.currentExpression.type === 'precedence') {
                        expressionText = `${this.currentExpression.a} + ${this.currentExpression.b} × ${this.currentExpression.c} - ${this.currentExpression.d} = ?`;
                    }
                    document.getElementById('mathProblem').textContent = expressionText;
                }
            }
        }
        
        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PipeDream();
        });
    </script>
</body>
</html>
