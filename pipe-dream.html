<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Dream - Retro Games Collection</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        :root{
            --wall:#0bb;
            --bg:#000;
            --score:#0f0;
            --title:#ffd700;
            --focus-outline: #0ff;
        }

        .app{ 
            height: 80%;
            display:flex;
            flex-direction: column;
            gap:15px;
            align-items:center;
            justify-content:center;
            padding:15px;
            width: 100%;
            max-width: 1200px;
        }

        .game-wrap {
            position: relative;
        }

        .game-container {
            background: #1a1a2e;
            border: 3px solid #0f0;
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            text-align: center;
        }

        #sidebar{
            width: 100%;
            max-width: 220px;
            color:var(--score);
            display:flex;
            flex-direction:column;
            gap:14px
        }

        #title { 
            text-transform: uppercase; 
            font-size: clamp(1.5rem, 4vw, 2rem);
            color: var(--title); 
            text-shadow: 0 0 8px #f00; 
            text-align: center;
            margin: 0;
        }

        .section-title{
            color:var(--title);
            font-weight:700;
            margin-bottom:8px
        }

        #scoreboard{
            border:2px solid var(--score);
            padding:12px;
            display:grid;
            grid-template-columns:1fr 1fr;
            gap:8px;
            align-items:center;
            border-radius: 6px;
        }

        #scoreboard .section-title{
            text-align:left;
            margin:0
        }

        #scoreboard div.value{
            text-align:right
        }

        #instructions{
            font-size:13px;
            line-height:1.4
        }

        .game-header {
            margin-bottom: 20px;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
            border: 2px solid #0f0;
        }

        .math-problem {
            font-size: 2rem;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin: 20px 0;
        }

        .pipe-inventory {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 255, 0, 0.05);
            border-radius: 10px;
            border: 1px solid #0f0;
        }

        .pipe-piece {
            width: 80px;
            height: 80px;
            display: grid;
            place-items: center;
            background: transparent;
            border: none;
            box-shadow: none;
            user-select: none;
            cursor: grab;
            transition: all 0.3s ease;
            touch-action: manipulation;
            position: relative;
            transform-style: preserve-3d;
        }







        .pipe-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #0f0;
        }

        .pipe-piece svg, .placed-pipe svg {
            width: 86%;
            height: 86%;
            overflow: visible;
        }

        .pipe-stroke {
            stroke: #a8c7d8;
            stroke-width: 16;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 1px 0 rgba(0,0,0,.35));
        }
        .pipe-stroke.glow { stroke: #6ddcff; }
        .pipe-inner { stroke: rgba(255,255,255,.22); stroke-width: 6; }
        .pipe-endcap { fill: #86a7b8; opacity: .7; }

        /* Pipe type indicators */
        .pipe-piece .number-pipe {
            background: linear-gradient(135deg, #4CAF50, #66BB6A) !important;
            border-color: #2E7D32 !important;
        }

        .pipe-piece .operator-pipe {
            background: linear-gradient(135deg, #FF9800, #FFB74D) !important;
            border-color: #F57C00 !important;
        }

        .pipe-piece .connector-pipe {
            background: transparent !important;
            border: none !important;
        }

        .pipe-piece.dragging, .placed-pipe.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
            z-index: 1000;
        }
        
        .placed-pipe {
            cursor: grab;
        }
        
        .placed-pipe:active {
            cursor: grabbing;
        }
        
        .placed-pipe.rotatable {
            cursor: pointer;
        }
        
        .placed-pipe.rotatable:hover::after {
            content: 'ðŸ”„ Double-click to rotate';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 1001;
        }

        .play-area {
            width: 100%;
            height: 400px;
            background: #16213e;
            border: 3px solid #0f0;
            border-radius: 15px;
            position: relative;
            margin: 20px 0;
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 80px 80px;
        }

        .placed-pipe {
            position: absolute;
            width: 80px;
            height: 80px;
            display: grid;
            place-items: center;
            background: transparent;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
        }



        .placed-pipe.connected {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border-color: #2E7D32;
            box-shadow: 
                0 0 20px #4CAF50,
                0 0 40px rgba(76, 175, 80, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
            animation: pipeConnect 0.6s ease-out;
        }

        @keyframes pipeConnect {
            0% { 
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 0px #4CAF50;
            }
            25% { 
                transform: scale(1.1) rotate(2deg);
                box-shadow: 0 0 30px #4CAF50;
            }
            50% { 
                transform: scale(1.05) rotate(-1deg);
                box-shadow: 0 0 25px #4CAF50;
            }
            100% { 
                transform: scale(1.05) rotate(0deg);
                box-shadow: 0 0 20px #4CAF50;
            }
        }

        .placed-pipe.connecting {
            background: linear-gradient(135deg, #FFD700, #FFED4E);
            border-color: #FF8C00;
            box-shadow: 
                0 0 15px #FFD700,
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            animation: connectingPulse 1.5s ease-in-out infinite;
        }

        @keyframes connectingPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 15px #FFD700, 0 0 30px rgba(255, 215, 0, 0.3);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 20px #FFD700, 0 0 40px rgba(255, 215, 0, 0.5);
            }
        }

        .grid-highlight {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px dashed #0f0;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 1;
            animation: gridPulse 2s infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .placed-pipe.filled {
            background: linear-gradient(45deg, #0066cc, #0099ff);
            border-color: #0099ff;
            box-shadow: 0 0 20px #0099ff;
        }

        .start-pipe {
            position: absolute;
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border: 4px solid #2E7D32;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(76, 175, 80, 0.5);
            animation: startPipeGlow 2s ease-in-out infinite;
        }



        @keyframes startPipeGlow {
            0%, 100% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 20px rgba(76, 175, 80, 0.5);
            }
            50% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 30px rgba(76, 175, 80, 0.8);
            }
        }

        .answer-pipe {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 4px solid #666;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }



        .answer-pipe.correct {
            background: linear-gradient(135deg, #F44336, #EF5350);
            border-color: #D32F2F;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(244, 67, 54, 0.5);
        }

        .answer-pipe.decoy {
            background: linear-gradient(135deg, #2196F3, #42A5F5);
            border-color: #1976D2;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(33, 150, 243, 0.5);
        }

        .grid-cell {
            background: rgba(0, 255, 0, 0.05);
        }

        .connection-spark {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #FFD700, #FFA500, transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: sparkEffect 0.6s ease-out forwards;
        }

        @keyframes sparkEffect {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
                box-shadow: 0 0 0px #FFD700;
            }
            25% { 
                transform: scale(2) rotate(90deg);
                opacity: 1;
                box-shadow: 0 0 20px #FFD700;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
                box-shadow: 0 0 15px #FFD700;
            }
            100% { 
                transform: scale(0) rotate(360deg);
                opacity: 0;
                box-shadow: 0 0 0px #FFD700;
            }
        }

        .water-flow {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #4FC3F7, #29B6F6, #0288D1);
            border-radius: 50%;
            pointer-events: none;
            animation: waterFlow 2s linear infinite;
            box-shadow: 0 0 8px #4FC3F7;
        }

        @keyframes waterFlow {
            0% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
            25% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            50% { 
                transform: scale(1); 
                opacity: 1; 
                box-shadow: 0 0 8px #4FC3F7;
            }
            75% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            100% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
        }

        .splash {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #0099ff, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: splash 1s ease-out forwards;
        }

        @keyframes splash {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .game-controls {
            margin: 20px 0;
        }

        .control-btn {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 12px 25px;
            margin: 0 10px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .control-btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .score-display {
            font-size: 1.2rem;
            color: #ffd700;
            margin: 15px 0;
        }

        .pressure-gauge {
            font-size: 1.2rem;
            color: #ff6b6b;
            font-weight: bold;
        }

        .pressure-bar {
            width: 100px;
            height: 20px;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .pressure-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffd700;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            text-align: center;
            z-index: 1000;
        }

        .success-message {
            color: #0f0;
            font-size: 1.5rem;
            margin: 20px 0;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Responsive breakpoints */
        @media (min-width: 768px) {
            .app {
                flex-direction: row;
                align-items: flex-start;
                gap: 20px;
                padding: 18px;
            }
            
            .game-wrap {
                flex: 1;
            }
            
            .game-container {
                max-width: 800px;
                margin: 0;
            }
            
            #sidebar {
                width: 220px;
                flex-shrink: 0;
            }
        }

        /* Mobile responsiveness */
        @media (max-width: 767px) {
            .app {
                flex-direction: column;
                padding: 10px;
            }
            
            .game-container {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings > div {
                grid-template-columns: 1fr !important;
            }
            
            .play-area {
                height: 300px;
            }
            
            .pipe-inventory {
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }
            
            .pipe-piece {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .math-problem {
                font-size: 1.5rem;
            }
            
            #sidebar {
                width: 100%;
                max-width: none;
            }
        }

        @keyframes sparkEffect {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
                box-shadow: 0 0 0px #FFD700;
            }
            25% { 
                transform: scale(2) rotate(90deg);
                opacity: 1;
                box-shadow: 0 0 20px #FFD700;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
                box-shadow: 0 0 15px #FFD700;
            }
            100% { 
                transform: scale(0) rotate(360deg);
                opacity: 0;
                box-shadow: 0 0 0px #FFD700;
            }
        }

        .connection-line {
            background: linear-gradient(90deg, #4FC3F7, #29B6F6);
            border-radius: 4px;
            box-shadow: 0 0 8px #4FC3F7;
            animation: connectionGlow 2s ease-in-out infinite;
        }

        @keyframes connectionGlow {
            0%, 100% { 
                box-shadow: 0 0 8px #4FC3F7;
                opacity: 0.8;
            }
            50% { 
                box-shadow: 0 0 15px #4FC3F7, 0 0 25px rgba(79, 195, 247, 0.5);
                opacity: 1;
            }
        }

        .placed-pipe.flowing {
            animation: waterFlow 3s ease-in-out infinite;
        }

        @keyframes waterFlow {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.02);
                filter: brightness(1.2);
            }
        }

        /* Enhanced styling for curved elbows */
        .placed-pipe:contains('â•­'), .placed-pipe:contains('â•®'), 
        .placed-pipe:contains('â•°'), .placed-pipe:contains('â•¯') {
            font-size: 1.5rem;
            color: #555;
        }

        /* T-junction styling */
        .placed-pipe:contains('â”£'), .placed-pipe:contains('â”«'),
        .placed-pipe:contains('â”»'), .placed-pipe:contains('â”³') {
            font-size: 1.4rem;
            color: #555;
        }

        /* Cross junction styling */
        .placed-pipe:contains('â•‹') {
            font-size: 1.3rem;
            color: #555;
        }
    </style>
</head>
<body>
    <nav id="gameNav" style="padding:10px; background:#111; color:#0f0; font-family:monospace;">
        <strong>Games:</strong>
    </nav>

    <div class="app">
        <div class="game-wrap">
            <div class="game-container">
                <div class="game-header">
                    <h1>ðŸš° Pipe Dream</h1>
                    <p>Connect pipes to solve math problems and watch the water flow!</p>
                </div>

    <div class="game-container">
        <div class="game-header">
            <h1>ðŸš° Pipe Dream</h1>
            <p>Connect pipes to solve math problems and watch the water flow!</p>
            
            
        </div>

        <div class="level-info">
            <div class="score-display">
                <strong>Level:</strong> <span id="level">1</span>
                <strong>Score:</strong> <span id="score">0</span>
                <strong>Stars:</strong> <span id="stars">0</span>
            </div>
            <div class="pressure-gauge">
                <strong>Pressure:</strong> <span id="pressure">0</span>%
                <div class="pressure-bar">
                    <div class="pressure-fill" id="pressureFill"></div>
                </div>
            </div>
        </div>

        <div class="math-problem" id="mathProblem" role="heading" aria-level="2">
            5 + 3 = ?
        </div>

        <div class="pipe-inventory" id="pipeInventory">
            <!-- Pipe pieces will be generated here -->
        </div>

        <div class="play-area" id="playArea">
            <!-- Placed pipes will appear here -->
        </div>

        <div class="game-controls">
            <button class="control-btn" id="newLevelBtn" aria-label="Start new level">New Level</button>
            <button class="control-btn" id="resetBtn" aria-label="Reset current level">Reset</button>
            <button class="control-btn" id="undoBtn" aria-label="Undo last pipe placement">Undo</button>
            <button class="control-btn" id="flowTestBtn" aria-label="Test water flow">Flow Test</button>
            <button class="control-btn" id="hintBtn" aria-label="Get a hint for current problem">Hint</button>
        </div>
            </div>
        </div>

        <div id="sidebar">
            <h1 id="title">Pipe Dream</h1>

            <div role="region" aria-label="Game Settings">
                <div class="section-title">SETTINGS</div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: #0f0;">Game Mode:</label>
                    <select id="gameMode" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px; margin-bottom: 10px;">
                        <option value="practice">Practice (Free Build)</option>
                        <option value="adventure">Adventure (Levels)</option>
                        <option value="timed">Timed Rush</option>
                    </select>
                    
                    <label style="display: block; margin-bottom: 5px; color: #0f0;">Difficulty:</label>
                    <select id="difficulty" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px; margin-bottom: 10px;">
                        <option value="easy">Easy (5Ã—5 grid)</option>
                        <option value="medium">Medium (7Ã—7 grid)</option>
                        <option value="hard">Hard (9Ã—9 grid)</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div class="section-title">OPERATIONS</div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="opAdd" checked style="accent-color: #0f0;"> +
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="opSub" style="accent-color: #0f0;"> âˆ’
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="opMul" style="accent-color: #0f0;"> Ã—
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="opDiv" style="accent-color: #0f0;"> Ã·
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="allowNegatives" style="accent-color: #0f0;"> Allow Negatives
                        </label>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                            <input type="checkbox" id="showPrecedenceHints" checked style="accent-color: #0f0;"> Show Hints
                        </label>
                    </div>
                </div>
                
                <button id="applySettings" style="width: 100%; background: #0f0; color: #000; border: none; padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;">
                    Apply Settings & New Game
                </button>
            </div>

            <div id="scoreboard" role="region" aria-label="Game Score">
                <div class="section-title">CURRENT</div>
                <div class="section-title">Level</div><div class="value" id="levelDisplay">1</div>
                <div class="section-title">Score</div><div class="value" id="scoreDisplay">0</div>
                <div class="section-title">Pressure</div><div class="value" id="pressureDisplay">0%</div>
            </div>

            <div id="instructions">
                <div class="section-title">CONTROLS</div>
                Drag & Drop â€” place pipes<br>
                Double-click â€” rotate pipes<br>
                Drag placed pipes â€” reposition
                
                <div style="margin-top: 15px" class="section-title">RULES</div>
                <div style="font-size: 13px; line-height: 1.4;">
                    â€¢ Connect start pipe (green) to answer pipe (red)<br>
                    â€¢ Use operator pipes (+, âˆ’, Ã—, Ã·) for math<br>
                    â€¢ Route through connector pipes<br>
                    â€¢ Water flows when pipes connect<br>
                    â€¢ Solve the math expression correctly
                </div>
            </div>
        </div>
    </div>

    <script>
        class PipeDream {
            constructor() {
                this.gameMode = 'practice'; // 'adventure', 'practice', 'timed'
                this.difficulty = 'easy'; // 'easy', 'medium', 'hard', 'custom'
                this.operations = ['+']; // Available operations - default to addition only
                this.allowNegatives = false;
                this.showPrecedenceHints = true;
                
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 0;
                this.maxPressure = 100;
                this.gameActive = true;
                
                this.pipes = [];
                this.connectedPipes = [];
                this.draggedPipe = null;
                this.draggedPlacedPipe = null;
                this.timer = null;
                this.pipeHistory = [];
                
                this.gridSize = 7; // 7x7 for medium
                this.startPipe = null;
                this.answerPipes = [];
                this.obstacles = [];
                this.inventory = [];
                
                this.currentExpression = null;
                this.correctAnswer = null;
                this.decoyAnswers = [];
                
                this.init();
            }
            
            // Game configuration based on difficulty
            getGameConfig() {
                const configs = {
                    easy: {
                        gridSize: 5,
                        maxPathLength: 8,
                        answerPipeCount: 3,
                        allowCrossings: false,
                        pressureRate: 0.5
                    },
                    medium: {
                        gridSize: 7,
                        maxPathLength: 12,
                        answerPipeCount: 4,
                        allowCrossings: false,
                        pressureRate: 1.0
                    },
                    hard: {
                        gridSize: 9,
                        maxPathLength: 16,
                        answerPipeCount: 5,
                        allowCrossings: true,
                        pressureRate: 2.0
                    }
                };
                return configs[this.difficulty] || configs.medium;
            }
            
            // Enhanced pipe types with operators and special pieces
            getPipeTypes() {
                const basePipes = [
                    // Numbers
                    { symbol: '1', value: 1, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '2', value: 2, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '3', value: 3, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '4', value: 4, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '5', value: 5, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '6', value: 6, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '7', value: 7, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '8', value: 8, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '9', value: 9, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Operators
                    { symbol: 'â—', value: 0, type: 'operator', operation: '+', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: 'â—', value: 0, type: 'operator', operation: '-', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: 'â—', value: 0, type: 'operator', operation: 'Ã—', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: 'â—', value: 0, type: 'operator', operation: 'Ã·', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Connectors - make them look more like actual pipe segments with proper curves
                    { symbol: 'â•‹', value: 0, type: 'connector', connections: ['top', 'bottom', 'left', 'right'] }, // cross junction
                    { symbol: 'â”£', value: 0, type: 'connector', connections: ['top', 'bottom', 'left'] }, // T-junction left
                    { symbol: 'â”«', value: 0, type: 'connector', connections: ['top', 'bottom', 'right'] }, // T-junction right
                    { symbol: 'â”»', value: 0, type: 'connector', connections: ['bottom', 'left', 'right'] }, // T-junction bottom
                    { symbol: 'â”³', value: 0, type: 'connector', connections: ['top', 'left', 'right'] }, // T-junction top
                    { symbol: 'â•­', value: 0, type: 'connector', connections: ['top', 'right'] }, // top-right curved elbow
                    { symbol: 'â•®', value: 0, type: 'connector', connections: ['top', 'left'] }, // top-left curved elbow
                    { symbol: 'â•°', value: 0, type: 'connector', connections: ['bottom', 'right'] }, // bottom-right curved elbow
                    { symbol: 'â•¯', value: 0, type: 'connector', connections: ['bottom', 'left'] }, // bottom-left curved elbow
                    { symbol: 'â”', value: 0, type: 'connector', connections: ['left', 'right'] }, // horizontal pipe
                    { symbol: 'â”ƒ', value: 0, type: 'connector', connections: ['top', 'bottom'] } // vertical pipe
                ];
                
                // Add special pieces for medium+ difficulty
                if (this.difficulty !== 'easy') {
                    basePipes.push(
                        { symbol: 'â•¬', value: 0, type: 'splitter', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: 'â–¶', value: 0, type: 'valve', connections: ['left', 'right'] }
                    );
                }
                
                // Add advanced pieces for hard difficulty
                if (this.difficulty === 'hard') {
                    basePipes.push(
                        { symbol: 'âŠ•', value: 0, type: 'crossover', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: 'âš¡', value: 0, type: 'pressureValve', connections: ['top', 'bottom', 'left', 'right'] }
                    );
                }
                
                return basePipes;
            }
            
            init() {
                this.pipeHistory = [];
                this.gridSize = this.getGameConfig().gridSize;
                this.createNewPuzzle();
                this.setupEventListeners();
                this.startPressureTimer();
                this.updateDisplay();
                this.updateUndoButton();
                this.setupSettingsUI();
            }
            
            setupSettingsUI() {
                // Set initial UI values
                document.getElementById('gameMode').value = this.gameMode;
                document.getElementById('difficulty').value = this.difficulty;
                document.getElementById('opAdd').checked = this.operations.includes('+');
                document.getElementById('opSub').checked = this.operations.includes('-');
                document.getElementById('opMul').checked = this.operations.includes('Ã—');
                document.getElementById('opDiv').checked = this.operations.includes('Ã·');
                document.getElementById('allowNegatives').checked = this.allowNegatives;
                document.getElementById('showPrecedenceHints').checked = this.showPrecedenceHints;
                
                // Add event listener for apply settings button
                document.getElementById('applySettings').addEventListener('click', () => this.applySettings());
            }
            
            applySettings() {
                // Update game settings from UI
                this.gameMode = document.getElementById('gameMode').value;
                this.difficulty = document.getElementById('difficulty').value;
                
                // Update operations
                this.operations = [];
                if (document.getElementById('opAdd').checked) this.operations.push('+');
                if (document.getElementById('opSub').checked) this.operations.push('-');
                if (document.getElementById('opMul').checked) this.operations.push('Ã—');
                if (document.getElementById('opDiv').checked) this.operations.push('Ã·');
                
                // Ensure at least one operation is selected
                if (this.operations.length === 0) {
                    this.operations = ['+'];
                    document.getElementById('opAdd').checked = true;
                    alert('At least one operation must be selected. Defaulting to addition.');
                }
                
                // Update other settings
                this.allowNegatives = document.getElementById('allowNegatives').checked;
                this.showPrecedenceHints = document.getElementById('showPrecedenceHints').checked;
                
                // Reset game with new settings
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
                
                alert('Settings applied! New game started.');
            }
            
            createNewPuzzle() {
                this.currentExpression = this.generateExpression();
                this.correctAnswer = this.evaluateExpression(this.currentExpression);
                this.decoyAnswers = this.generateDecoyAnswers();
                this.createGrid();
                this.placeStartAndAnswerPipes();
                this.generateInventory();
                this.updateDisplay();
            }
            
            generateExpression() {
                const config = this.getGameConfig();
                let expression;
                
                if (this.difficulty === 'easy') {
                    // Simple: a âŠ• b
                    const op = this.operations[Math.floor(Math.random() * this.operations.length)];
                    const a = this.getRandomNumber(op, 0, 10);
                    const b = this.getRandomNumber(op, 0, 10);
                    expression = { a, b, op, type: 'simple' };
                } else if (this.difficulty === 'medium') {
                    // Medium: (a âŠ• b) âŠ— c or a âŠ• (b âŠ— c)
                    // Only use operations that are available
                    const availableOps = this.operations.filter(op => op !== 'Ã·'); // Avoid division in medium for now
                    if (availableOps.length < 2) {
                        // Fall back to simple if not enough operations
                        const op = this.operations[0];
                        const a = this.getRandomNumber(op, 0, 15);
                        const b = this.getRandomNumber(op, 0, 15);
                        expression = { a, b, op, type: 'simple' };
                    } else {
                        const op1 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const op2 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const a = this.getRandomNumber(op1, 0, 20);
                        const b = this.getRandomNumber(op1, 0, 20);
                        const c = this.getRandomNumber(op2, 0, 10);
                        
                        if (Math.random() > 0.5) {
                            expression = { a, b, c, op1, op2, type: 'leftGrouped' };
                        } else {
                            expression = { a, b, c, op1, op2, type: 'rightGrouped' };
                        }
                    }
                } else {
                    // Hard: a âŠ• b âŠ— c âŠ– d with precedence
                    // Only use available operations
                    const addOps = this.operations.filter(op => op === '+' || op === '-');
                    const mulOps = this.operations.filter(op => op === 'Ã—' || op === 'Ã·');
                    
                    if (addOps.length === 0) addOps.push('+');
                    if (mulOps.length === 0) mulOps.push('Ã—');
                    
                    const a = this.getRandomNumber(addOps[0], 0, 50);
                    const b = this.getRandomNumber(mulOps[0], 0, 12);
                    const c = this.getRandomNumber(mulOps[0], 0, 12);
                    const d = this.getRandomNumber(addOps[0], 0, 50);
                    expression = { a, b, c, d, type: 'precedence' };
                }
                
                return expression;
            }
            
            getRandomNumber(operation, min, max) {
                let num;
                do {
                    num = Math.floor(Math.random() * (max - min + 1)) + min;
                } while (!this.allowNegatives && operation === '-' && num === 0);
                return num;
            }
            
            evaluateExpression(expr) {
                if (expr.type === 'simple') {
                    return this.applyOperation(expr.a, expr.b, expr.op);
                } else if (expr.type === 'leftGrouped') {
                    const first = this.applyOperation(expr.a, expr.b, expr.op1);
                    return this.applyOperation(first, expr.c, expr.op2);
                } else if (expr.type === 'rightGrouped') {
                    const second = this.applyOperation(expr.b, expr.c, expr.op2);
                    return this.applyOperation(expr.a, second, expr.op1);
                } else if (expr.type === 'precedence') {
                    // Follow order of operations: Ã— Ã· before + âˆ’
                    const product = this.applyOperation(expr.b, expr.c, 'Ã—');
                    const sum = this.applyOperation(expr.a, product, '+');
                    return this.applyOperation(sum, expr.d, '-');
                }
                return 0;
            }
            
            applyOperation(a, b, op) {
                switch (op) {
                    case '+': return a + b;
                    case '-': return a - b;
                    case 'Ã—': return a * b;
                    case 'Ã·': return Math.floor(a / b);
                    default: return a;
                }
            }
            
            generateDecoyAnswers() {
                const config = this.getGameConfig();
                const decoys = [];
                const correct = this.correctAnswer;
                
                // Generate plausible wrong answers
                const decoyTypes = [
                    correct + 1, // off-by-one
                    correct - 1,
                    correct * 2, // operation confusion
                    correct / 2,
                    Math.abs(correct), // sign error
                    -correct
                ];
                
                // Filter valid decoys
                decoyTypes.forEach(decoy => {
                    if (decoy !== correct && 
                        decoy >= (this.allowNegatives ? -100 : 0) && 
                        decoy <= 100 &&
                        !decoys.includes(decoy)) {
                        decoys.push(decoy);
                    }
                });
                
                // Fill remaining slots with random plausible values
                while (decoys.length < config.answerPipeCount - 1) {
                    const randomDecoy = Math.floor(Math.random() * 50) - (this.allowNegatives ? 25 : 0);
                    if (randomDecoy !== correct && !decoys.includes(randomDecoy)) {
                        decoys.push(randomDecoy);
                    }
                }
                
                return decoys.slice(0, config.answerPipeCount - 1);
            }
            
            createGrid() {
                const playArea = document.getElementById('playArea');
                playArea.innerHTML = '';
                
                // Set grid size
                const config = this.getGameConfig();
                this.gridSize = config.gridSize;
                
                // Update grid background
                playArea.style.backgroundSize = `${80}px ${80}px`;
                
                // Create grid cells for visual reference
                for (let x = 0; x < this.gridSize; x++) {
                    for (let y = 0; y < this.gridSize; y++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.style.position = 'absolute';
                        cell.style.left = (x * 80) + 'px';
                        cell.style.top = (y * 80) + 'px';
                        cell.style.width = '80px';
                        cell.style.height = '80px';
                        cell.style.border = '1px solid rgba(0, 255, 0, 0.2)';
                        cell.style.pointerEvents = 'none';
                        cell.style.zIndex = '1';
                        playArea.appendChild(cell);
                    }
                }
            }
            
            placeStartAndAnswerPipes() {
                const playArea = document.getElementById('playArea');
                const config = this.getGameConfig();
                
                // Place start pipe on left side, centered vertically in the row
                const startY = Math.floor(this.gridSize / 2);
                this.startPipe = {
                    x: 0,
                    y: startY,
                    value: this.currentExpression.a,
                    type: 'start'
                };
                
                // Create start pipe element
                const startElement = document.createElement('div');
                startElement.className = 'start-pipe';
                startElement.textContent = this.currentExpression.a;
                startElement.style.left = '0px';
                startElement.style.top = (startY * 80) + 'px'; // Center vertically in the 80px grid cell
                playArea.appendChild(startElement);
                
                // Place answer pipes along right and bottom edges
                const allAnswers = [this.correctAnswer, ...this.decoyAnswers];
                const shuffledAnswers = allAnswers.sort(() => Math.random() - 0.5);
                
                shuffledAnswers.forEach((answer, index) => {
                    let x, y;
                    
                    if (index < this.gridSize - 1) {
                        // Place along right edge
                        x = this.gridSize - 1;
                        y = index;
                    } else {
                        // Place along bottom edge
                        x = index - (this.gridSize - 1);
                        y = this.gridSize - 1;
                    }
                    
                    const answerPipe = {
                        x: x,
                        y: y,
                        value: answer,
                        type: 'answer',
                        isCorrect: answer === this.correctAnswer
                    };
                    
                    this.answerPipes.push(answerPipe);
                    
                    // Create answer pipe element
                    const answerElement = document.createElement('div');
                    answerElement.className = `answer-pipe ${answer === this.correctAnswer ? 'correct' : 'decoy'}`;
                    answerElement.textContent = answer;
                    answerElement.style.left = (x * 80) + 'px';
                    answerElement.style.top = (y * 80) + 'px'; // Center vertically in the grid cell
                    playArea.appendChild(answerElement);
                });
            }
            
            generateInventory() {
                const inventory = document.getElementById('pipeInventory');
                inventory.innerHTML = '';
                
                const config = this.getGameConfig();
                const pipeTypes = this.getPipeTypes();
                const pipes = [];
                
                // Add numbers from the expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'precedence') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.d));
                }
                
                // Add some extra numbers to make players think strategically
                const extraNumbers = [2, 3, 4, 6, 7, 8, 9].filter(num => {
                    // Don't add numbers that are already in the expression
                    if (this.currentExpression.type === 'simple') {
                        return num !== this.currentExpression.a && num !== this.currentExpression.b;
                    } else if (this.currentExpression.type === 'leftGrouped') {
                        return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c;
                    } else if (this.currentExpression.type === 'rightGrouped') {
                        return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c;
                    } else if (this.currentExpression.type === 'precedence') {
                        return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c && num !== this.currentExpression.d;
                    }
                    return true;
                });
                
                // Add 2-3 random extra numbers
                const extraCount = Math.min(3, extraNumbers.length);
                for (let i = 0; i < extraCount; i++) {
                    const randomIndex = Math.floor(Math.random() * extraNumbers.length);
                    const extraNum = extraNumbers.splice(randomIndex, 1)[0];
                    pipes.push(pipeTypes.find(p => p.value === extraNum));
                }
                
                // Add operators - only use the ones in the current expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'precedence') {
                    // For precedence, we need specific operations
                    if (this.operations.includes('+')) pipes.push(pipeTypes.find(p => p.operation === '+'));
                    if (this.operations.includes('Ã—')) pipes.push(pipeTypes.find(p => p.operation === 'Ã—'));
                    if (this.operations.includes('-')) pipes.push(pipeTypes.find(p => p.operation === '-'));
                }
                
                // Add connector pipes - ensure we have enough for the grid
                const connectors = pipeTypes.filter(p => p.type === 'connector');
                const connectorCount = Math.min(12, connectors.length); // More connectors for better gameplay
                for (let i = 0; i < connectorCount; i++) {
                    pipes.push(connectors[i]);
                }
                
                // Filter out undefined pipes and shuffle
                const validPipes = pipes.filter(pipe => pipe !== undefined);
                const shuffledPipes = validPipes.sort(() => Math.random() - 0.5);
                
                shuffledPipes.forEach(pipe => {
                    const pipeElement = document.createElement('div');
                    pipeElement.className = 'pipe-piece';
                    pipeElement.draggable = true;
                    pipeElement.dataset.pipeType = JSON.stringify(pipe);
                    
                    // Decide what kind of pipe it is and render SVG
                    let type = 'straight-h'; let rot = 0;
                    
                    if (pipe.type === 'number') {
                        // Number pipes get a special number display
                        pipeElement.innerHTML = `
                            <div style="
                                width: 100%; 
                                height: 100%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                background: linear-gradient(135deg, #4CAF50, #66BB6A);
                                border: 3px solid #2E7D32;
                                border-radius: 15px;
                                color: white;
                                font-size: 1.5rem;
                                font-weight: bold;
                                text-shadow: 1px 1px 2px #000;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                                position: relative;
                            ">
                                ${pipe.symbol}
                                <div style="
                                    position: absolute;
                                    bottom: -25px;
                                    left: 50%;
                                    transform: translateX(-50%);
                                    background: rgba(0,0,0,0.8);
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 4px;
                                    font-size: 0.7rem;
                                    white-space: nowrap;
                                ">
                                    Number
                                </div>
                            </div>
                        `;
                    } else if (pipe.type === 'operator') {
                        // Operator pipes get a special operator display
                        pipeElement.innerHTML = `
                            <div style="
                                width: 100%; 
                                height: 100%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                background: linear-gradient(135deg, #FF9800, #FFB74D);
                                border: 3px solid #F57C00;
                                border-radius: 15px;
                                color: white;
                                font-size: 1.8rem;
                                font-weight: bold;
                                text-shadow: 1px 1px 2px #000;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                                position: relative;
                            ">
                                ${pipe.operation}
                                <div style="
                                    position: absolute;
                                    bottom: -25px;
                                    left: 50%;
                                    transform: translateX(-50%);
                                    background: rgba(0,0,0,0.8);
                                    color: white;
                                    padding: 2px 6px;
                                    border-radius: 4px;
                                    font-size: 0.7rem;
                                    white-space: nowrap;
                                ">
                                    Operator
                                </div>
                            </div>
                        `;
                    } else {
                        // Connector pipes use SVG rendering
                        switch(pipe.symbol) {
                            case 'â”': type = 'straight-h'; break;
                            case 'â”ƒ': type = 'straight-v'; break;
                            case 'â•­': type = 'elbow'; rot = 0; break;      // top-right
                            case 'â•®': type = 'elbow'; rot = 90; break;     // top-left
                            case 'â•°': type = 'elbow'; rot = 270; break;    // bottom-right
                            case 'â•¯': type = 'elbow'; rot = 180; break;    // bottom-left
                            case 'â”£': type = 'tee'; rot = 180; break;
                            case 'â”«': type = 'tee'; rot = 0; break;
                            case 'â”»': type = 'tee'; rot = 90; break;
                            case 'â”³': type = 'tee'; rot = 270; break;
                            case 'â•‹': type = 'cross'; break;
                            default: type = 'straight-h';
                        }
                        renderPipeInto(pipeElement, type, rot);
                    }
                    

                    
                    pipeElement.addEventListener('dragstart', (e) => this.handleDragStart(e, pipe));
                    pipeElement.addEventListener('dragend', () => this.handleDragEnd());
                    
                    inventory.appendChild(pipeElement);
                });
            }
            

            
            setupEventListeners() {
                const playArea = document.getElementById('playArea');
                
                // Desktop drag and drop
                playArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                
                playArea.addEventListener('drop', (e) => this.handleDrop(e));
                
                // Mobile touch support
                let touchStartX, touchStartY;
                let currentPipe = null;
                
                playArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                    
                    // Check if touching a pipe piece in inventory
                    const element = document.elementFromPoint(touchStartX, touchStartY);
                    if (element && element.classList.contains('pipe-piece')) {
                        currentPipe = JSON.parse(element.dataset.pipeType);
                        element.style.opacity = '0.7';
                    }
                });
                
                playArea.addEventListener('touchend', (e) => {
                    if (currentPipe) {
                        const touch = e.changedTouches[0];
                        const rect = playArea.getBoundingClientRect();
                        const rawX = touch.clientX - rect.left;
                        const rawY = touch.clientY - rect.top;
                        
                        // Snap to grid
                        const gridSize = 80;
                        const x = Math.floor(rawX / gridSize) * gridSize;
                        const y = Math.floor(rawY / gridSize) * gridSize;
                        
                        // Ensure pipe stays within bounds
                        const maxX = rect.width - gridSize;
                        const maxY = rect.height - gridSize;
                        const clampedX = Math.max(0, Math.min(x, maxX));
                        const clampedY = Math.max(0, Math.min(y, maxY));
                        
                        if (clampedX >= 0 && clampedY >= 0 && clampedX <= maxX && clampedY <= maxY) {
                            this.placePipe(currentPipe, clampedX, clampedY);
                        }
                        
                        // Reset inventory pipe opacity
                        document.querySelectorAll('.pipe-piece').forEach(p => p.style.opacity = '1');
                        currentPipe = null;
                    }
                });
                
                document.getElementById('newLevelBtn').addEventListener('click', () => this.nextLevel());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetLevel());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoLastPipe());
                document.getElementById('flowTestBtn').addEventListener('click', () => this.testFlow());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
            }
            
            handleDragStart(e, pipe) {
                this.draggedPipe = pipe;
                e.target.classList.add('dragging');
                e.dataTransfer.setData('text/plain', JSON.stringify(pipe));
                
                // Show grid highlights
                this.showGridHighlights();
            }
            
            handleDragEnd() {
                document.querySelectorAll('.pipe-piece').forEach(p => p.classList.remove('dragging'));
                this.draggedPipe = null;
                
                // Clear grid highlights
                this.clearGridHighlights();
            }
            
            handlePlacedPipeDragStart(e, pipeElement) {
                this.draggedPlacedPipe = pipeElement;
                pipeElement.classList.add('dragging');
                e.dataTransfer.setData('text/plain', 'placed-pipe');
                
                // Show grid highlights
                this.showGridHighlights();
            }
            
            handlePlacedPipeDragEnd() {
                if (this.draggedPlacedPipe) {
                    this.draggedPlacedPipe.classList.remove('dragging');
                    this.draggedPlacedPipe = null;
                }
                
                // Clear grid highlights
                this.clearGridHighlights();
            }
            
            rotatePipe(pipeElement) {
                const pipeData = JSON.parse(pipeElement.dataset.pipeData);
                
                // Only rotate connector pipes (not numbers or operators)
                if (pipeData.type === 'connector') {
                    // Get current rotation
                    let currentRotation = parseInt(pipeElement.dataset.rotation || '0');
                    currentRotation = (currentRotation + 90) % 360;
                    
                    // Update rotation data
                    pipeElement.dataset.rotation = currentRotation;
                    
                    // Re-render the pipe with new rotation
                    let type = 'straight-h';
                    switch(pipeData.symbol) {
                        case 'â”': type = 'straight-h'; break;
                        case 'â”ƒ': type = 'straight-v'; break;
                        case 'â•­': type = 'elbow'; break;
                        case 'â•®': type = 'elbow'; break;
                        case 'â•°': type = 'elbow'; break;
                        case 'â•¯': type = 'elbow'; break;
                        case 'â”£': type = 'tee'; break;
                        case 'â”«': type = 'tee'; break;
                        case 'â”»': type = 'tee'; break;
                        case 'â”³': type = 'tee'; break;
                        case 'â•‹': type = 'cross'; break;
                    }
                    
                    renderPipeInto(pipeElement, type, currentRotation);
                    
                    // Recheck connections after rotation
                    setTimeout(() => this.checkConnections(), 100);
                }
            }
            
            repositionPlacedPipe(pipeElement, newX, newY) {
                // Update the pipe's position
                pipeElement.style.left = newX + 'px';
                pipeElement.style.top = newY + 'px';
                pipeElement.dataset.x = newX;
                pipeElement.dataset.y = newY;
                
                // Update the pipe info in our arrays
                const timestamp = pipeElement.dataset.timestamp;
                const pipeInfo = this.pipes.find(p => p.timestamp === parseInt(timestamp));
                if (pipeInfo) {
                    pipeInfo.x = newX;
                    pipeInfo.y = newY;
                }
                
                // Recheck connections after repositioning
                setTimeout(() => this.checkConnections(), 100);
            }
            
            handleDrop(e) {
                e.preventDefault();
                
                const rect = e.currentTarget.getBoundingClientRect();
                const rawX = e.clientX - rect.left;
                const rawY = e.clientY - rect.top;
                
                // Snap to grid
                const gridSize = 80;
                const x = Math.floor(rawX / gridSize) * gridSize;
                const y = Math.floor(rawY / gridSize) * gridSize;
                
                // Ensure pipe stays within bounds
                const maxX = rect.width - gridSize;
                const maxY = rect.height - gridSize;
                const clampedX = Math.max(0, Math.min(x, maxX));
                const clampedY = Math.max(0, Math.min(y, maxY));
                
                if (this.draggedPipe) {
                    // Placing a new pipe from inventory
                    this.placePipe(this.draggedPipe, clampedX, clampedY);
                } else if (this.draggedPlacedPipe) {
                    // Repositioning an existing placed pipe
                    this.repositionPlacedPipe(this.draggedPlacedPipe, clampedX, clampedY);
                }
            }
            
            placePipe(pipeData, x, y) {
                const playArea = document.getElementById('playArea');
                const pipeElement = document.createElement('div');
                
                pipeElement.className = 'placed-pipe';
                pipeElement.style.left = x + 'px';
                pipeElement.style.top = y + 'px'; // Center vertically in the 80px grid cell
                pipeElement.dataset.pipeData = JSON.stringify(pipeData);
                pipeElement.dataset.x = x;
                pipeElement.dataset.y = y;
                
                // Make placed pipes draggable for repositioning
                pipeElement.draggable = true;
                pipeElement.addEventListener('dragstart', (e) => this.handlePlacedPipeDragStart(e, pipeElement));
                pipeElement.addEventListener('dragend', () => this.handlePlacedPipeDragEnd());
                
                // Add double-click to rotate pipes
                pipeElement.addEventListener('dblclick', () => this.rotatePipe(pipeElement));
                
                // Decide what kind of pipe it is and render SVG
                let type = 'straight-h'; let rot = 0;
                
                if (pipeData.type === 'number') {
                    // Number pipes get a special number display
                    pipeElement.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #4CAF50, #66BB6A);
                            border: 3px solid #2E7D32;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.5rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.symbol}
                        </div>
                    `;
                } else if (pipeData.type === 'operator') {
                    // Operator pipes get a special operator display
                    pipeElement.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #FF9800, #FFB74D);
                            border: 3px solid #F57C00;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.8rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.operation}
                        </div>
                    `;
                } else {
                    // Connector pipes use SVG rendering
                    switch(pipeData.symbol) {
                        case 'â”': type = 'straight-h'; break;
                        case 'â”ƒ': type = 'straight-v'; break;
                        case 'â•­': type = 'elbow'; rot = 0; break;      // top-right
                        case 'â•®': type = 'elbow'; rot = 90; break;     // top-left
                        case 'â•°': type = 'elbow'; rot = 270; break;    // bottom-right
                        case 'â•¯': type = 'elbow'; rot = 180; break;    // bottom-left
                        case 'â”£': type = 'tee'; rot = 180; break;
                        case 'â”«': type = 'tee'; rot = 0; break;
                        case 'â”»': type = 'tee'; rot = 90; break;
                        case 'â”³': type = 'tee'; rot = 270; break;
                        case 'â•‹': type = 'cross'; break;
                        default: type = 'straight-h';
                    }
                    renderPipeInto(pipeElement, type, rot);
                    
                    // Add rotatable class for connector pipes
                    pipeElement.classList.add('rotatable');
                }
                

                
                // Remove click event - pipes will connect automatically when placed correctly
                
                playArea.appendChild(pipeElement);
                
                const pipeInfo = {
                    element: pipeElement,
                    data: pipeData,
                    x: x,
                    y: y,
                    connected: false,
                    timestamp: Date.now()
                };
                
                this.pipes.push(pipeInfo);
                
                // Store in history for undo
                if (!this.pipeHistory) this.pipeHistory = [];
                this.pipeHistory.push(pipeInfo);
                
                this.checkConnections();
            }
            
            checkConnections() {
                // Clear all previous connections and connecting states
                this.pipes.forEach(pipe => {
                    pipe.connected = false;
                    pipe.element.classList.remove('connected');
                    pipe.element.classList.remove('flowing');
                    
                    // Clear any water flow styling
                    if (pipe.data.type === 'number') {
                        pipe.element.querySelector('div').style.background = 'linear-gradient(135deg, #4CAF50, #66BB6A)';
                        pipe.element.querySelector('div').style.borderColor = '#2E7D32';
                        pipe.element.querySelector('div').style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.4)';
                    } else if (pipe.data.type === 'operator') {
                        pipe.element.querySelector('div').style.background = 'linear-gradient(135deg, #FF9800, #FFB74D)';
                        pipe.element.querySelector('div').style.borderColor = '#F57C00';
                        pipe.element.querySelector('div').style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.4)';
                    }
                });
                this.connectedPipes = [];
                
                // Clear previous connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                // Create a grid-based connection system for more logical gameplay
                const gridSize = 80; // Match pipe width
                const tolerance = 20; // Allow some positioning flexibility
                
                // Group pipes by grid position
                const gridPipes = {};
                this.pipes.forEach(pipe => {
                    const gridX = Math.floor(pipe.x / gridSize);
                    const gridY = Math.floor(pipe.y / gridSize);
                    const key = `${gridX},${gridY}`;
                    
                    if (!gridPipes[key]) gridPipes[key] = [];
                    gridPipes[key].push(pipe);
                });
                
                // Check for logical connections based on grid adjacency
                Object.keys(gridPipes).forEach(key => {
                    const [gridX, gridY] = key.split(',').map(Number);
                    const currentPipes = gridPipes[key];
                    
                    // Check adjacent grid cells
                    const adjacentKeys = [
                        `${gridX-1},${gridY}`, // left
                        `${gridX+1},${gridY}`, // right
                        `${gridX},${gridY-1}`, // top
                        `${gridX},${gridY+1}`  // bottom
                    ];
                    
                    adjacentKeys.forEach(adjKey => {
                        if (gridPipes[adjKey]) {
                            const adjacentPipes = gridPipes[adjKey];
                            
                            // Try to connect pipes between adjacent cells
                            currentPipes.forEach(pipe => {
                                adjacentPipes.forEach(adjPipe => {
                                    if (!pipe.connected && !adjPipe.connected) {
                                        // Check if these pipes can logically connect
                                        if (this.canPipesConnect(pipe, adjPipe)) {
                                            this.connectPipes(pipe, adjPipe);
                                        }
                                    }
                                });
                            });
                        }
                    });
                });
                
                // Apply water flow effect if pipes are connected
                if (this.connectedPipes.length > 0) {
                    setTimeout(() => this.applyWaterFlowEffect(), 100);
                }
                
                // Create continuous flow path across all connected pipes
                this.createContinuousFlowPath();
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            canPipesConnect(pipe1, pipe2) {
                // Only number pipes can connect to other number pipes
                // Connector pipes can connect to any pipe
                if (pipe1.data.value > 0 && pipe2.data.value > 0) {
                    // Two number pipes - check if they can form a valid math expression
                    return this.isValidMathConnection(pipe1, pipe2);
                } else if (pipe1.data.value === 0 || pipe2.data.value === 0) {
                    // At least one connector pipe - always allow connection
                    return true;
                }
                return false;
            }
            
            isValidMathConnection(pipe1, pipe2) {
                // Check if connecting these two number pipes would help solve the problem
                const total = pipe1.data.value + pipe2.data.value;
                
                if (this.currentProblem.operator === '+') {
                    return total === this.currentProblem.answer;
                } else if (this.currentProblem.operator === 'Ã—') {
                    return total === this.currentProblem.answer;
                } else if (this.currentProblem.operator === '-') {
                    // For subtraction, we need the larger number minus smaller
                    const larger = Math.max(pipe1.data.value, pipe2.data.value);
                    const smaller = Math.min(pipe1.data.value, pipe2.data.value);
                    return (larger - smaller) === this.currentProblem.answer;
                }
                return false;
            }
            
            connectPipes(pipe1, pipe2) {
                pipe1.connected = true;
                pipe2.connected = true;
                pipe1.element.classList.add('connected');
                pipe2.element.classList.add('connected');
                
                // Add satisfying "click" effect
                this.createConnectionEffect(pipe1, pipe2);
                
                // Create visual connection line between pipes
                this.createConnectionLine(pipe1, pipe2);
                
                this.connectedPipes.push(pipe1, pipe2);
                this.animateWaterFlow(pipe1, pipe2);
            }
            
            createConnectionEffect(pipe1, pipe2) {
                const playArea = document.getElementById('playArea');
                
                // Create connection spark effect
                const spark = document.createElement('div');
                spark.className = 'connection-spark';
                spark.style.left = ((pipe1.x + pipe2.x) / 2 + 40) + 'px';
                spark.style.top = ((pipe1.y + pipe2.y) / 2 + 40) + 'px';
                playArea.appendChild(spark);
                
                // Remove spark after animation
                setTimeout(() => {
                    if (spark.parentNode) {
                        spark.parentNode.removeChild(spark);
                    }
                }, 600);
            }
            
            createConnectionLine(pipe1, pipe2) {
                const playArea = document.getElementById('playArea');
                
                // Calculate connection line position - pipes are now centered vertically
                const x1 = pipe1.x + 40; // center of pipe1
                const y1 = pipe1.y + 40; // center of pipe1 (grid position + 40px centering)
                const x2 = pipe2.x + 40; // center of pipe2
                const y2 = pipe2.y + 40; // center of pipe2 (grid position + 40px centering)
                
                const connectionLine = document.createElement('div');
                connectionLine.className = 'connection-line';
                connectionLine.style.position = 'absolute';
                connectionLine.style.left = Math.min(x1, x2) + 'px';
                connectionLine.style.top = Math.min(y1, y2) + 'px';
                connectionLine.style.width = Math.abs(x2 - x1) + 'px';
                connectionLine.style.height = Math.abs(y2 - y1) + 'px';
                connectionLine.style.zIndex = '1';
                
                // Determine if it's horizontal or vertical connection
                if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
                    // Horizontal connection
                    connectionLine.style.height = '8px';
                    connectionLine.style.top = (Math.min(y1, y2) - 4) + 'px'; // Center the line on the pipe
                } else {
                    // Vertical connection
                    connectionLine.style.width = '8px';
                    connectionLine.style.left = (Math.min(x1, x2) - 4) + 'px'; // Center the line on the pipe
                }
                
                playArea.appendChild(connectionLine);
                
                // Store reference for later removal
                if (!this.connectionLines) this.connectionLines = [];
                this.connectionLines.push(connectionLine);
            }
            
            createContinuousFlowPath() {
                if (this.connectedPipes.length === 0) return;
                
                // Find all connected pipes and create a continuous flow
                const flowPath = this.findCompleteFlowPath();
                if (!flowPath || flowPath.length === 0) return;
                
                // Apply water flow effect to all pipes in the path
                flowPath.forEach((pipe, index) => {
                    const progress = index / (flowPath.length - 1);
                    const blueIntensity = Math.floor(progress * 255);
                    const color = `rgb(0, ${blueIntensity}, 255)`;
                    
                    if (pipe.data.type === 'number') {
                        pipe.element.querySelector('div').style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                        pipe.element.querySelector('div').style.borderColor = color;
                        pipe.element.querySelector('div').style.boxShadow = `0 0 20px ${color}`;
                    } else if (pipe.data.type === 'operator') {
                        pipe.element.querySelector('div').style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                        pipe.element.querySelector('div').style.borderColor = color;
                        pipe.element.querySelector('div').style.boxShadow = `0 0 20px ${color}`;
                    } else {
                        // For connector pipes, add a glow effect
                        pipe.element.style.filter = `drop-shadow(0 0 10px ${color})`;
                    }
                    
                    pipe.element.classList.add('flowing');
                });
            }
            
            findCompleteFlowPath() {
                // Find a continuous path through all connected pipes
                const visited = new Set();
                const path = [];
                
                // Start with any connected pipe
                const startPipe = this.connectedPipes[0];
                if (!startPipe) return [];
                
                const dfs = (pipe) => {
                    if (visited.has(pipe.timestamp)) return;
                    visited.add(pipe.timestamp);
                    path.push(pipe);
                    
                    // Find adjacent connected pipes
                    const adjacentPipes = this.findAdjacentConnectedPipes(pipe);
                    adjacentPipes.forEach(adjPipe => {
                        if (!visited.has(adjPipe.timestamp)) {
                            dfs(adjPipe);
                        }
                    });
                };
                
                dfs(startPipe);
                return path;
            }
            
            findAdjacentConnectedPipes(pipe) {
                const adjacentPipes = [];
                const gridSize = 80;
                const pipeGridX = Math.floor(pipe.x / gridSize);
                const pipeGridY = Math.floor(pipe.y / gridSize);
                
                // Check all other connected pipes for adjacency
                this.connectedPipes.forEach(otherPipe => {
                    if (otherPipe.timestamp === pipe.timestamp) return;
                    
                    const otherGridX = Math.floor(otherPipe.x / gridSize);
                    const otherGridY = Math.floor(otherPipe.y / gridSize);
                    
                    // Check if pipes are adjacent (including diagonals for better flow)
                    const distance = Math.abs(otherGridX - pipeGridX) + Math.abs(otherGridY - pipeGridY);
                    if (distance === 1) {
                        adjacentPipes.push(otherPipe);
                    }
                });
                
                return adjacentPipes;
            }
            
            // Method to apply gradual blue water flow effect
            applyWaterFlowEffect() {
                if (this.connectedPipes.length === 0) return;
                
                // Find the path from start to end
                const path = this.findFlowPath();
                if (!path) return;
                
                // Apply gradual blue effect along the path
                path.forEach((pipe, index) => {
                    const progress = index / (path.length - 1);
                    const blueIntensity = Math.floor(progress * 255);
                    const color = `rgb(0, ${blueIntensity}, 255)`;
                    
                    // Add water flow class with custom color
                    pipe.element.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                    pipe.element.style.borderColor = color;
                    pipe.element.style.boxShadow = `0 0 20px ${color}`;
                    
                    // Add flowing water animation
                    pipe.element.classList.add('flowing');
                });
            }
            
            animateWaterFlow(pipe1, pipe2) {
                // Create water flow animation between connected pipes
                const playArea = document.getElementById('playArea');
                
                // Create multiple water droplets for better effect
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const flow = document.createElement('div');
                        flow.className = 'water-flow';
                        flow.style.left = (pipe1.x + 40 + (Math.random() - 0.5) * 20) + 'px';
                        flow.style.top = (pipe1.y + 40 + (Math.random() - 0.5) * 20) + 'px';
                        
                        playArea.appendChild(flow);
                        
                        // Animate water flow towards pipe2
                        const startX = parseFloat(flow.style.left);
                        const startY = parseFloat(flow.style.top);
                        const endX = pipe2.x + 40;
                        const endY = pipe2.y + 40;
                        
                        let progress = 0;
                        const animate = () => {
                            progress += 0.02;
                            if (progress <= 1) {
                                flow.style.left = (startX + (endX - startX) * progress) + 'px';
                                flow.style.top = (startY + (endY - startY) * progress) + 'px';
                                requestAnimationFrame(animate);
                            } else {
                                flow.remove();
                            }
                        };
                        animate();
                    }, i * 200);
                }
                
                // Check win condition after animation
                setTimeout(() => {
                    this.checkWinCondition();
                }, 1500);
            }
            
            checkWinCondition() {
                // This method is no longer used in the new flow-based system
                // Win condition is now checked during flow testing
                return;
            }
            
            celebrateWin() {
                this.score += 100 * this.level;
                this.updateDisplay();
                
                // Create splash effect
                const playArea = document.getElementById('playArea');
                const splash = document.createElement('div');
                splash.className = 'splash';
                splash.style.left = '50%';
                splash.style.top = '50%';
                splash.style.transform = 'translate(-50%, -50%)';
                
                playArea.appendChild(splash);
                
                // Show success message
                const success = document.createElement('div');
                success.className = 'success-message';
                success.textContent = 'ðŸŽ‰ Water flowing! ðŸŽ‰';
                success.style.position = 'absolute';
                success.style.top = '20%';
                success.style.left = '50%';
                success.style.transform = 'translateX(-50%)';
                success.style.zIndex = '1000';
                
                playArea.appendChild(success);
                
                setTimeout(() => {
                    splash.remove();
                    success.remove();
                    this.nextLevel();
                }, 2000);
            }
            
            nextLevel() {
                this.level++;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                // Clear connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            generateNewProblem() {
                const operators = ['+', '-', 'Ã—'];
                const operator = operators[Math.floor(Math.random() * operators.length)];
                let num1, num2, answer;
                
                switch (operator) {
                    case '+':
                        num1 = Math.floor(Math.random() * 10) + 1;
                        num2 = Math.floor(Math.random() * 10) + 1;
                        answer = num1 + num2;
                        break;
                    case '-':
                        num1 = Math.floor(Math.random() * 15) + 5;
                        num2 = Math.floor(Math.random() * num1) + 1;
                        answer = num1 - num2;
                        break;
                    case 'Ã—':
                        num1 = Math.floor(Math.random() * 6) + 2;
                        num2 = Math.floor(Math.random() * 6) + 2;
                        answer = num1 * num2;
                        break;
                }
                
                this.currentProblem = { num1, num2, operator, answer };
                document.getElementById('mathProblem').textContent = 
                    `${num1} ${operator} ${num2} = ?`;
            }
            
            clearPlayArea() {
                document.getElementById('playArea').innerHTML = '';
            }
            
            resetLevel() {
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                // Clear connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            undoLastPipe() {
                if (!this.pipeHistory || this.pipeHistory.length === 0) {
                    alert('No pipes to undo!');
                    return;
                }
                
                const lastPipe = this.pipeHistory.pop();
                
                // Remove from pipes array
                const index = this.pipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (index > -1) {
                    this.pipes.splice(index, 1);
                }
                
                // Remove from connected pipes if it was connected
                const connectedIndex = this.connectedPipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (connectedIndex > -1) {
                    this.connectedPipes.splice(connectedIndex, 1);
                }
                
                // Remove the DOM element
                if (lastPipe.element && lastPipe.element.parentNode) {
                    lastPipe.element.parentNode.removeChild(lastPipe.element);
                }
                
                // Recheck connections since we removed a pipe
                this.checkConnections();
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (this.pipeHistory && this.pipeHistory.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                }
            }
            
            showGridHighlights() {
                const playArea = document.getElementById('playArea');
                const rect = playArea.getBoundingClientRect();
                const gridSize = 80;
                
                // Clear existing highlights
                this.clearGridHighlights();
                
                // Create grid highlights
                for (let x = 0; x < rect.width; x += gridSize) {
                    for (let y = 0; y < rect.height; y += gridSize) {
                        const highlight = document.createElement('div');
                        highlight.className = 'grid-highlight';
                        highlight.style.left = x + 'px';
                        highlight.style.top = y + 'px';
                        playArea.appendChild(highlight);
                    }
                }
            }
            
            clearGridHighlights() {
                const highlights = document.querySelectorAll('.grid-highlight');
                highlights.forEach(h => h.remove());
            }
            
            showHint() {
                // More helpful hint system for the new expression system
                let hint = '';
                if (this.currentExpression.type === 'simple') {
                    hint = `You need to route from the start pipe (${this.currentExpression.a}) through the ${this.currentExpression.op} operator and the number ${this.currentExpression.b}. The answer should be ${this.correctAnswer}.`;
                } else if (this.currentExpression.type === 'leftGrouped') {
                    hint = `First calculate (${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}), then apply ${this.currentExpression.op2} ${this.currentExpression.c}. Remember: ${this.currentExpression.op1} happens first!`;
                } else if (this.currentExpression.type === 'rightGrouped') {
                    hint = `First calculate (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}), then apply ${this.currentExpression.a} ${this.currentExpression.op1}. Remember: ${this.currentExpression.op2} happens first!`;
                } else if (this.currentExpression.type === 'precedence') {
                    hint = `Remember order of operations: Ã— and Ã· happen before + and âˆ’. So calculate ${this.currentExpression.b} Ã— ${this.currentExpression.c} first, then add ${this.currentExpression.a}, then subtract ${this.currentExpression.d}.`;
                }
                alert(hint);
            }
            
            startPressureTimer() {
                if (this.timer) clearInterval(this.timer);
                
                const config = this.getGameConfig();
                this.timer = setInterval(() => {
                    this.pressure += config.pressureRate;
                    this.updateDisplay();
                    
                    if (this.pressure >= this.maxPressure) {
                        this.gameOver();
                    }
                }, 1000);
            }
            
            testFlow() {
                if (this.pipes.length === 0) {
                    alert('Place some pipes first!');
                    return;
                }
                
                // Simulate water flow through the pipe network
                this.animateFlow();
            }
            
            animateFlow() {
                const playArea = document.getElementById('playArea');
                
                // Find the path from start to answer pipes
                const path = this.findFlowPath();
                
                if (!path) {
                    this.showFlowError('No valid path found!');
                    return;
                }
                
                // Animate water flow step by step
                let currentValue = this.startPipe.value;
                let step = 0;
                
                const animateStep = () => {
                    if (step >= path.length) {
                        this.checkFlowResult(currentValue);
                        return;
                    }
                    
                    const pipe = path[step];
                    const flowElement = this.createFlowElement(pipe.x, pipe.y);
                    playArea.appendChild(flowElement);
                    
                    // Apply operation if it's an operator
                    if (pipe.data && pipe.data.type === 'operator') {
                        const nextPipe = path[step + 1];
                        if (nextPipe && nextPipe.data && nextPipe.data.type === 'number') {
                            currentValue = this.applyOperation(currentValue, nextPipe.data.value, pipe.data.operation);
                            step++; // Skip the number pipe since we processed it
                        }
                    }
                    
                    step++;
                    
                    setTimeout(() => {
                        flowElement.remove();
                        animateStep();
                    }, 500);
                };
                
                animateStep();
            }
            
            findFlowPath() {
                // Simple pathfinding from start to answer pipes
                // This is a simplified version - in a full implementation you'd want proper pathfinding
                const path = [];
                const visited = new Set();
                
                const dfs = (x, y, targetX, targetY) => {
                    if (x === targetX && y === targetY) return true;
                    if (x < 0 || y < 0 || x >= this.gridSize || y >= this.gridSize) return false;
                    
                    const key = `${x},${y}`;
                    if (visited.has(key)) return false;
                    visited.add(key);
                    
                    // Check if there's a pipe here
                    const pipe = this.pipes.find(p => Math.floor(p.x / 80) === x && Math.floor(p.y / 80) === y);
                    if (pipe) {
                        path.push(pipe);
                        
                        // Try adjacent cells
                        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of directions) {
                            if (dfs(x + dx, y + dy, targetX, targetY)) return true;
                        }
                        
                        path.pop();
                    }
                    
                    return false;
                };
                
                // Try to find path to correct answer
                const correctAnswer = this.answerPipes.find(p => p.isCorrect);
                if (correctAnswer && dfs(1, Math.floor(this.gridSize / 2), correctAnswer.x, correctAnswer.y)) {
                    return path;
                }
                
                return null;
            }
            
            createFlowElement(x, y) {
                const flow = document.createElement('div');
                flow.className = 'water-flow';
                flow.style.left = (x + 40) + 'px';
                flow.style.top = (y + 40) + 'px'; // Account for vertical centering
                return flow;
            }
            
            checkFlowResult(finalValue) {
                const correctAnswer = this.answerPipes.find(p => p.isCorrect);
                
                if (finalValue === correctAnswer.value) {
                    this.celebrateWin();
                } else {
                    this.showFlowError(`Flow reached value ${finalValue}, but correct answer is ${correctAnswer.value}`);
                }
            }
            
            showFlowError(message) {
                this.pressure += 20; // Increase pressure for failed attempt
                alert(message);
                this.updateDisplay();
            }
            
            gameOver() {
                clearInterval(this.timer);
                this.gameActive = false;
                
                const gameOver = document.createElement('div');
                gameOver.className = 'game-over';
                gameOver.innerHTML = `
                    <h2>Pressure Too High!</h2>
                    <p>Final Score: ${this.score}</p>
                    <p>Level Reached: ${this.level}</p>
                    <p>Stars Earned: ${this.stars}</p>
                    <button class="control-btn" onclick="location.reload()">Play Again</button>
                `;
                
                document.getElementById('playArea').appendChild(gameOver);
            }
            
            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('stars').textContent = this.stars;
                document.getElementById('pressure').textContent = Math.round(this.pressure);
                
                // Update sidebar display elements
                const levelDisplay = document.getElementById('levelDisplay');
                const scoreDisplay = document.getElementById('scoreDisplay');
                const pressureDisplay = document.getElementById('pressureDisplay');
                
                if (levelDisplay) levelDisplay.textContent = this.level;
                if (scoreDisplay) scoreDisplay.textContent = this.score;
                if (pressureDisplay) pressureDisplay.textContent = Math.round(this.pressure) + '%';
                
                // Update pressure bar
                const pressureFill = document.getElementById('pressureFill');
                if (pressureFill) {
                    pressureFill.style.width = (this.pressure / this.maxPressure * 100) + '%';
                }
                
                // Update expression display
                if (this.currentExpression) {
                    let expressionText = '';
                    if (this.currentExpression.type === 'simple') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op} ${this.currentExpression.b} = ?`;
                    } else if (this.currentExpression.type === 'leftGrouped') {
                        expressionText = `(${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}) ${this.currentExpression.op2} ${this.currentExpression.c} = ?`;
                    } else if (this.currentExpression.type === 'rightGrouped') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op1} (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}) = ?`;
                    } else if (this.currentExpression.type === 'precedence') {
                        expressionText = `${this.currentExpression.a} + ${this.currentExpression.b} Ã— ${this.currentExpression.c} - ${this.currentExpression.d} = ?`;
                    }
                    document.getElementById('mathProblem').textContent = expressionText;
                }
            }
        }
        
        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PipeDream();
        });
    </script>

    <script>
        function svgForPipe(type = 'straight-h', rot = 0, active = false) {
            const strokeClass = 'pipe-stroke' + (active ? ' glow' : '');
            const paths = {
                'straight-h': `<path class="${strokeClass}" d="M12 50 H88"/>`,
                'straight-v': `<path class="${strokeClass}" d="M50 12 V88"/>`,
                'elbow': `<path class="${strokeClass}" d="M12 50 H50 V12"/>`,
                'tee': `
                    <path class="${strokeClass}" d="M12 50 H88"/>
                    <path class="${strokeClass}" d="M50 50 V12"/>`,
                'cross': `
                    <path class="${strokeClass}" d="M12 50 H88"/>
                    <path class="${strokeClass}" d="M50 12 V88"/>`
            };
            const inner = {
                'straight-h': `<path class="pipe-inner" d="M12 50 H88"/>`,
                'straight-v': `<path class="pipe-inner" d="M50 12 V88"/>`,
                'elbow': `<path class="pipe-inner" d="M12 50 H50 V12"/>`,
                'tee': `
                    <path class="pipe-inner" d="M12 50 H88"/>
                    <path class="pipe-inner" d="M50 50 V12"/>`,
                'cross': `
                    <path class="pipe-inner" d="M12 50 H88"/>
                    <path class="pipe-inner" d="M50 12 V88"/>`
            };
            const endcaps = {
                'straight-h': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/>`,
                'straight-v': `<circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`,
                'elbow': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
                'tee': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
                'cross': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`
            };
            return `
        <svg viewBox="0 0 100 100">
            <g transform="rotate(${rot} 50 50)">
                ${paths[type] || paths['straight-h']}
                ${inner[type] || ''}
                ${endcaps[type] || ''}
            </g>
        </svg>`;
        }
        function renderPipeInto(el, type, rot = 0, active = false) {
            el.innerHTML = svgForPipe(type, rot, active);
        }
    </script>

    <script src="navigation.js"></script>
</body>
</html>
