<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pipe Dream - Retro Games Collection</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        :root{
            --wall:#0bb;
            --bg:#000;
            --score:#0f0;
            --title:#ffd700;
            --focus-outline: #0ff;
        }

        .app{ 
            min-height: 100vh;
            display:flex;
            flex-direction: column;
            gap:15px;
            align-items:center;
            justify-content:flex-start;
            padding:15px;
            width: 100%;
            max-width: 1200px;
        }

        #gameNav {
            width: 100%;
            max-width: 220px;
            margin-bottom: 20px;
        }

        .game-wrap {
            position: relative;
        }

        .game-container {
            background: #1a1a2e;
            border: 3px solid #0f0;
            border-radius: 15px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            text-align: center;
        }

        #gameNav, 
        #gameNav a {
        display: block;
        margin-top: 5px;
        text-transform: uppercase;
        color: var(--score);
        text-decoration: none;
        padding: 8px;
        border-radius: 4px;
        transition: background-color 0.2s;
        }

        #gameNav a:hover,
        #gameNav a:focus {
        background-color: rgba(0, 255, 0, 0.1);
        }

        #gameNav a.active {
        color: #ff0;
        font-weight: bold;
        text-decoration: underline;
        background-color: rgba(255, 255, 0, 0.1);
        }

        #sidebar{
            width: 100%;
            max-width: 220px;
            color:var(--score);
            display:flex;
            flex-direction:column;
            gap:14px
        }

        #title { 
            text-transform: uppercase; 
            font-size: clamp(1.5rem, 4vw, 2rem);
            color: var(--title); 
            text-shadow: 0 0 8px #f00; 
            text-align: center;
            margin: 0;
        }

        .section-title{
            color:var(--title);
            font-weight:700;
            margin-bottom:8px
        }

        #scoreboard{
            border:2px solid var(--score);
            padding:12px;
            display:grid;
            grid-template-columns:1fr 1fr;
            gap:8px;
            align-items:center;
            border-radius: 6px;
        }

        #scoreboard .section-title{
            text-align:left;
            margin:0
        }

        #scoreboard div.value{
            text-align:right
        }

        #instructions{
            font-size:13px;
            line-height:1.4
        }

        .game-header {
            margin-bottom: 20px;
        }

        .level-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 10px;
            border: 2px solid #0f0;
        }

        .math-problem {
            font-size: 2rem;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin: 20px 0;
        }

        .pipe-inventory {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
            gap: 8px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(0, 255, 0, 0.05);
            border-radius: 10px;
            border: 1px solid #0f0;
        }

        .pipe-piece {
            width: 50px;
            height: 50px;
            display: grid;
            place-items: center;
            background: transparent;
            border: none;
            box-shadow: none;
            user-select: none;
            cursor: grab;
            transition: all 0.3s ease;
            touch-action: manipulation;
            position: relative;
            transform-style: preserve-3d;
        }







        .pipe-piece:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px #0f0;
        }

        .pipe-piece svg, .placed-pipe svg {
            width: 86%;
            height: 86%;
            overflow: visible;
        }

        .pipe-stroke {
            stroke: #a8c7d8;
            stroke-width: 16;
            stroke-linecap: round;
            stroke-linejoin: round;
            filter: drop-shadow(0 1px 0 rgba(0,0,0,.35));
        }
        .pipe-stroke.glow { stroke: #6ddcff; }
        .pipe-inner { stroke: rgba(255,255,255,.22); stroke-width: 6; }
        .pipe-endcap { fill: #86a7b8; opacity: .7; }

        /* Pipe type indicators */
        .pipe-piece .number-pipe {
            background: linear-gradient(135deg, #4CAF50, #66BB6A) !important;
            border-color: #2E7D32 !important;
        }

        .pipe-piece .operator-pipe {
            background: linear-gradient(135deg, #FF9800, #FFB74D) !important;
            border-color: #F57C00 !important;
        }

        .pipe-piece .connector-pipe {
            background: transparent !important;
            border: none !important;
        }

        .pipe-piece.dragging, .placed-pipe.dragging {
            opacity: 0.7;
            transform: rotate(5deg);
            z-index: 1000;
        }
        
        .placed-pipe {
            cursor: grab;
        }
        
        .placed-pipe:active {
            cursor: grabbing;
        }
        
        .placed-pipe.rotatable {
            cursor: pointer;
        }
        
        .placed-pipe.rotatable:hover::after {
            content: '🔄 Double-click to rotate';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 1001;
        }

        .play-area {
            width: 100%;
            min-height: 320px;
            background: #16213e;
            border: 3px solid #0f0;
            border-radius: 15px;
            position: relative;
            margin: 20px 0;
            overflow: hidden;
            background-image: 
                linear-gradient(rgba(0, 255, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 0, 0.1) 1px, transparent 1px);
            background-size: 60px 60px;
        }
        
        /* Mobile responsive play area */
        @media (max-width: 768px) {
            .play-area {
                min-height: 400px;
                margin: 10px 0;
            }
        }

        .placed-pipe {
            position: absolute;
            width: 60px;
            height: 60px;
            display: grid;
            place-items: center;
            background: transparent;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: all 0.3s ease;
            transform-style: preserve-3d;
        }



        .placed-pipe.connected {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border-color: #2E7D32;
            box-shadow: 
                0 0 20px #4CAF50,
                0 0 40px rgba(76, 175, 80, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            transform: scale(1.05);
            animation: pipeConnect 0.6s ease-out;
        }

        @keyframes pipeConnect {
            0% { 
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 0px #4CAF50;
            }
            25% { 
                transform: scale(1.1) rotate(2deg);
                box-shadow: 0 0 30px #4CAF50;
            }
            50% { 
                transform: scale(1.05) rotate(-1deg);
                box-shadow: 0 0 25px #4CAF50;
            }
            100% { 
                transform: scale(1.05) rotate(0deg);
                box-shadow: 0 0 20px #4CAF50;
            }
        }

        .placed-pipe.connecting {
            background: linear-gradient(135deg, #FFD700, #FFED4E);
            border-color: #FF8C00;
            box-shadow: 
                0 0 15px #FFD700,
                0 0 30px rgba(255, 215, 0, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.4),
                inset 0 -2px 4px rgba(0, 0, 0, 0.1);
            animation: connectingPulse 1.5s ease-in-out infinite;
        }

        @keyframes connectingPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 15px #FFD700, 0 0 30px rgba(255, 215, 0, 0.3);
            }
            50% { 
                transform: scale(1.02);
                box-shadow: 0 0 20px #FFD700, 0 0 40px rgba(255, 215, 0, 0.5);
            }
        }

        .grid-highlight {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px dashed #0f0;
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            z-index: 1;
            animation: gridPulse 2s infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }

        .placed-pipe.filled {
            background: linear-gradient(45deg, #0066cc, #0099ff);
            border-color: #0099ff;
            box-shadow: 0 0 20px #0099ff;
        }

        .start-pipe {
            position: absolute;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border: 3px solid #2E7D32;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 15px rgba(76, 175, 80, 0.5);
            animation: startPipeGlow 2s ease-in-out infinite;
        }



        @keyframes startPipeGlow {
            0%, 100% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 20px rgba(76, 175, 80, 0.5);
            }
            50% { 
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.2), 0 0 30px rgba(76, 175, 80, 0.8);
            }
        }

        .answer-pipe {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid #666;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
            z-index: 10;
            box-shadow: 
                0 3px 6px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2);
        }



        .answer-pipe.correct {
            background: linear-gradient(135deg, #F44336, #EF5350);
            border-color: #D32F2F;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(244, 67, 54, 0.5);
        }

        .answer-pipe.decoy {
            background: linear-gradient(135deg, #2196F3, #42A5F5);
            border-color: #1976D2;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(255, 255, 255, 0.3),
                inset 0 -2px 4px rgba(0, 0, 0, 0.2),
                0 0 20px rgba(33, 150, 243, 0.5);
        }

        .grid-cell {
            background: rgba(0, 255, 0, 0.05);
        }

        .connection-spark {
            position: absolute;
            width: 8px;
            height: 8px;
            background: radial-gradient(circle, #FFD700, #FFA500, transparent);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: sparkEffect 0.6s ease-out forwards;
        }

        @keyframes sparkEffect {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
                box-shadow: 0 0 0px #FFD700;
            }
            25% { 
                transform: scale(2) rotate(90deg);
                opacity: 1;
                box-shadow: 0 0 20px #FFD700;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
                box-shadow: 0 0 15px #FFD700;
            }
            100% { 
                transform: scale(0) rotate(360deg);
                opacity: 0;
                box-shadow: 0 0 0px #FFD700;
            }
        }

        .water-flow {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, #4FC3F7, #29B6F6, #0288D1);
            border-radius: 50%;
            pointer-events: none;
            animation: waterFlow 2s linear infinite;
            box-shadow: 0 0 8px #4FC3F7;
        }

        @keyframes waterFlow {
            0% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
            25% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            50% { 
                transform: scale(1); 
                opacity: 1; 
                box-shadow: 0 0 8px #4FC3F7;
            }
            75% { 
                transform: scale(0.8); 
                opacity: 0.7; 
                box-shadow: 0 0 6px #4FC3F7;
            }
            100% { 
                transform: scale(0.3); 
                opacity: 0; 
                box-shadow: 0 0 4px #4FC3F7;
            }
        }

        .splash {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, #0099ff, transparent);
            border-radius: 50%;
            pointer-events: none;
            animation: splash 1s ease-out forwards;
        }

        @keyframes splash {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .game-controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .control-row {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .control-row:first-child {
            justify-content: flex-start;
            margin-left: 20px;
        }
        
        .control-btn {
            padding: 12px 20px;
            background: linear-gradient(135deg, #2E7D32, #4CAF50);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #388E3C, #66BB6A);
        }
        
        .control-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .water-btn {
            background: linear-gradient(135deg, #1565C0, #42A5F5);
            border: 3px solid #0D47A1;
            box-shadow: 0 4px 15px rgba(21, 101, 192, 0.4);
            position: relative;
            overflow: hidden;
            animation: waterRipple 3s infinite;
        }
        
        .water-btn:hover {
            background: linear-gradient(135deg, #1976D2, #64B5F6);
            box-shadow: 0 6px 20px rgba(21, 101, 192, 0.6);
            transform: translateY(-3px) scale(1.05);
        }
        
        .water-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        .water-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            animation: waterShine 2s infinite;
        }
        
        .tap-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 18px;
            animation: tapBounce 2s infinite;
        }
        
        @keyframes waterRipple {
            0%, 100% { box-shadow: 0 4px 15px rgba(21, 101, 192, 0.4); }
            50% { box-shadow: 0 4px 25px rgba(21, 101, 192, 0.7), 0 0 30px rgba(21, 101, 192, 0.3); }
        }
        
        @keyframes waterShine {
            0% { transform: rotate(45deg) translateX(-100%); }
            100% { transform: rotate(45deg) translateX(100%); }
        }
        
        @keyframes tapBounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-5px); }
            60% { transform: translateY(-3px); }
        }
        
        @keyframes waterRippleExpand {
            0% { 
                transform: scale(0.8); 
                opacity: 1; 
                border-width: 2px;
            }
            100% { 
                transform: scale(2); 
                opacity: 0; 
                border-width: 1px;
            }
        }
        
        .water-ripple {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        .score-display {
            font-size: 1.2rem;
            color: #ffd700;
            margin: 15px 0;
        }

        .pressure-gauge {
            font-size: 1.2rem;
            color: #ff6b6b;
            font-weight: bold;
        }

        .pressure-bar {
            width: 100px;
            height: 20px;
            background: rgba(255, 107, 107, 0.3);
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .pressure-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #ffd700;
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            text-align: center;
            z-index: 1000;
        }

        .success-message {
            color: #0f0;
            font-size: 1.5rem;
            margin: 20px 0;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Responsive breakpoints */
        @media (min-width: 768px) {
            .app {
                flex-direction: row;
                align-items: flex-start;
                gap: 20px;
                padding: 18px;
            }
            
            #gameNav {
                width: 220px;
                flex-shrink: 0;
                order: 1;
            }
            
            .game-wrap {
                flex: 1;
                order: 2;
            }
            
            .game-container {
                max-width: 800px;
                margin: 0;
            }
            
            #sidebar {
                width: 220px;
                flex-shrink: 0;
                order: 3;
            }
        }

        /* Mobile responsiveness */
        @media (max-width: 767px) {
            .app {
                flex-direction: column;
                padding: 10px;
            }
            
            .game-container {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings {
                margin: 10px;
                padding: 15px;
            }
            
            .game-settings > div {
                grid-template-columns: 1fr !important;
            }
            
            .play-area {
                height: 240px;
                background-size: 60px 60px;
            }
            
            .pipe-inventory {
                grid-template-columns: repeat(5, 1fr);
                gap: 8px;
            }
            
            .pipe-piece {
                width: 50px;
                height: 50px;
                font-size: 1rem;
            }
            
            .placed-pipe {
                width: 50px;
                height: 50px;
            }
            
            .start-pipe, .answer-pipe {
                width: 50px;
                height: 50px;
                font-size: 0.9rem;
            }
            
            .math-problem {
                font-size: 1.3rem;
            }
            
            #sidebar {
                width: 100%;
                max-width: none;
            }
            
            .level-info {
                margin-bottom: 15px;
            }
            
            .score-display div {
                margin-bottom: 5px;
                font-size: 0.9rem;
            }
        }

        @keyframes sparkEffect {
            0% { 
                transform: scale(0) rotate(0deg);
                opacity: 1;
                box-shadow: 0 0 0px #FFD700;
            }
            25% { 
                transform: scale(2) rotate(90deg);
                opacity: 1;
                box-shadow: 0 0 20px #FFD700;
            }
            50% { 
                transform: scale(1.5) rotate(180deg);
                opacity: 0.8;
                box-shadow: 0 0 15px #FFD700;
            }
            100% { 
                transform: scale(0) rotate(360deg);
                opacity: 0;
                box-shadow: 0 0 0px #FFD700;
            }
        }

        .connection-line {
            background: linear-gradient(90deg, #4FC3F7, #29B6F6);
            border-radius: 4px;
            box-shadow: 0 0 8px #4FC3F7;
            animation: connectionGlow 2s ease-in-out infinite;
        }

        @keyframes connectionGlow {
            0%, 100% { 
                box-shadow: 0 0 8px #4FC3F7;
                opacity: 0.8;
            }
            50% { 
                box-shadow: 0 0 15px #4FC3F7, 0 0 25px rgba(79, 195, 247, 0.5);
                opacity: 1;
            }
        }

        .placed-pipe.flowing {
            animation: waterFlow 3s ease-in-out infinite;
        }

        @keyframes waterFlow {
            0%, 100% { 
                transform: scale(1);
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.02);
                filter: brightness(1.2);
            }
        }

        /* Enhanced styling for curved elbows */
        .placed-pipe:contains('╭'), .placed-pipe:contains('╮'), 
        .placed-pipe:contains('╰'), .placed-pipe:contains('╯') {
            font-size: 1.5rem;
            color: #555;
        }

        /* T-junction styling */
        .placed-pipe:contains('┣'), .placed-pipe:contains('┫'),
        .placed-pipe:contains('┻'), .placed-pipe:contains('┳') {
            font-size: 1.4rem;
            color: #555;
        }

        /* Cross junction styling */
        .placed-pipe:contains('╋') {
            font-size: 1.3rem;
            color: #555;
        }

        .pipe-piece.selected {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            border: 3px solid #FFD700;
            z-index: 10;
        }
        
        .pipe-piece.selected::after {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            border: 2px solid #FFD700;
            border-radius: 20px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* Mobile-specific styles */
        @media (max-width: 767px) {
            .pipe-piece {
                cursor: pointer;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            .pipe-piece:active {
                transform: scale(0.95);
            }
            
            .placed-pipe {
                cursor: pointer;
                user-select: none;
                -webkit-tap-highlight-color: transparent;
            }
            
            .placed-pipe:active {
                transform: scale(0.95);
            }
            
            /* Prevent text selection on mobile */
            .play-area, .pipe-inventory {
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
        }

        @keyframes waterRippleExpand {
            0% { 
                transform: scale(0.8); 
                opacity: 1; 
                border-width: 2px;
            }
            100% { 
                transform: scale(2); 
                opacity: 0; 
                border-width: 1px;
            }
        }
        
        .water-ripple {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 767px) {
            .app {
                padding: 10px;
                gap: 10px;
            }
            
            #title {
                margin-top: 10px;
                margin-bottom: 10px;
                font-size: 1.5rem;
            }
            
            #sidebar {
                order: 3;
            }
            
            .game-wrap {
                order: 2;
            }
            
            .game-container {
                margin: 10px auto;
                padding: 15px;
            }
            
            .pipe-inventory {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .control-row {
                flex-direction: column;
                gap: 10px;
            }
            
            .control-btn {
                width: 100%;
                margin: 5px 0;
            }
            
            .play-area {
                margin: 10px auto;
                max-width: 100vw;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <nav id="gameNav" style="padding:10px; background:#111; color:#0f0; font-family:monospace;">
            <strong>Games:</strong>
        </nav>
        
        <h1 id="title">🚰 Pipe Dream</h1>
        
        <div class="game-wrap">
            <div class="game-container">
                <div class="game-header">
                    <h1>🚰 Pipe Dream</h1>
                    <p>Connect pipes to solve math problems and watch the water flow!</p>
                </div>
        


                <div class="math-problem" id="mathProblem" role="heading" aria-level="2">
                    5 + 3 = ?
                </div>

                <div class="pipe-inventory" id="pipeInventory">
                    <!-- Pipe pieces will be generated here -->
                </div>

                <div class="play-area" id="playArea">
                    <!-- Placed pipes will appear here -->
                </div>

                <div class="game-controls">
                    <div class="control-row">
                        <button class="control-btn water-btn" id="flowTestBtn" aria-label="Start water flow">
                            <span class="tap-icon">💧</span>
                            Start Tap
                        </button>
                    </div>
                    <div class="control-row">
                        <button class="control-btn" id="newLevelBtn" aria-label="Start new level">New Level</button>
                        <button class="control-btn" id="resetBtn" aria-label="Reset current level">Reset</button>
                        <button class="control-btn" id="undoBtn" aria-label="Undo last pipe placement">Undo</button>
                        <button class="control-btn" id="hintBtn" aria-label="Get a hint for current problem">Hint</button>
                    </div>
                </div>
                    </div>
                </div>

                <div id="sidebar">
                    <div class="level-info" style="margin-bottom: 20px;">
                        <div class="score-display" style="text-align: center; margin-bottom: 15px;">
                            <div style="margin-bottom: 8px;">
                                <strong>Level:</strong> <span id="level">1</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Score:</strong> <span id="score">0</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong>Stars:</strong> <span id="stars">0</span>
                            </div>
                        </div>
                        <div class="pressure-gauge" style="text-align: center;">
                            <strong>Pressure:</strong> <span id="pressure">0</span>%
                            <div class="pressure-bar" style="margin: 10px auto;">
                                <div class="pressure-fill" id="pressureFill"></div>
                            </div>
                        </div>
                    </div>

                    <div role="region" aria-label="Game Settings">
                        <div class="section-title">SETTINGS</div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 5px; color: #0f0;">Game Mode:</label>
                            <select id="gameMode" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px; margin-bottom: 10px;">
                                <option value="practice">Practice (Free Build)</option>
                                <option value="adventure">Adventure (Levels)</option>
                                <option value="timed">Timed Rush</option>
                            </select>
                            
                            <label style="display: block; margin-bottom: 5px; color: #0f0;">Difficulty:</label>
                            <select id="difficulty" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px; margin-bottom: 10px;">
                                <option value="basic">Basic (Ages 5-7)</option>
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Hard</option>
                            </select>
                            
                            <label style="display: block; margin-bottom: 5px; color: #0f0;">Grid Size:</label>
                            <select id="gridSize" style="width: 100%; padding: 8px; background: #1a1a2e; color: #0f0; border: 2px solid #0f0; border-radius: 5px; margin-bottom: 10px;">
                                <option value="5x5" id="5x5-option">5×5 Grid</option>
                                <option value="6x4">6×4 Grid</option>
                                <option value="7x5">7×5 Grid</option>
                                <option value="8x5" id="8x5-option">8×5 Grid (Default)</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 15px;">
                            <div class="section-title">OPERATIONS</div>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="opAdd" checked style="accent-color: #0f0;"> +
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="opSub" style="accent-color: #0f0;"> −
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="opMul" style="accent-color: #0f0;"> ×
                                </label>
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="opDiv" style="accent-color: #0f0;"> ÷
                                </label>
                            </div>
                            
                            <div style="margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="allowNegatives" style="accent-color: #0f0;"> Allow Negatives
                                </label>
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: flex; align-items: center; gap: 5px; color: #0f0;">
                                    <input type="checkbox" id="showPrecedenceHints" checked style="accent-color: #0f0;"> Show Hints
                                </label>
                            </div>
                        </div>
                        
                        <button id="applySettings" style="width: 100%; background: #0f0; color: #000; border: none; padding: 12px; border-radius: 8px; font-weight: bold; cursor: pointer; font-size: 1rem;">
                            Apply Settings & New Game
                        </button>
                    </div>

                    <div id="scoreboard" role="region" aria-label="Game Score">
                        <div class="section-title">CURRENT</div>
                        <div class="section-title">Level</div><div class="value" id="levelDisplay">1</div>
                        <div class="section-title">Score</div><div class="value" id="scoreDisplay">0</div>
                        <div class="section-title">Pressure</div><div class="value" id="pressureDisplay">0%</div>
                    </div>

                    <div id="instructions">
                        <div class="section-title">CONTROLS</div>
                        Drag & Drop — place pipes<br>
                        Double-click — rotate pipes<br>
                        Drag placed pipes — reposition
                        
                        <div style="margin-top: 15px" class="section-title">RULES</div>
                        <div style="font-size: 13px; line-height: 1.4;">
                            • Connect start pipe (green) to answer pipe (red)<br>
                            • Use operator pipes (+, −, ×, ÷) for math<br>
                            • Route through connector pipes<br>
                            • Water flows when pipes connect<br>
                            • Solve the math expression correctly
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Sound Effects -->
    <audio id="buildSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    <audio id="testSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    <audio id="celebrateSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT" type="audio/wav">
    </audio>
    
    <script src="navigation.js"></script>
    <script>
        class PipeDream {
            constructor() {
                this.gameMode = 'practice'; // 'adventure', 'practice', 'timed'
                this.difficulty = 'basic'; // 'basic', 'easy', 'medium', 'hard'
                
                // Detect mobile device
                this.isMobile = window.innerWidth <= 768;
                
                // Set default grid size based on screen size
                if (this.isMobile) {
                    this.gridSize = '5x5'; // Mobile default
                } else {
                    this.gridSize = '8x5'; // Desktop default
                }
                
                this.operations = ['+']; // Available operations - default to addition only
                this.allowNegatives = false;
                this.showPrecedenceHints = true;
                
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 12;
                this.maxPressure = 100;
                this.gameActive = true;
                
                this.pipes = [];
                this.connectedPipes = [];
                this.draggedPipe = null;
                this.draggedPlacedPipe = null;
                this.timer = null;
                this.pipeHistory = [];
                
                this.startPipe = null;
                this.answerPipes = [];
                this.obstacles = [];
                this.inventory = [];
                
                this.currentExpression = null;
                this.correctAnswer = null;
                this.decoyAnswers = [];
                
                this.init();
            }
            
            // Sound effects
            playSound(soundId) {
                try {
                    const audio = document.getElementById(soundId);
                    if (audio) {
                        audio.currentTime = 0;
                        audio.play().catch(e => console.log('Audio play failed:', e));
                    }
                } catch (e) {
                    console.log('Sound play error:', e);
                }
            }
            
            // Game configuration based on difficulty
            getGameConfig() {
                const configs = {
                    basic: {
                        maxPathLength: 6,
                        answerPipeCount: 2,
                        allowCrossings: false,
                        pressureRate: 0.3,
                        maxNumber: 5,
                        operations: ['+']
                    },
                    easy: {
                        maxPathLength: 8,
                        answerPipeCount: 3,
                        allowCrossings: false,
                        pressureRate: 0.5,
                        maxNumber: 10,
                        operations: ['+', '-']
                    },
                    medium: {
                        maxPathLength: 12,
                        answerPipeCount: 4,
                        allowCrossings: false,
                        pressureRate: 1.0,
                        maxNumber: 15,
                        operations: ['+', '-', '×']
                    },
                    hard: {
                        maxPathLength: 16,
                        answerPipeCount: 5,
                        allowCrossings: true,
                        pressureRate: 2.0,
                        maxNumber: 20,
                        operations: ['+', '-', '×', '÷']
                    }
                };
                return configs[this.difficulty] || configs.basic;
            }
            
            // Grid configuration based on grid size selection
            getGridConfig() {
                // Determine cell size based on screen size and grid dimensions
                let baseCellSize = 60;
                if (window.innerWidth <= 768) {
                    // Mobile: use larger cells to ensure grid is fully visible
                    baseCellSize = 80;
                }
                
                const gridConfigs = {
                    '5x5': { width: 5, height: 5, cellSize: baseCellSize },
                    '6x4': { width: 6, height: 4, cellSize: baseCellSize },
                    '7x5': { width: 7, height: 5, cellSize: baseCellSize },
                    '8x5': { width: 8, height: 5, cellSize: baseCellSize }
                };
                return gridConfigs[this.gridSize] || gridConfigs['8x5'];
            }
            
            // Enhanced pipe types with operators and special pieces
            getPipeTypes() {
                const basePipes = [
                    // Numbers
                    { symbol: '1', value: 1, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '2', value: 2, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '3', value: 3, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '4', value: 4, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '5', value: 5, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '6', value: 6, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '7', value: 7, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '8', value: 8, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '9', value: 9, type: 'number', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Operators
                    { symbol: '●', value: 0, type: 'operator', operation: '+', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '●', value: 0, type: 'operator', operation: '-', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '●', value: 0, type: 'operator', operation: '×', connections: ['top', 'bottom', 'left', 'right'] },
                    { symbol: '●', value: 0, type: 'operator', operation: '÷', connections: ['top', 'bottom', 'left', 'right'] },
                    
                    // Connectors - make them look more like actual pipe segments with proper curves
                    { symbol: '╋', value: 0, type: 'connector', connections: ['top', 'bottom', 'left', 'right'] }, // cross junction
                    { symbol: '┣', value: 0, type: 'connector', connections: ['top', 'bottom', 'left'] }, // T-junction left
                    { symbol: '┫', value: 0, type: 'connector', connections: ['top', 'bottom', 'right'] }, // T-junction right
                    { symbol: '┻', value: 0, type: 'connector', connections: ['bottom', 'left', 'right'] }, // T-junction bottom
                    { symbol: '┳', value: 0, type: 'connector', connections: ['top', 'left', 'right'] }, // T-junction top
                    { symbol: '╭', value: 0, type: 'connector', connections: ['top', 'right'] }, // top-right curved elbow
                    { symbol: '╮', value: 0, type: 'connector', connections: ['top', 'left'] }, // top-left curved elbow
                    { symbol: '╰', value: 0, type: 'connector', connections: ['bottom', 'right'] }, // bottom-right curved elbow
                    { symbol: '╯', value: 0, type: 'connector', connections: ['bottom', 'left'] }, // bottom-left curved elbow
                    { symbol: '━', value: 0, type: 'connector', connections: ['left', 'right'] }, // horizontal pipe
                    { symbol: '┃', value: 0, type: 'connector', connections: ['top', 'bottom'] } // vertical pipe
                ];
                
                // Add special pieces for medium+ difficulty
                if (this.difficulty !== 'easy') {
                    basePipes.push(
                        { symbol: '╬', value: 0, type: 'splitter', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: '▶', value: 0, type: 'valve', connections: ['left', 'right'] }
                    );
                }
                
                // Add advanced pieces for hard difficulty
                if (this.difficulty === 'hard') {
                    basePipes.push(
                        { symbol: '⊕', value: 0, type: 'crossover', connections: ['top', 'bottom', 'left', 'right'] },
                        { symbol: '⚡', value: 0, type: 'pressureValve', connections: ['top', 'bottom', 'left', 'right'] }
                    );
                }
                
                return basePipes;
            }
            
            init() {
                this.pipeHistory = [];
                this.createNewPuzzle();
                this.setupEventListeners();
                this.startPressureTimer();
                this.updateDisplay();
                this.updateUndoButton();
                this.setupSettingsUI();
            }
            
            setupSettingsUI() {
                // Set initial UI values
                document.getElementById('gameMode').value = this.gameMode;
                document.getElementById('difficulty').value = this.difficulty;
                document.getElementById('gridSize').value = this.gridSize;
                
                // Update the selected attribute based on current grid size
                document.querySelectorAll('#gridSize option').forEach(option => {
                    option.selected = option.value === this.gridSize;
                });
                
                document.getElementById('opAdd').checked = this.operations.includes('+');
                document.getElementById('opSub').checked = this.operations.includes('-');
                document.getElementById('opMul').checked = this.operations.includes('×');
                document.getElementById('opDiv').checked = this.operations.includes('÷');
                document.getElementById('allowNegatives').checked = this.allowNegatives;
                document.getElementById('showPrecedenceHints').checked = this.showPrecedenceHints;
                
                // Add event listener for apply settings button
                document.getElementById('applySettings').addEventListener('click', () => this.applySettings());
            }
            
            applySettings() {
                // Update game settings from UI
                this.gameMode = document.getElementById('gameMode').value;
                this.difficulty = document.getElementById('difficulty').value;
                this.gridSize = document.getElementById('gridSize').value;
                
                // Update operations based on difficulty
                const config = this.getGameConfig();
                this.operations = config.operations;
                
                // Update operation checkboxes to match difficulty
                document.getElementById('opAdd').checked = this.operations.includes('+');
                document.getElementById('opSub').checked = this.operations.includes('-');
                document.getElementById('opMul').checked = this.operations.includes('×');
                document.getElementById('opDiv').checked = this.operations.includes('÷');
                
                // Update other settings
                this.allowNegatives = document.getElementById('allowNegatives').checked;
                this.showPrecedenceHints = document.getElementById('showPrecedenceHints').checked;
                
                // Reset game with new settings
                this.level = 1;
                this.score = 0;
                this.stars = 0;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
                
                alert('Settings applied! New game started.');
            }
            
            createNewPuzzle() {
                this.currentExpression = this.generateExpression();
                this.correctAnswer = this.evaluateExpression(this.currentExpression);
                this.decoyAnswers = this.generateDecoyAnswers();
                this.createGrid();
                this.placeStartAndAnswerPipes();
                this.generateInventory();
                this.updateDisplay();
            }
            
            generateExpression() {
                const config = this.getGameConfig();
                let expression;
                
                if (this.difficulty === 'basic') {
                    // Basic: Very simple addition for ages 5-7
                    const a = Math.floor(Math.random() * 5) + 1; // 1-5
                    const b = Math.floor(Math.random() * 5) + 1; // 1-5
                    expression = { a, b, op: '+', type: 'simple' };
                } else if (this.difficulty === 'easy') {
                    // Simple: a ⊕ b
                    const op = this.operations[Math.floor(Math.random() * this.operations.length)];
                    const a = this.getRandomNumber(op, 0, 10);
                    const b = this.getRandomNumber(op, 0, 10);
                    expression = { a, b, op, type: 'simple' };
                } else if (this.difficulty === 'medium') {
                    // Medium: (a ⊕ b) ⊗ c or a ⊕ (b ⊗ c)
                    // Only use operations that are available
                    const availableOps = this.operations.filter(op => op !== '÷'); // Avoid division in medium for now
                    if (availableOps.length < 2) {
                        // Fall back to simple if not enough operations
                        const op = this.operations[0];
                        const a = this.getRandomNumber(op, 0, 15);
                        const b = this.getRandomNumber(op, 0, 15);
                        expression = { a, b, op, type: 'simple' };
                    } else {
                        const op1 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const op2 = availableOps[Math.floor(Math.random() * availableOps.length)];
                        const a = this.getRandomNumber(op1, 0, 20);
                        const b = this.getRandomNumber(op1, 0, 20);
                        const c = this.getRandomNumber(op2, 0, 10);
                        
                        if (Math.random() > 0.5) {
                            expression = { a, b, c, op1, op2, type: 'leftGrouped' };
                        } else {
                            expression = { a, b, c, op1, op2, type: 'rightGrouped' };
                        }
                    }
                } else {
                    // Hard: a ⊕ b ⊗ c ⊖ d with precedence
                    // Only use available operations
                    const addOps = this.operations.filter(op => op === '+' || op === '-');
                    const mulOps = this.operations.filter(op => op === '×' || op === '÷');
                    
                    if (addOps.length === 0) addOps.push('+');
                    if (mulOps.length === 0) mulOps.push('×');
                    
                    const a = this.getRandomNumber(addOps[0], 0, 50);
                    const b = this.getRandomNumber(mulOps[0], 0, 12);
                    const c = this.getRandomNumber(mulOps[0], 0, 12);
                    const d = this.getRandomNumber(addOps[0], 0, 50);
                    expression = { a, b, c, d, type: 'precedence' };
                }
                
                return expression;
            }
            
            getRandomNumber(operation, min, max) {
                const config = this.getGameConfig();
                const maxNum = config.maxNumber || max;
                let num;
                do {
                    num = Math.floor(Math.random() * (maxNum - min + 1)) + min;
                } while (!this.allowNegatives && operation === '-' && num === 0);
                return num;
            }
            
            evaluateExpression(expr) {
                if (expr.type === 'simple') {
                    return this.applyOperation(expr.a, expr.b, expr.op);
                } else if (expr.type === 'leftGrouped') {
                    const first = this.applyOperation(expr.a, expr.b, expr.op1);
                    return this.applyOperation(first, expr.c, expr.op2);
                } else if (expr.type === 'rightGrouped') {
                    const second = this.applyOperation(expr.b, expr.c, expr.op2);
                    return this.applyOperation(expr.a, second, expr.op1);
                } else if (expr.type === 'precedence') {
                    // Follow order of operations: × ÷ before + −
                    const product = this.applyOperation(expr.b, expr.c, '×');
                    const sum = this.applyOperation(expr.a, product, '+');
                    return this.applyOperation(sum, expr.d, '-');
                }
                return 0;
            }
            
            applyOperation(a, b, op) {
                switch (op) {
                    case '+': return a + b;
                    case '-': return a - b;
                    case '×': return a * b;
                    case '÷': return Math.floor(a / b);
                    default: return a;
                }
            }
            
            generateDecoyAnswers() {
                const config = this.getGameConfig();
                const decoys = [];
                const correct = this.correctAnswer;
                
                // Generate plausible wrong answers
                const decoyTypes = [
                    correct + 1, // off-by-one
                    correct - 1,
                    correct * 2, // operation confusion
                    correct / 2,
                    Math.abs(correct), // sign error
                    -correct
                ];
                
                // Filter valid decoys
                decoyTypes.forEach(decoy => {
                    if (decoy !== correct && 
                        decoy >= (this.allowNegatives ? -100 : 0) && 
                        decoy <= 100 &&
                        !decoys.includes(decoy)) {
                        decoys.push(decoy);
                    }
                });
                
                // Fill remaining slots with random plausible values
                while (decoys.length < config.answerPipeCount - 1) {
                    const randomDecoy = Math.floor(Math.random() * 50) - (this.allowNegatives ? 25 : 0);
                    if (randomDecoy !== correct && !decoys.includes(randomDecoy)) {
                        decoys.push(randomDecoy);
                    }
                }
                
                return decoys.slice(0, config.answerPipeCount - 1);
            }
            
            createGrid() {
                const playArea = document.getElementById('playArea');
                playArea.innerHTML = '';
                
                // Get grid configuration
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                
                // Calculate play area dimensions based on grid
                const playAreaWidth = gridConfig.width * cellSize;
                const playAreaHeight = gridConfig.height * cellSize;
                
                // Update play area size to fit the grid
                playArea.style.width = playAreaWidth + 'px';
                playArea.style.height = playAreaHeight + 'px';
                playArea.style.maxWidth = '100%';
                playArea.style.margin = '20px auto';
                
                // Update grid background
                playArea.style.backgroundSize = `${cellSize}px ${cellSize}px`;
                
                // Create grid cells for visual reference
                for (let x = 0; x < gridConfig.width; x++) {
                    for (let y = 0; y < gridConfig.height; y++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.style.position = 'absolute';
                        cell.style.left = (x * cellSize) + 'px';
                        cell.style.top = (y * cellSize) + 'px';
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';
                        cell.style.border = '1px solid rgba(0, 255, 0, 0.2)';
                        cell.style.pointerEvents = 'none';
                        cell.style.zIndex = '1';
                        playArea.appendChild(cell);
                    }
                }
            }
            
            placeStartAndAnswerPipes() {
                const playArea = document.getElementById('playArea');
                const config = this.getGameConfig();
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                
                // Place start pipe on left side, centered vertically in the row
                const startY = Math.floor(gridConfig.height / 2);
                this.startPipe = {
                    x: 0,
                    y: startY,
                    value: this.currentExpression.a,
                    type: 'start'
                };
                
                // Create start pipe element
                const startElement = document.createElement('div');
                startElement.className = 'start-pipe';
                startElement.textContent = this.currentExpression.a;
                startElement.style.left = '0px';
                startElement.style.top = (startY * cellSize) + 'px';
                playArea.appendChild(startElement);
                
                // IMPORTANT: Add start pipe to the pipes array so it can be found by pathfinding
                const startPipeInfo = {
                    element: startElement,
                    data: { symbol: this.currentExpression.a, value: this.currentExpression.a, type: 'start' },
                    x: 0,
                    y: startY * cellSize, // Convert grid position to pixel position
                    connected: false,
                    timestamp: Date.now()
                };
                this.pipes.push(startPipeInfo);
                
                console.log('🚰 Start pipe added to pipes array:', startPipeInfo);
                
                // Place answer pipes along right and bottom edges
                const allAnswers = [this.correctAnswer, ...this.decoyAnswers];
                const shuffledAnswers = allAnswers.sort(() => Math.random() - 0.5);
                
                shuffledAnswers.forEach((answer, index) => {
                    let x, y;
                    
                    if (index < gridConfig.height - 1) {
                        // Place along right edge
                        x = gridConfig.width - 1;
                        y = index;
                    } else {
                        // Place along bottom edge
                        x = index - (gridConfig.height - 1);
                        y = gridConfig.height - 1;
                    }
                    
                    const answerPipe = {
                        x: x,
                        y: y,
                        value: answer,
                        type: 'answer',
                        isCorrect: answer === this.correctAnswer
                    };
                    
                    this.answerPipes.push(answerPipe);
                    
                    // Create answer pipe element - all start as decoys until solved
                    const answerElement = document.createElement('div');
                    answerElement.className = 'answer-pipe decoy';
                    answerElement.textContent = answer;
                    answerElement.style.left = (x * cellSize) + 'px';
                    answerElement.style.top = (y * cellSize) + 'px';
                    answerElement.dataset.correctAnswer = answer === this.correctAnswer;
                    playArea.appendChild(answerElement);
                });
            }
            
            generateInventory() {
                const inventory = document.getElementById('pipeInventory');
                inventory.innerHTML = '';
                
                const config = this.getGameConfig();
                const pipeTypes = this.getPipeTypes();
                const pipes = [];
                
                // Add numbers from the expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                } else if (this.currentExpression.type === 'precedence') {
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.b));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.c));
                    pipes.push(pipeTypes.find(p => p.value === this.currentExpression.d));
                }
                
                // Ensure the answer is available if it's not already included
                if (!pipes.some(p => p.value === this.correctAnswer)) {
                    pipes.push(pipeTypes.find(p => p.value === this.correctAnswer));
                }
                
                // Add some extra numbers to make players think strategically
                let extraNumbers;
                if (this.difficulty === 'basic') {
                    // For basic difficulty, only use small numbers 1-5
                    extraNumbers = [1, 2, 3, 4, 5].filter(num => {
                        if (this.currentExpression.type === 'simple') {
                            return num !== this.currentExpression.a && num !== this.currentExpression.b;
                        }
                        return true;
                    });
                } else {
                    extraNumbers = [2, 3, 4, 6, 7, 8, 9].filter(num => {
                        // Don't add numbers that are already in the expression
                        if (this.currentExpression.type === 'simple') {
                            return num !== this.currentExpression.a && num !== this.currentExpression.b;
                        } else if (this.currentExpression.type === 'leftGrouped') {
                            return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c;
                        } else if (this.currentExpression.type === 'rightGrouped') {
                            return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c;
                        } else if (this.currentExpression.type === 'precedence') {
                            return num !== this.currentExpression.a && num !== this.currentExpression.b && num !== this.currentExpression.c && num !== this.currentExpression.d;
                        }
                        return true;
                    });
                }
                
                // Add 2-3 random extra numbers
                const extraCount = Math.min(3, extraNumbers.length);
                for (let i = 0; i < extraCount; i++) {
                    const randomIndex = Math.floor(Math.random() * extraNumbers.length);
                    const extraNum = extraNumbers.splice(randomIndex, 1)[0];
                    pipes.push(pipeTypes.find(p => p.value === extraNum));
                }
                
                // Add operators - only use the ones in the current expression
                if (this.currentExpression.type === 'simple') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op));
                } else if (this.currentExpression.type === 'leftGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'rightGrouped') {
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op1));
                    pipes.push(pipeTypes.find(p => p.operation === this.currentExpression.op2));
                } else if (this.currentExpression.type === 'precedence') {
                    // For precedence, we need specific operations
                    if (this.operations.includes('+')) pipes.push(pipeTypes.find(p => p.operation === '+'));
                    if (this.operations.includes('×')) pipes.push(pipeTypes.find(p => p.operation === '×'));
                    if (this.operations.includes('-')) pipes.push(pipeTypes.find(p => p.operation === '-'));
                }
                
                // Add connector pipes - ensure we have enough for the grid
                const connectors = pipeTypes.filter(p => p.type === 'connector');
                const connectorCount = Math.min(12, connectors.length); // More connectors for better gameplay
                for (let i = 0; i < connectorCount; i++) {
                    pipes.push(connectors[i]);
                }
                
                // Filter out undefined pipes and shuffle
                const validPipes = pipes.filter(pipe => pipe !== undefined);
                const shuffledPipes = validPipes.sort(() => Math.random() - 0.5);
                
                shuffledPipes.forEach(pipe => {
                    const pipeElement = document.createElement('div');
                    pipeElement.className = 'pipe-piece';
                    pipeElement.draggable = true;
                    pipeElement.dataset.pipeType = JSON.stringify(pipe);
                    
                    // Decide what kind of pipe it is and render SVG
                    let type = 'straight-h'; let rot = 0;
                    
                    if (pipe.type === 'number') {
                        // Number pipes get a special number display
                        pipeElement.innerHTML = `
                            <div style="
                                width: 100%; 
                                height: 100%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                background: linear-gradient(135deg, #4CAF50, #66BB6A);
                                border: 3px solid #2E7D32;
                                border-radius: 15px;
                                color: white;
                                font-size: 1.2rem;
                                font-weight: bold;
                                text-shadow: 1px 1px 2px #000;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                                position: relative;
                            ">
                                ${pipe.symbol}
                            </div>
                        `;
                    } else if (pipe.type === 'operator') {
                        // Operator pipes get a special operator display
                        pipeElement.innerHTML = `
                            <div style="
                                width: 100%; 
                                height: 100%; 
                                display: flex; 
                                align-items: center; 
                                justify-content: center; 
                                background: linear-gradient(135deg, #FF9800, #FFB74D);
                                border: 3px solid #F57C00;
                                border-radius: 15px;
                                color: white;
                                font-size: 1.4rem;
                                font-weight: bold;
                                text-shadow: 1px 1px 2px #000;
                                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                                position: relative;
                            ">
                                ${pipe.operation}
                            </div>
                        `;
                    } else {
                        // Connector pipes use SVG rendering
                        switch(pipe.symbol) {
                            case '━': type = 'straight-h'; break;
                            case '┃': type = 'straight-v'; break;
                            case '╭': type = 'elbow'; rot = 0; break;      // top-right
                            case '╮': type = 'elbow'; rot = 90; break;     // top-left
                            case '╰': type = 'elbow'; rot = 270; break;    // bottom-right
                            case '╯': type = 'elbow'; rot = 180; break;    // bottom-left
                            case '┣': type = 'tee'; rot = 180; break;
                            case '┫': type = 'tee'; rot = 0; break;
                            case '┻': type = 'tee'; rot = 90; break;
                            case '┳': type = 'tee'; rot = 270; break;
                            case '╋': type = 'cross'; break;
                            default: type = 'straight-h';
                        }
                        renderPipeInto(pipeElement, type, rot);
                    }
                    

                    
                    pipeElement.addEventListener('dragstart', (e) => this.handleDragStart(e, pipe));
                    pipeElement.addEventListener('dragend', () => this.handleDragEnd());
                    
                    inventory.appendChild(pipeElement);
                });
            }
            

            
            setupEventListeners() {
                const playArea = document.getElementById('playArea');
                const inventory = document.getElementById('pipeInventory');
                
                console.log('🔧 Setting up event listeners, isMobile:', this.isMobile);
                
                // Desktop drag and drop
                if (!this.isMobile) {
                    console.log('🖥️ Setting up desktop drag and drop events');
                    inventory.addEventListener('dragstart', (e) => this.handleDragStart(e));
                    inventory.addEventListener('dragend', (e) => this.handleDragEnd(e));
                    playArea.addEventListener('dragover', (e) => e.preventDefault());
                    playArea.addEventListener('drop', (e) => this.handleDrop(e));
                    
                    // Placed pipe drag events
                    playArea.addEventListener('dragstart', (e) => this.handlePlacedPipeDragStart(e));
                    playArea.addEventListener('dragend', (e) => this.handlePlacedPipeDragEnd(e));
                }
                
                // Mobile tap events
                if (this.isMobile) {
                    console.log('📱 Setting up mobile tap events');
                    
                    // Inventory tap to select
                    inventory.addEventListener('click', (e) => this.handleInventoryTap(e));
                    
                    // Grid tap to place
                    playArea.addEventListener('click', (e) => this.handleGridTap(e));
                    
                    // Double tap to rotate placed pipes
                    playArea.addEventListener('dblclick', (e) => this.handleDoubleTap(e));
                }
                
                // Common events for both desktop and mobile
                document.getElementById('newLevelBtn').addEventListener('click', () => this.newLevel());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetLevel());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoLastPipe());
                document.getElementById('flowTestBtn').addEventListener('click', () => this.testFlow());
                
                // Settings events
                document.getElementById('gameMode').addEventListener('change', () => this.applySettings());
                document.getElementById('difficulty').addEventListener('change', () => this.applySettings());
                document.getElementById('gridSize').addEventListener('change', () => this.applySettings());
                
                // Operation checkboxes
                document.querySelectorAll('input[name="operation"]').forEach(checkbox => {
                    checkbox.addEventListener('change', () => this.applySettings());
                });
                
                document.getElementById('allowNegatives').addEventListener('change', () => this.applySettings());
                
                // Handle window resize for responsive grid sizing
                window.addEventListener('resize', () => this.handleResize());
            }
            
            handleResize() {
                // Check if we need to update grid size based on screen size
                const wasMobile = this.isMobile;
                this.isMobile = window.innerWidth <= 768;
                const currentGridSize = this.gridSize;
                let newGridSize = currentGridSize;
                
                if (this.isMobile && currentGridSize === '8x5') {
                    // Switch to 5x5 on mobile for better visibility
                    newGridSize = '5x5';
                } else if (!this.isMobile && currentGridSize === '5x5') {
                    // Switch back to 8x5 on desktop
                    newGridSize = '8x5';
                }
                
                if (newGridSize !== currentGridSize) {
                    this.gridSize = newGridSize;
                    document.getElementById('gridSize').value = newGridSize;
                    this.createNewPuzzle(); // Recreate puzzle with new grid size
                }
            }
            
            handleDragStart(e) {
                const pipeElement = e.target.closest('.pipe-piece');
                if (!pipeElement) return;
                
                const pipeData = JSON.parse(pipeElement.dataset.pipeType);
                e.dataTransfer.setData('text/plain', JSON.stringify(pipeElement.dataset.pipeType));
                e.dataTransfer.effectAllowed = 'copy';
                
                pipeElement.style.opacity = '0.7';
            }
            
            handleDragEnd(e) {
                const pipeElement = e.target.closest('.pipe-piece');
                if (pipeElement) {
                    pipeElement.style.opacity = '1';
                }
            }
            
            handlePlacedPipeDragStart(e) {
                const pipeElement = e.target.closest('.placed-pipe');
                if (!pipeElement) return;
                
                e.dataTransfer.setData('text/plain', 'move');
                e.dataTransfer.effectAllowed = 'move';
                
                pipeElement.style.opacity = '0.7';
            }
            
            handlePlacedPipeDragEnd(e) {
                const pipeElement = e.target.closest('.placed-pipe');
                if (pipeElement) {
                    pipeElement.style.opacity = '1';
                }
            }
            
            handleDrop(e) {
                e.preventDefault();
                
                const pipeData = JSON.parse(e.dataTransfer.getData('text/plain'));
                const rect = e.currentTarget.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Snap to grid
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);
                
                // Convert back to pixel coordinates
                const snapX = gridX * cellSize;
                const snapY = gridY * cellSize;
                
                this.placePipe(pipeData, snapX, snapY);
            }
            
            placePipe(pipeData, x, y) {
                console.log('📍 placePipe() called with:', pipeData, 'at position:', x, y);
                const playArea = document.getElementById('playArea');
                const pipeElement = document.createElement('div');
                
                pipeElement.className = 'placed-pipe';
                pipeElement.style.left = x + 'px';
                pipeElement.style.top = y + 'px'; // Center vertically in the grid cell
                pipeElement.dataset.pipeData = JSON.stringify(pipeData);
                pipeElement.dataset.x = x;
                pipeElement.dataset.y = y;
                pipeElement.dataset.pipeId = Date.now(); // Add unique ID for water flow styling
                
                console.log('🔧 Pipe element created with data:', pipeElement.dataset);
                
                // Make placed pipes draggable for repositioning
                pipeElement.draggable = true;
                pipeElement.addEventListener('dragstart', (e) => this.handlePlacedPipeDragStart(e, pipeElement));
                pipeElement.addEventListener('dragend', () => this.handlePlacedPipeDragEnd());
                
                // Add double-click to rotate pipes
                pipeElement.addEventListener('dblclick', () => this.rotatePipe(pipeElement));
                
                // Decide what kind of pipe it is and render SVG
                let type = 'straight-h'; let rot = 0;
                
                if (pipeData.type === 'number') {
                    console.log('🔢 Rendering number pipe:', pipeData.symbol);
                    // Number pipes get a special number display
                    pipeElement.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #4CAF50, #66BB6A);
                            border: 3px solid #2E7D32;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.2rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.symbol}
                        </div>
                    `;
                } else if (pipeData.type === 'operator') {
                    console.log('🔧 Rendering operator pipe:', pipeData.operation);
                    // Operator pipes get a special operator display
                    pipeElement.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #FF9800, #FFB74D);
                            border: 3px solid #F57C00;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.4rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.operation}
                        </div>
                    `;
                } else {
                    console.log('🔗 Rendering connector pipe:', pipeData.symbol);
                    // Connector pipes use SVG rendering
                    switch(pipeData.symbol) {
                        case '━': type = 'straight-h'; break;
                        case '┃': type = 'straight-v'; break;
                        case '╭': type = 'elbow'; rot = 0; break;      // top-right
                        case '╮': type = 'elbow'; rot = 90; break;     // top-left
                        case '╰': type = 'elbow'; rot = 270; break;    // bottom-right
                        case '╯': type = 'elbow'; rot = 180; break;    // bottom-left
                        case '┣': type = 'tee'; rot = 180; break;
                        case '┫': type = 'tee'; rot = 0; break;
                        case '┻': type = 'tee'; rot = 90; break;
                        case '┳': type = 'tee'; rot = 270; break;
                        case '╋': type = 'cross'; break;
                        default: type = 'straight-h';
                    }
                    renderPipeInto(pipeElement, type, rot);
                    
                    // Add rotatable class for connector pipes
                    pipeElement.classList.add('rotatable');
                }
                

                
                // Remove click event - pipes will connect automatically when placed correctly
                
                playArea.appendChild(pipeElement);
                
                const pipeInfo = {
                    element: pipeElement,
                    data: pipeData,
                    x: x,
                    y: y,
                    connected: false,
                    timestamp: Date.now()
                };
                
                console.log('📝 Pipe info created:', pipeInfo);
                
                this.pipes.push(pipeInfo);
                
                // Store in history for undo
                if (!this.pipeHistory) this.pipeHistory = [];
                this.pipeHistory.push(pipeInfo);
                
                console.log('📊 Total pipes after placement:', this.pipes.length);
                
                // Play build sound
                this.playSound('buildSound');
                
                this.checkConnections();
            }
            
            checkConnections() {
                console.log('🔗 checkConnections() called');
                console.log('📊 Pipes before connection check:', this.pipes);
                
                // Clear all previous connections and connecting states
                this.pipes.forEach(pipe => {
                    pipe.connected = false;
                    pipe.element.classList.remove('connected');
                    pipe.element.classList.remove('flowing');
                    
                    // Clear any water flow styling
                    if (pipe.data.type === 'number') {
                        pipe.element.querySelector('div').style.background = 'linear-gradient(135deg, #4CAF50, #66BB6A)';
                        pipe.element.querySelector('div').style.borderColor = '#2E7D32';
                        pipe.element.querySelector('div').style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.4)';
                    } else if (pipe.data.type === 'operator') {
                        pipe.element.querySelector('div').style.background = 'linear-gradient(135deg, #FF9800, #FFB74D)';
                        pipe.element.querySelector('div').style.borderColor = '#F57C00';
                        pipe.element.querySelector('div').style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.4)';
                    }
                });
                this.connectedPipes = [];
                
                // Clear previous connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                // Create a grid-based connection system for more logical gameplay
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const tolerance = 20; // Allow some positioning flexibility
                
                console.log('📐 Grid config for connections:', gridConfig, 'Cell size:', cellSize);
                
                // Group pipes by grid position
                const gridPipes = {};
                this.pipes.forEach(pipe => {
                    const gridX = Math.floor(pipe.x / cellSize);
                    const gridY = Math.floor(pipe.y / cellSize);
                    const key = `${gridX},${gridY}`;
                    
                    if (!gridPipes[key]) gridPipes[key] = [];
                    gridPipes[key].push(pipe);
                });
                
                console.log('🗺️ Pipes grouped by grid position:', gridPipes);
                
                // Check for logical connections based on grid adjacency
                Object.keys(gridPipes).forEach(key => {
                    const [gridX, gridY] = key.split(',').map(Number);
                    const currentPipes = gridPipes[key];
                    
                    // Check adjacent grid cells
                    const adjacentKeys = [
                        `${gridX-1},${gridY}`, // left
                        `${gridX+1},${gridY}`, // right
                        `${gridX},${gridY-1}`, // top
                        `${gridX},${gridY+1}`  // bottom
                    ];
                    
                    adjacentKeys.forEach(adjKey => {
                        if (gridPipes[adjKey]) {
                            const adjacentPipes = gridPipes[adjKey];
                            
                            // Try to connect pipes between adjacent cells
                            currentPipes.forEach(pipe => {
                                adjacentPipes.forEach(adjPipe => {
                                    if (!pipe.connected && !adjPipe.connected) {
                                        console.log('🔍 Checking connection between:', pipe, 'and', adjPipe);
                                        // Check if these pipes can logically connect
                                        if (this.canPipesConnect(pipe, adjPipe)) {
                                            console.log('✅ Connecting pipes:', pipe, 'and', adjPipe);
                                            this.connectPipes(pipe, adjPipe);
                                        } else {
                                            console.log('❌ Pipes cannot connect:', pipe, 'and', adjPipe);
                                        }
                                    }
                                });
                            });
                        }
                    });
                });
                
                // Special case: Check if start pipe connects to first placed pipe
                if (this.pipes.length > 0 && this.startPipe) {
                    console.log('🚰 Checking start pipe connection to first placed pipe');
                    console.log('🚰 Start pipe:', this.startPipe);
                    console.log('🔢 First placed pipe:', this.pipes[0]);
                    
                    const firstPipe = this.pipes[0];
                    
                    // Convert pixel positions to grid positions consistently
                    const startGridX = Math.floor(this.startPipe.x / cellSize);
                    const startGridY = Math.floor(this.startPipe.y / cellSize);
                    const firstGridX = Math.floor(firstPipe.x / cellSize);
                    const firstGridY = Math.floor(firstPipe.y / cellSize);
                    
                    console.log('📍 Start grid position:', startGridX, startGridY);
                    console.log('📍 First pipe grid position:', firstGridX, firstGridY);
                    
                    // Check if they are adjacent (including diagonal for better connection detection)
                    const xDiff = Math.abs(startGridX - firstGridX);
                    const yDiff = Math.abs(startGridY - firstGridY);
                    
                    if ((xDiff === 1 && yDiff === 0) || (xDiff === 0 && yDiff === 1)) {
                        console.log('✅ Start pipe and first pipe are adjacent - marking as connected');
                        // Mark first pipe as connected to start
                        firstPipe.connected = true;
                        firstPipe.element.classList.add('connected');
                        this.connectedPipes.push(firstPipe);
                    } else {
                        console.log('❌ Start pipe and first pipe are not adjacent');
                        console.log('📏 Distance:', xDiff, yDiff);
                    }
                }
                
                console.log('🔗 Final connected pipes:', this.connectedPipes);
                
                // Apply water flow effect if pipes are connected
                if (this.connectedPipes.length > 0) {
                    setTimeout(() => this.applyWaterFlowEffect(), 100);
                }
                
                // Create continuous flow path across all connected pipes
                this.createContinuousFlowPath();
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            canPipesConnect(pipe1, pipe2) {
                console.log('🔍 canPipesConnect called for:', pipe1, 'and', pipe2);
                console.log('🔍 Pipe1 data:', pipe1.data);
                console.log('🔍 Pipe2 data:', pipe2.data);
                
                // Pipes can connect if they are adjacent, regardless of type
                // The mathematical validation happens during flow testing, not during connection establishment
                console.log('🔍 Pipes are adjacent - allowing connection');
                return true;
            }
            
            connectPipes(pipe1, pipe2) {
                pipe1.connected = true;
                pipe2.connected = true;
                pipe1.element.classList.add('connected');
                pipe2.element.classList.add('connected');
                
                // Add satisfying "click" effect
                this.createConnectionEffect(pipe1, pipe2);
                
                // Create visual connection line between pipes
                this.createConnectionLine(pipe1, pipe2);
                
                this.connectedPipes.push(pipe1, pipe2);
                this.animateWaterFlow(pipe1, pipe2);
            }
            
            createConnectionEffect(pipe1, pipe2) {
                const playArea = document.getElementById('playArea');
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const offset = cellSize / 2;
                
                // Create connection spark effect
                const spark = document.createElement('div');
                spark.className = 'connection-spark';
                spark.style.left = ((pipe1.x + pipe2.x) / 2 + offset) + 'px';
                spark.style.top = ((pipe1.y + pipe2.y) / 2 + offset) + 'px';
                playArea.appendChild(spark);
                
                // Remove spark after animation
                setTimeout(() => {
                    if (spark.parentNode) {
                        spark.parentNode.removeChild(spark);
                    }
                }, 600);
            }
            
            createConnectionLine(pipe1, pipe2) {
                const playArea = document.getElementById('playArea');
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const offset = cellSize / 2;
                
                // Calculate connection line position - pipes are now centered vertically
                const x1 = pipe1.x + offset; // center of pipe1
                const y1 = pipe1.y + offset; // center of pipe1
                const x2 = pipe2.x + offset; // center of pipe2
                const y2 = pipe2.y + offset; // center of pipe2
                
                const connectionLine = document.createElement('div');
                connectionLine.className = 'connection-line';
                connectionLine.style.position = 'absolute';
                connectionLine.style.left = Math.min(x1, x2) + 'px';
                connectionLine.style.top = Math.min(y1, y2) + 'px';
                connectionLine.style.width = Math.abs(x2 - x1) + 'px';
                connectionLine.style.height = Math.abs(y2 - y1) + 'px';
                connectionLine.style.zIndex = '1';
                
                // Determine if it's horizontal or vertical connection
                if (Math.abs(x2 - x1) > Math.abs(y2 - y1)) {
                    // Horizontal connection
                    connectionLine.style.height = '8px';
                    connectionLine.style.top = (Math.min(y1, y2) - 4) + 'px'; // Center the line on the pipe
                } else {
                    // Vertical connection
                    connectionLine.style.width = '8px';
                    connectionLine.style.left = (Math.min(x1, x2) - 4) + 'px'; // Center the line on the pipe
                }
                
                playArea.appendChild(connectionLine);
                
                // Store reference for later removal
                if (!this.connectionLines) this.connectionLines = [];
                this.connectionLines.push(connectionLine);
            }
            
            createContinuousFlowPath() {
                if (this.connectedPipes.length === 0) return;
                
                // Find all connected pipes and create a continuous flow
                const flowPath = this.findCompleteFlowPath();
                if (!flowPath || flowPath.length === 0) return;
                
                // Apply water flow effect to all pipes in the path
                flowPath.forEach((pipe, index) => {
                    const progress = index / (flowPath.length - 1);
                    const blueIntensity = Math.floor(progress * 255);
                    const color = `rgb(0, ${blueIntensity}, 255)`;
                    
                    if (pipe.data.type === 'number') {
                        pipe.element.querySelector('div').style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                        pipe.element.querySelector('div').style.borderColor = color;
                        pipe.element.querySelector('div').style.boxShadow = `0 0 20px ${color}`;
                    } else if (pipe.data.type === 'operator') {
                        pipe.element.querySelector('div').style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                        pipe.element.querySelector('div').style.borderColor = color;
                        pipe.element.querySelector('div').style.boxShadow = `0 0 20px ${color}`;
                    } else {
                        // For connector pipes, add a glow effect
                        pipe.element.style.filter = `drop-shadow(0 0 10px ${color})`;
                    }
                    
                    pipe.element.classList.add('flowing');
                });
            }
            
            findCompleteFlowPath() {
                // Find a continuous path through all connected pipes
                const visited = new Set();
                const path = [];
                
                // Start with any connected pipe
                const startPipe = this.connectedPipes[0];
                if (!startPipe) return [];
                
                const dfs = (pipe) => {
                    if (visited.has(pipe.timestamp)) return;
                    visited.add(pipe.timestamp);
                    path.push(pipe);
                    
                    // Find adjacent connected pipes
                    const adjacentPipes = this.findAdjacentConnectedPipes(pipe);
                    adjacentPipes.forEach(adjPipe => {
                        if (!visited.has(adjPipe.timestamp)) {
                            dfs(adjPipe);
                        }
                    });
                };
                
                dfs(startPipe);
                return path;
            }
            
            findAdjacentConnectedPipes(pipe) {
                const adjacentPipes = [];
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const pipeGridX = Math.floor(pipe.x / cellSize);
                const pipeGridY = Math.floor(pipe.y / cellSize);
                
                // Check all other connected pipes for adjacency
                this.connectedPipes.forEach(otherPipe => {
                    if (otherPipe.timestamp === pipe.timestamp) return;
                    
                    const otherGridX = Math.floor(otherPipe.x / cellSize);
                    const otherGridY = Math.floor(otherPipe.y / cellSize);
                    
                    // Check if pipes are adjacent (including diagonals for better flow)
                    const distance = Math.abs(otherGridX - pipeGridX) + Math.abs(otherGridY - pipeGridY);
                    if (distance === 1) {
                        adjacentPipes.push(otherPipe);
                    }
                });
                
                return adjacentPipes;
            }
            
            // Method to apply gradual blue water flow effect
            applyWaterFlowEffect() {
                if (this.connectedPipes.length === 0) return;
                
                // Find the path from start to end
                const path = this.findFlowPath();
                if (!path) return;
                
                // Apply gradual blue effect along the path
                path.forEach((pipe, index) => {
                    const progress = index / (path.length - 1);
                    const blueIntensity = Math.floor(progress * 255);
                    const color = `rgb(0, ${blueIntensity}, 255)`;
                    
                    // Add water flow class with custom color
                    pipe.element.style.background = `linear-gradient(135deg, ${color}, ${color}dd)`;
                    pipe.element.style.borderColor = color;
                    pipe.element.style.boxShadow = `0 0 20px ${color}`;
                    
                    // Add flowing water animation
                    pipe.element.classList.add('flowing');
                });
            }
            
            animateWaterFlow(pipe1, pipe2) {
                // Create water flow animation between connected pipes
                const playArea = document.getElementById('playArea');
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const offset = cellSize / 2;
                
                // Create multiple water droplets for better effect
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const flow = document.createElement('div');
                        flow.className = 'water-flow';
                        flow.style.left = (pipe1.x + offset + (Math.random() - 0.5) * 20) + 'px';
                        flow.style.top = (pipe1.y + offset + (Math.random() - 0.5) * 20) + 'px';
                        
                        playArea.appendChild(flow);
                        
                        // Animate water flow towards pipe2
                        const startX = parseFloat(flow.style.left);
                        const startY = parseFloat(flow.style.top);
                        const endX = pipe2.x + offset;
                        const endY = pipe2.y + offset;
                        
                        let progress = 0;
                        const animate = () => {
                            progress += 0.02;
                            if (progress <= 1) {
                                flow.style.left = (startX + (endX - startX) * progress) + 'px';
                                flow.style.top = (startY + (endY - startY) * progress) + 'px';
                                requestAnimationFrame(animate);
                            } else {
                                flow.remove();
                            }
                        };
                        animate();
                    }, i * 200);
                }
                
                // Check win condition after animation
                setTimeout(() => {
                    this.checkWinCondition();
                }, 1500);
            }
            
            checkWinCondition() {
                // This method is no longer used in the new flow-based system
                // Win condition is now checked during flow testing
                return;
            }
            
            celebrateWin() {
                this.score += 100 * this.level;
                this.updateDisplay();
                
                // Play celebration sound
                this.playSound('celebrateSound');
                
                // Create splash effect
                const playArea = document.getElementById('playArea');
                const splash = document.createElement('div');
                splash.className = 'splash';
                splash.style.left = '50%';
                splash.style.top = '50%';
                splash.style.transform = 'translate(-50%, -50%)';
                
                playArea.appendChild(splash);
                
                // Show success message
                const success = document.createElement('div');
                success.className = 'success-message';
                success.textContent = '🎉 Water flowing! 🎉';
                success.style.position = 'absolute';
                success.style.top = '20%';
                success.style.left = '50%';
                success.style.transform = 'translateX(-50%)';
                success.style.zIndex = '1000';
                
                playArea.appendChild(success);
                
                setTimeout(() => {
                    splash.remove();
                    success.remove();
                    this.nextLevel();
                }, 2000);
            }
            
            nextLevel() {
                this.level++;
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                // Clear connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            generateNewProblem() {
                const operators = ['+', '-', '×'];
                const operator = operators[Math.floor(Math.random() * operators.length)];
                let num1, num2, answer;
                
                switch (operator) {
                    case '+':
                        num1 = Math.floor(Math.random() * 10) + 1;
                        num2 = Math.floor(Math.random() * 10) + 1;
                        answer = num1 + num2;
                        break;
                    case '-':
                        num1 = Math.floor(Math.random() * 15) + 5;
                        num2 = Math.floor(Math.random() * num1) + 1;
                        answer = num1 - num2;
                        break;
                    case '×':
                        num1 = Math.floor(Math.random() * 6) + 2;
                        num2 = Math.floor(Math.random() * 6) + 2;
                        answer = num1 * num2;
                        break;
                }
                
                this.currentProblem = { num1, num2, operator, answer };
                document.getElementById('mathProblem').textContent = 
                    `${num1} ${operator} ${num2} = ?`;
            }
            
            clearPlayArea() {
                document.getElementById('playArea').innerHTML = '';
            }
            
            resetLevel() {
                this.pressure = 0;
                this.pipes = [];
                this.connectedPipes = [];
                this.pipeHistory = [];
                this.answerPipes = [];
                
                // Clear connection lines
                if (this.connectionLines) {
                    this.connectionLines.forEach(line => {
                        if (line.parentNode) line.parentNode.removeChild(line);
                    });
                    this.connectionLines = [];
                }
                
                this.createNewPuzzle();
                this.startPressureTimer();
                this.updateUndoButton();
            }
            
            undoLastPipe() {
                if (!this.pipeHistory || this.pipeHistory.length === 0) {
                    alert('No pipes to undo!');
                    return;
                }
                
                const lastPipe = this.pipeHistory.pop();
                
                // Remove from pipes array
                const index = this.pipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (index > -1) {
                    this.pipes.splice(index, 1);
                }
                
                // Remove from connected pipes if it was connected
                const connectedIndex = this.connectedPipes.findIndex(p => p.timestamp === lastPipe.timestamp);
                if (connectedIndex > -1) {
                    this.connectedPipes.splice(connectedIndex, 1);
                }
                
                // Remove the DOM element
                if (lastPipe.element && lastPipe.element.parentNode) {
                    lastPipe.element.parentNode.removeChild(lastPipe.element);
                }
                
                // Recheck connections since we removed a pipe
                this.checkConnections();
                
                // Update undo button state
                this.updateUndoButton();
            }
            
            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (this.pipeHistory && this.pipeHistory.length > 0) {
                    undoBtn.disabled = false;
                    undoBtn.style.opacity = '1';
                } else {
                    undoBtn.disabled = true;
                    undoBtn.style.opacity = '0.5';
                }
            }
            
            showGridHighlights() {
                const playArea = document.getElementById('playArea');
                const rect = playArea.getBoundingClientRect();
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                
                // Clear existing highlights
                this.clearGridHighlights();
                
                // Create grid highlights
                for (let x = 0; x < rect.width; x += cellSize) {
                    for (let y = 0; y < rect.height; y += cellSize) {
                        const highlight = document.createElement('div');
                        highlight.className = 'grid-highlight';
                        highlight.style.left = x + 'px';
                        highlight.style.top = y + 'px';
                        playArea.appendChild(highlight);
                    }
                }
            }
            
            clearGridHighlights() {
                const highlights = document.querySelectorAll('.grid-highlight');
                highlights.forEach(h => h.remove());
            }
            
            showHint() {
                // More helpful hint system for the new expression system
                let hint = '';
                if (this.currentExpression.type === 'simple') {
                    hint = `You need to route from the start pipe (${this.currentExpression.a}) through the ${this.currentExpression.op} operator and the number ${this.currentExpression.b}. The answer should be ${this.correctAnswer}.`;
                } else if (this.currentExpression.type === 'leftGrouped') {
                    hint = `First calculate (${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}), then apply ${this.currentExpression.op2} ${this.currentExpression.c}. Remember: ${this.currentExpression.op1} happens first!`;
                } else if (this.currentExpression.type === 'rightGrouped') {
                    hint = `First calculate (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}), then apply ${this.currentExpression.a} ${this.currentExpression.op1}. Remember: ${this.currentExpression.op2} happens first!`;
                } else if (this.currentExpression.type === 'precedence') {
                    hint = `Remember order of operations: × and ÷ happen before + and −. So calculate ${this.currentExpression.b} × ${this.currentExpression.c} first, then add ${this.currentExpression.a}, then subtract ${this.currentExpression.d}.`;
                }
                alert(hint);
            }
            
            startPressureTimer() {
                if (this.timer) clearInterval(this.timer);
                
                const config = this.getGameConfig();
                this.timer = setInterval(() => {
                    this.pressure += config.pressureRate;
                    this.updateDisplay();
                    
                    if (this.pressure >= this.maxPressure) {
                        this.gameOver();
                    }
                }, 1000);
            }
            
            testFlow() {
                console.log('🌊 testFlow() called');
                if (this.pipes.length === 0) {
                    console.log('❌ No pipes placed');
                    alert('Place some pipes first!');
                    return;
                }
                
                console.log('📊 Pipes available for flow test:', this.pipes);
                console.log('🎯 Current expression:', this.currentExpression);
                console.log('✅ Correct answer:', this.correctAnswer);
                
                // Play test sound
                this.playSound('testSound');
                
                // Simulate water flow through the pipe network
                this.animateFlow();
            }
            
            animateFlow() {
                console.log('🌊 animateFlow() called');
                const playArea = document.getElementById('playArea');
                
                // Find the path from start to answer pipes
                const path = this.findFlowPath();
                console.log('🛤️ Path found for animation:', path);
                
                if (!path) {
                    console.log('❌ No valid path found for animation');
                    this.showFlowError('No valid path found!');
                    return;
                }
                
                console.log('✅ Valid path found, starting animation');
                
                // Calculate the final value by following the pipe path and applying operations
                let finalValue = this.calculatePathValue(path);
                console.log('🧮 Calculated final value from path:', finalValue);
                
                // Apply water flow styling to start pipe
                if (this.startPipe && this.startPipe.element) {
                    this.applyWaterFlowStyling({ element: this.startPipe.element, timestamp: 'start' });
                }
                
                // Animate water flow step by step
                let currentValue = this.startPipe.value;
                let step = 0;
                
                console.log('🚰 Starting flow with value:', currentValue);
                
                const animateStep = () => {
                    if (step >= path.length) {
                        console.log('🏁 Animation complete, final value:', finalValue);
                        this.checkFlowResult(finalValue);
                        // Reset all pipes to normal appearance
                        this.resetPipeAppearances();
                        return;
                    }
                    
                    const pipe = path[step];
                    console.log('➡️ Animating step', step, 'with pipe:', pipe);
                    
                    // Apply water flow styling to current pipe
                    this.applyWaterFlowStyling(pipe);
                    
                    const flowElement = this.createFlowElement(pipe.x, pipe.y);
                    playArea.appendChild(flowElement);
                    
                    step++;
                    
                    setTimeout(() => {
                        flowElement.remove();
                        animateStep();
                    }, 500);
                };
                
                animateStep();
            }
            
            applyWaterFlowStyling(pipe) {
                // Find the DOM element for this pipe by timestamp or position
                let pipeElement = null;
                
                // First try to find by timestamp if the pipe has one
                if (pipe.timestamp) {
                    pipeElement = document.querySelector(`[data-pipe-id="${pipe.timestamp}"]`);
                }
                
                // If not found by timestamp, try to find by position
                if (!pipeElement) {
                    console.log('⚠️ Could not find pipe element by timestamp, trying fallback');
                    const allPipes = document.querySelectorAll('.placed-pipe');
                    let foundElement = null;
                    
                    allPipes.forEach(element => {
                        const elementX = parseInt(element.style.left);
                        const elementY = parseInt(element.style.top);
                        if (Math.abs(elementX - pipe.x) < 5 && Math.abs(elementY - pipe.y) < 5) {
                            foundElement = element;
                        }
                    });
                    
                    if (!foundElement) {
                        console.log('❌ Could not find pipe element for styling');
                        return;
                    }
                    
                    pipeElement = foundElement;
                }
                
                console.log('✅ Found pipe element for water flow styling:', pipeElement);
                
                // Apply water flow styling
                pipeElement.style.filter = 'hue-rotate(200deg) brightness(1.2)';
                pipeElement.style.boxShadow = '0 0 20px rgba(33, 150, 243, 0.8)';
                pipeElement.style.border = '3px solid #2196F3';
                pipeElement.style.transform = 'scale(1.1)';
                pipeElement.style.transition = 'all 0.3s ease';
                
                // Add water ripple effect
                this.createWaterRippleEffect(pipeElement);
            }
            
            createWaterRippleEffect(pipeElement) {
                const ripple = document.createElement('div');
                ripple.className = 'water-ripple';
                ripple.style.cssText = `
                    position: absolute;
                    top: -10px;
                    left: -10px;
                    right: -10px;
                    bottom: -10px;
                    border: 2px solid #2196F3;
                    border-radius: 50%;
                    animation: waterRippleExpand 1s ease-out forwards;
                    pointer-events: none;
                    z-index: 100;
                `;
                
                pipeElement.appendChild(ripple);
                
                // Remove ripple after animation
                setTimeout(() => {
                    if (ripple.parentNode) {
                        ripple.parentNode.removeChild(ripple);
                    }
                }, 1000);
            }
            
            resetPipeAppearances() {
                // Reset all placed pipes to normal appearance
                document.querySelectorAll('.placed-pipe').forEach(pipe => {
                    pipe.style.filter = '';
                    pipe.style.boxShadow = '';
                    pipe.style.border = '';
                    pipe.style.transform = '';
                    pipe.style.transition = '';
                });
                
                // Reset start pipe to normal appearance
                if (this.startPipe && this.startPipe.element) {
                    this.startPipe.element.style.filter = '';
                    this.startPipe.element.style.boxShadow = '';
                    this.startPipe.element.style.border = '';
                    this.startPipe.element.style.transform = '';
                    this.startPipe.element.style.transition = '';
                }
                
                // Reset answer pipe to normal appearance
                if (this.answerPipe && this.answerPipe.element) {
                    this.answerPipe.element.style.filter = '';
                    this.answerPipe.element.style.boxShadow = '';
                    this.answerPipe.element.style.border = '';
                    this.answerPipe.element.style.transform = '';
                    this.answerPipe.element.style.transition = '';
                }
            }
            
            calculatePathValue(path) {
                console.log('🧮 calculatePathValue called with path:', path);
                
                if (path.length === 0) return this.startPipe.value;
                
                // For basic difficulty, we expect: start → operator → number
                if (this.difficulty === 'basic' && this.currentExpression.type === 'simple') {
                    console.log('🧮 Basic difficulty - simple expression:', this.currentExpression);
                    
                    // Find the operator and number in the path
                    const operatorPipe = path.find(p => p.data && p.data.type === 'operator');
                    const numberPipe = path.find(p => p.data && p.data.type === 'number');
                    
                    if (operatorPipe && numberPipe) {
                        const startValue = this.startPipe.value;
                        const operator = operatorPipe.data.operation;
                        const numberValue = numberPipe.data.value;
                        
                        console.log('🧮 Found operator:', operator, 'and number:', numberValue);
                        
                        const result = this.applyOperation(startValue, numberValue, operator);
                        console.log('🧮 Calculated result:', startValue, operator, numberValue, '=', result);
                        return result;
                    } else {
                        console.log('⚠️ Missing operator or number in path');
                        return this.startPipe.value;
                    }
                }
                
                // For other difficulties, follow the path more complexly
                let currentValue = this.startPipe.value;
                let i = 0;
                
                while (i < path.length) {
                    const pipe = path[i];
                    
                    if (pipe.data && pipe.data.type === 'operator') {
                        const nextPipe = path[i + 1];
                        if (nextPipe && nextPipe.data && nextPipe.data.type === 'number') {
                            const oldValue = currentValue;
                            currentValue = this.applyOperation(currentValue, nextPipe.data.value, pipe.data.operation);
                            console.log('🧮 Applied operation:', oldValue, pipe.data.operation, nextPipe.data.value, '=', currentValue);
                            i += 2; // Skip both operator and number
                        } else {
                            i++; // Skip operator if no number follows
                        }
                    } else {
                        i++; // Skip non-operator pipes
                    }
                }
                
                return currentValue;
            }
            
            findFlowPath() {
                console.log('🔍 findFlowPath() called');
                console.log('📊 Current pipes:', this.pipes);
                console.log('🔗 Connected pipes:', this.connectedPipes);
                console.log('🎯 Answer pipes:', this.answerPipes);
                
                // Improved pathfinding that handles more creative pipe setups
                const path = [];
                const visited = new Set();
                
                // Find all connected pipes and create a network graph
                const pipeNetwork = this.buildPipeNetwork();
                console.log('🌐 Pipe network built:', pipeNetwork);
                
                // Try to find path from start to any answer pipe
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                console.log('📐 Grid config:', gridConfig, 'Cell size:', cellSize);
                
                // Find start pipe by looking for the start pipe element in the DOM
                let startPipe = null;
                const startElement = document.querySelector('.start-pipe');
                console.log('🚰 Start element found:', startElement);
                
                if (startElement) {
                    // Look for start pipe in the pipes array by type
                    startPipe = this.pipes.find(p => p.data && p.data.type === 'start');
                    console.log('🔍 Start pipe found in pipes array by type:', startPipe);
                    
                    // Fallback: look by position
                    if (!startPipe) {
                        const startX = parseInt(startElement.style.left);
                        const startY = parseInt(startElement.style.top);
                        console.log('📍 Start position:', startX, startY);
                        
                        startPipe = this.pipes.find(p => 
                            Math.abs(p.x - startX) < cellSize/2 && Math.abs(p.y - startY) < cellSize/2
                        );
                        console.log('🔍 Start pipe found in pipes array by position:', startPipe);
                    }
                }
                
                // Fallback: look for pipe at start position
                if (!startPipe) {
                    startPipe = this.pipes.find(p => p.x === 0 && p.y === Math.floor(gridConfig.height / 2) * cellSize);
                    console.log('🔄 Fallback start pipe:', startPipe);
                }
                
                if (!startPipe) {
                    console.log('❌ No start pipe found!');
                    return null;
                }
                
                console.log('✅ Start pipe identified:', startPipe);
                
                // If we have connected pipes, try to build a path through them
                if (this.connectedPipes.length > 0) {
                    console.log('🔗 Building path through connected pipes...');
                    
                    // Find the start pipe in connected pipes (it should be there now)
                    const connectedStartPipe = this.connectedPipes.find(p => p.data && p.data.type === 'start');
                    if (connectedStartPipe) {
                        console.log('🚰 Found start pipe in connected pipes:', connectedStartPipe);
                        
                        // Start with the start pipe
                        path.push(connectedStartPipe);
                        visited.add(connectedStartPipe.timestamp);
                        
                        // Find the next connected pipe
                        let currentPipe = connectedStartPipe;
                        let attempts = 0;
                        const maxAttempts = this.connectedPipes.length;
                        
                        while (attempts < maxAttempts && path.length < this.connectedPipes.length) {
                            const nextPipe = this.findNextConnectedPipe(currentPipe, visited);
                            if (nextPipe && !visited.has(nextPipe.timestamp)) {
                                console.log('➡️ Next connected pipe:', nextPipe);
                                path.push(nextPipe);
                                visited.add(nextPipe.timestamp);
                                currentPipe = nextPipe;
                            } else {
                                console.log('🛑 No more connected pipes found');
                                break;
                            }
                            attempts++;
                        }
                        
                        console.log('🛤️ Path built through connected pipes:', path);
                        
                        // Check if this path leads to an answer
                        if (path.length > 1) {
                            console.log('✅ Valid path found through connected pipes!');
                            return path;
                        }
                    } else {
                        console.log('❌ Start pipe not found in connected pipes');
                    }
                }
                
                // Fallback: Try to reach any answer pipe using network
                console.log('🔄 Trying network-based pathfinding...');
                for (const answerPipe of this.answerPipes) {
                    console.log('🎯 Trying to reach answer pipe:', answerPipe);
                    const pathToAnswer = this.findPathToAnswer(startPipe, answerPipe, pipeNetwork, visited);
                    if (pathToAnswer) {
                        console.log('✅ Network path found to answer:', pathToAnswer);
                        return pathToAnswer;
                    }
                }
                
                console.log('❌ No valid path found through any method');
                return null;
            }
            
            findNextConnectedPipe(currentPipe, visited) {
                // Find the next pipe that is connected to the current one
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const currentGridX = Math.floor(currentPipe.x / cellSize);
                const currentGridY = Math.floor(currentPipe.y / cellSize);
                
                // Look for pipes in adjacent grid cells
                for (const pipe of this.pipes) {
                    if (visited.has(pipe.timestamp)) continue;
                    
                    const pipeGridX = Math.floor(pipe.x / cellSize);
                    const pipeGridY = Math.floor(pipe.y / cellSize);
                    
                    // Check if pipes are adjacent
                    if ((Math.abs(pipeGridX - currentGridX) === 1 && pipeGridY === currentGridY) ||
                        (Math.abs(pipeGridY - currentGridY) === 1 && pipeGridX === currentGridX)) {
                        return pipe;
                    }
                }
                
                return null;
            }
            
            buildPipeNetwork() {
                const network = new Map();
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                
                // Build adjacency map for all pipes
                this.pipes.forEach(pipe => {
                    const key = `${Math.floor(pipe.x / cellSize)},${Math.floor(pipe.y / cellSize)}`;
                    if (!network.has(key)) {
                        network.set(key, []);
                    }
                    
                    // Check adjacent grid cells for other pipes
                    const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                    directions.forEach(([dx, dy]) => {
                        const adjKey = `${Math.floor(pipe.x / cellSize) + dx},${Math.floor(pipe.y / cellSize) + dy}`;
                        const adjPipe = this.pipes.find(p => 
                            Math.floor(p.x / cellSize) === Math.floor(pipe.x / cellSize) + dx && 
                            Math.floor(p.y / cellSize) === Math.floor(pipe.y / cellSize) + dy
                        );
                        
                        if (adjPipe) {
                            network.get(key).push(adjPipe);
                        }
                    });
                });
                
                return network;
            }
            
            findPathToAnswer(startPipe, answerPipe, network, visited) {
                const path = [];
                const localVisited = new Set();
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                
                const dfs = (currentPipe, targetPipe) => {
                    const key = `${Math.floor(currentPipe.x / cellSize)},${Math.floor(currentPipe.y / cellSize)}`;
                    if (localVisited.has(key)) return false;
                    localVisited.add(key);
                    
                    path.push(currentPipe);
                    
                    if (currentPipe === targetPipe) return true;
                    
                    // Get adjacent pipes from network
                    const adjKey = `${Math.floor(currentPipe.x / cellSize)},${Math.floor(currentPipe.y / cellSize)}`;
                    const adjacentPipes = network.get(adjKey) || [];
                    
                    for (const adjPipe of adjacentPipes) {
                        if (dfs(adjPipe, targetPipe)) return true;
                    }
                    
                    path.pop();
                    return false;
                };
                
                if (dfs(startPipe, answerPipe)) {
                    return path;
                }
                
                return null;
            }
            
            createFlowElement(x, y) {
                const flow = document.createElement('div');
                flow.className = 'water-flow';
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const offset = cellSize / 2;
                flow.style.left = (x + offset) + 'px';
                flow.style.top = (y + offset) + 'px';
                return flow;
            }
            
            checkFlowResult(finalValue) {
                const correctAnswer = this.answerPipes.find(p => p.isCorrect);
                
                if (!correctAnswer) {
                    console.log('❌ No correct answer pipe found');
                    this.showFlowError('No correct answer pipe found!');
                    return;
                }
                
                if (finalValue === correctAnswer.value) {
                    // Highlight the correct answer pipe
                    this.highlightCorrectAnswer();
                    this.celebrateWin();
                } else {
                    this.showFlowError(`Flow reached value ${finalValue}, but correct answer is ${correctAnswer.value}`);
                }
            }
            
            highlightCorrectAnswer() {
                // Find and highlight the correct answer pipe
                this.answerPipes.forEach(answerPipe => {
                    const answerElement = document.querySelector(`[data-correct-answer="true"]`);
                    if (answerElement) {
                        answerElement.className = 'answer-pipe correct';
                    }
                });
            }
            
            showFlowError(message) {
                this.pressure += 20; // Increase pressure for failed attempt
                alert(message);
                this.updateDisplay();
            }
            
            gameOver() {
                clearInterval(this.timer);
                this.gameActive = false;
                
                const gameOver = document.createElement('div');
                gameOver.className = 'game-over';
                gameOver.innerHTML = `
                    <h2>Pressure Too High!</h2>
                    <p>Final Score: ${this.score}</p>
                    <p>Level Reached: ${this.level}</p>
                    <p>Stars Earned: ${this.stars}</p>
                    <button class="control-btn" onclick="location.reload()">Play Again</button>
                `;
                
                document.getElementById('playArea').appendChild(gameOver);
            }
            
            updateDisplay() {
                document.getElementById('level').textContent = this.level;
                document.getElementById('score').textContent = this.score;
                document.getElementById('stars').textContent = this.stars;
                document.getElementById('pressure').textContent = Math.round(this.pressure);
                
                // Update sidebar display elements
                const levelDisplay = document.getElementById('levelDisplay');
                const scoreDisplay = document.getElementById('scoreDisplay');
                const pressureDisplay = document.getElementById('pressureDisplay');
                
                if (levelDisplay) levelDisplay.textContent = this.level;
                if (scoreDisplay) scoreDisplay.textContent = this.score;
                if (pressureDisplay) pressureDisplay.textContent = Math.round(this.pressure) + '%';
                
                // Update pressure bar
                const pressureFill = document.getElementById('pressureFill');
                if (pressureFill) {
                    pressureFill.style.width = (this.pressure / this.maxPressure * 100) + '%';
                }
                
                // Update expression display
                if (this.currentExpression) {
                    let expressionText = '';
                    if (this.currentExpression.type === 'simple') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op} ${this.currentExpression.b} = ?`;
                    } else if (this.currentExpression.type === 'leftGrouped') {
                        expressionText = `(${this.currentExpression.a} ${this.currentExpression.op1} ${this.currentExpression.b}) ${this.currentExpression.op2} ${this.currentExpression.c} = ?`;
                    } else if (this.currentExpression.type === 'rightGrouped') {
                        expressionText = `${this.currentExpression.a} ${this.currentExpression.op1} (${this.currentExpression.b} ${this.currentExpression.op2} ${this.currentExpression.c}) = ?`;
                    } else if (this.currentExpression.type === 'precedence') {
                        expressionText = `${this.currentExpression.a} + ${this.currentExpression.b} × ${this.currentExpression.c} - ${this.currentExpression.d} = ?`;
                    }
                    document.getElementById('mathProblem').textContent = expressionText;
                }
            }

            handleInventoryTap(e) {
                const pipeElement = e.target.closest('.pipe-piece');
                if (!pipeElement) return;
                
                e.preventDefault();
                console.log('📱 Inventory tap detected');
                
                // Get pipe data
                const pipeData = JSON.parse(pipeElement.dataset.pipeType);
                console.log('📱 Selected pipe:', pipeData);
                
                // Update selected pipe
                this.selectedPipe = pipeData;
                
                // Visual feedback - highlight selected pipe
                document.querySelectorAll('.pipe-piece').forEach(p => p.classList.remove('selected'));
                pipeElement.classList.add('selected');
                
                // Show placement hint
                this.showPlacementHint();
            }
            
            handleGridTap(e) {
                if (!this.selectedPipe) return;
                
                e.preventDefault();
                console.log('📱 Grid tap detected');
                
                const playArea = document.getElementById('playArea');
                const rect = playArea.getBoundingClientRect();
                const rawX = e.clientX - rect.left;
                const rawY = e.clientY - rect.top;
                
                // Snap to grid
                const gridConfig = this.getGridConfig();
                const cellSize = gridConfig.cellSize;
                const gridX = Math.floor(rawX / cellSize);
                const gridY = Math.floor(rawY / cellSize);
                
                // Convert back to pixel coordinates for placement
                const x = gridX * cellSize;
                const y = gridY * cellSize;
                
                console.log('📱 Placing pipe at grid position:', gridX, gridY, 'pixel position:', x, y);
                
                // Check if position is valid (not occupied)
                const isOccupied = this.pipes.some(pipe => 
                    Math.abs(pipe.x - x) < cellSize/2 && Math.abs(pipe.y - y) < cellSize/2
                );
                
                if (isOccupied) {
                    console.log('❌ Position occupied, cannot place pipe');
                    this.showPlacementError('Position occupied!');
                    return;
                }
                
                // Animate pipe from inventory to grid
                this.animatePipePlacement(this.selectedPipe, x, y);
                
                // Clear selection
                this.clearPipeSelection();
            }
            
            handleDoubleTap(e) {
                const placedPipe = e.target.closest('.placed-pipe');
                if (!placedPipe) return;
                
                e.preventDefault();
                console.log('📱 Double tap detected on placed pipe');
                
                // Find the pipe in our data
                const rect = placedPipe.getBoundingClientRect();
                const playArea = document.getElementById('playArea');
                const playRect = playArea.getBoundingClientRect();
                const x = rect.left - playRect.left;
                const y = rect.top - playRect.top;
                
                const pipe = this.pipes.find(p => 
                    Math.abs(p.x - x) < 10 && Math.abs(p.y - y) < 10
                );
                
                if (pipe) {
                    this.rotatePipe(pipe);
                }
            }
            
            animatePipePlacement(pipeData, x, y) {
                console.log('🎬 Animating pipe placement from inventory to:', x, y);
                
                // Create a temporary animated pipe element
                const animatedPipe = document.createElement('div');
                animatedPipe.className = 'pipe-piece animated-placement';
                animatedPipe.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    width: 60px;
                    height: 60px;
                    z-index: 1000;
                    pointer-events: none;
                    transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                `;
                
                // Set initial position (center of inventory)
                const inventory = document.getElementById('pipeInventory');
                const inventoryRect = inventory.getBoundingClientRect();
                const playArea = document.getElementById('playArea');
                const playRect = playArea.getBoundingClientRect();
                
                const startX = inventoryRect.left - playRect.left + inventoryRect.width / 2 - 30;
                const startY = inventoryRect.top - playRect.top + inventoryRect.height / 2 - 30;
                
                animatedPipe.style.left = startX + 'px';
                animatedPipe.style.top = startY + 'px';
                
                // Add pipe content
                if (pipeData.type === 'number') {
                    animatedPipe.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #4CAF50, #66BB6A);
                            border: 3px solid #2E7D32;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.2rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.symbol}
                        </div>
                    `;
                } else if (pipeData.type === 'operator') {
                    animatedPipe.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            display: flex; 
                            align-items: center; 
                            justify-content: center; 
                            background: linear-gradient(135deg, #FF9800, #FFB74D);
                            border: 3px solid #F57C00;
                            border-radius: 15px;
                            color: white;
                            font-size: 1.4rem;
                            font-weight: bold;
                            text-shadow: 1px 1px 2px #000;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        ">
                            ${pipeData.operation}
                        </div>
                    `;
                } else {
                    // Connector pipe
                    animatedPipe.innerHTML = `
                        <div style="
                            width: 100%; 
                            height: 100%; 
                            background: linear-gradient(135deg, #2196F3, #64B5F6);
                            border: 3px solid #1976D2;
                            border-radius: 15px;
                            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                        "></div>
                    `;
                }
                
                // Add to play area
                playArea.appendChild(animatedPipe);
                
                // Animate to final position
                setTimeout(() => {
                    animatedPipe.style.left = x + 'px';
                    animatedPipe.style.top = y + 'px';
                    animatedPipe.style.transform = 'scale(1.1)';
                }, 50);
                
                // Complete animation and place pipe
                setTimeout(() => {
                    animatedPipe.remove();
                    this.placePipe(pipeData, x, y);
                }, 550);
            }
            
            showPlacementHint() {
                // Remove existing hint
                this.clearPlacementHint();
                
                const hint = document.createElement('div');
                hint.id = 'placementHint';
                hint.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 10px;
                    font-size: 16px;
                    z-index: 10000;
                    pointer-events: none;
                    animation: fadeInOut 2s ease-in-out;
                `;
                hint.textContent = 'Tap a grid cell to place the pipe';
                
                // Add CSS animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(hint);
                
                // Auto-remove after animation
                setTimeout(() => {
                    this.clearPlacementHint();
                }, 2000);
            }
            
            clearPlacementHint() {
                const hint = document.getElementById('placementHint');
                if (hint) hint.remove();
            }
            
            showPlacementError(message) {
                const error = document.createElement('div');
                error.id = 'placementError';
                error.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(244, 67, 54, 0.9);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 10px;
                    font-size: 16px;
                    z-index: 10000;
                    pointer-events: none;
                    animation: shake 0.5s ease-in-out;
                `;
                error.textContent = message;
                
                // Add shake animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes shake {
                        0%, 100% { transform: translate(-50%, -50%); }
                        25% { transform: translate(-52%, -50%); }
                        75% { transform: translate(-48%, -50%); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(error);
                
                // Auto-remove after animation
                setTimeout(() => {
                    error.remove();
                }, 1500);
            }
            
            clearPipeSelection() {
                this.selectedPipe = null;
                document.querySelectorAll('.pipe-piece').forEach(p => p.classList.remove('selected'));
                this.clearPlacementHint();
            }

            rotatePipe(pipe) {
                console.log('🔄 Rotating pipe:', pipe);
                
                // Find the pipe element
                const pipeElement = pipe.element;
                if (!pipeElement) {
                    console.log('❌ No pipe element found for rotation');
                    return;
                }
                
                // Get current rotation
                const currentRotation = pipe.rotation || 0;
                const newRotation = (currentRotation + 90) % 360;
                
                // Update pipe data
                pipe.rotation = newRotation;
                
                // Apply rotation to element
                pipeElement.style.transform = `rotate(${newRotation}deg)`;
                
                console.log('✅ Pipe rotated to:', newRotation, 'degrees');
            }
            
            newLevel() {
                console.log('🆕 Starting new level');
                this.nextLevel();
            }
        }
        
        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PipeDream();
        });
    </script>

    <script>
        function svgForPipe(type = 'straight-h', rot = 0, active = false) {
            const strokeClass = 'pipe-stroke' + (active ? ' glow' : '');
            const paths = {
                'straight-h': `<path class="${strokeClass}" d="M12 50 H88"/>`,
                'straight-v': `<path class="${strokeClass}" d="M50 12 V88"/>`,
                'elbow': `<path class="${strokeClass}" d="M12 50 H50 V12"/>`,
                'tee': `
                    <path class="${strokeClass}" d="M12 50 H88"/>
                    <path class="${strokeClass}" d="M50 50 V12"/>`,
                'cross': `
                    <path class="${strokeClass}" d="M12 50 H88"/>
                    <path class="${strokeClass}" d="M50 12 V88"/>`
            };
            const inner = {
                'straight-h': `<path class="pipe-inner" d="M12 50 H88"/>`,
                'straight-v': `<path class="pipe-inner" d="M50 12 V88"/>`,
                'elbow': `<path class="pipe-inner" d="M12 50 H50 V12"/>`,
                'tee': `
                    <path class="pipe-inner" d="M12 50 H88"/>
                    <path class="pipe-inner" d="M50 50 V12"/>`,
                'cross': `
                    <path class="pipe-inner" d="M12 50 H88"/>
                    <path class="pipe-inner" d="M50 12 V88"/>`
            };
            const endcaps = {
                'straight-h': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/>`,
                'straight-v': `<circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`,
                'elbow': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
                'tee': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/>`,
                'cross': `<circle class="pipe-endcap" cx="12" cy="50" r="3"/><circle class="pipe-endcap" cx="88" cy="50" r="3"/><circle class="pipe-endcap" cx="50" cy="12" r="3"/><circle class="pipe-endcap" cx="50" cy="88" r="3"/>`
            };
            return `
        <svg viewBox="0 0 100 100">
            <g transform="rotate(${rot} 50 50)">
                ${paths[type] || paths['straight-h']}
                ${inner[type] || ''}
                ${endcaps[type] || ''}
            </g>
        </svg>`;
        }
        function renderPipeInto(el, type, rot = 0, active = false) {
            el.innerHTML = svgForPipe(type, rot, active);
        }
    </script>
    
    <script src="navigation.js"></script>
   
</body>
</html>

