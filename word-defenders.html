<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Word Defenders</title>
<style>
:root {
  --green: #0f0;
  --yellow: #ff0;
  --red: #f00;
  --bg: #000;
}
html, body { height: 100%; margin:0; padding:0; background: var(--bg); font-family: monospace; color: var(--green); overflow:hidden; }
#container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; padding:20px; position:relative; }
#gameNav, 
#gameNav a {
  display: block;
  margin-top: 5px;
  text-transform: uppercase;
  color: #0f0;
  text-decoration: none;
}

#gameNav a.active {
  color: #ff0;       /* highlight color */
  font-weight: bold;  /* optional emphasis */
  text-decoration: underline;
}
#game { border: 4px solid var(--green); width: 540px; height: 640px; background: var(--bg); image-rendering: pixelated; display: block; position:relative; z-index:1; }
#sidebar { width:450px; display:flex; flex-direction:column; gap:10px; }
#title { text-transform: uppercase; font-size: 2rem; color: #ff0; text-shadow: 0 0 8px #f00; text-align: center; }
#scoreboard { border: 2px solid var(--green); padding:8px; font-size:0.9rem; }
.section-title { color: var(--yellow); font-weight:bold; margin-bottom:4px; }
#controls { font-size:0.9rem; }
.pill { border:1px solid var(--green); padding:6px 8px; display:inline-block; cursor:pointer; margin-right:4px; user-select:none; }
.toggle input { accent-color: var(--green); }
#wordList { width:100%; height:80px; background:#001100; color: var(--green); border:1px solid var(--green); padding:6px; font-family:monospace; }
input[type=range] { width:100%; }
#quotes { margin-top:8px; font-size:0.9rem; height:24px; text-align:center; }

/* Full-screen rocket/fireworks overlay on top of everything */
#rocketOverlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:999; }

/* Splash screen */
#splashScreen { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); color:#fff; font-size:2rem; display:none; justify-content:center; align-items:center; flex-direction:column; text-align:center; z-index:1000; }
#splashScreen button { margin-top:20px; padding:10px 20px; font-size:1rem; cursor:pointer; }
</style>
</head>
<body>
<div id="splashScreen"><div id="splashText">Level Complete!</div><button id="splashBtn">Next Level</button></div>
<div id="container">
  <nav id="gameNav" style="padding:10px; background:#111; color:#0f0; font-family:monospace;">
    <strong>Games:</strong>
  </nav>
    <script src="navigation.js"></script>
  <canvas id="game" width="540" height="640"></canvas>
  <div id="sidebar">
    <div id="title">WORD DEFENDERS</div>
    <div id="scoreboard">
      <div class="section-title">SCORE</div>
      <div>Score: <span id="score">0</span> | Words Left: <span id="wordsLeft">0</span> | WPM: <span id="wpm">0</span></div>
      <div>Timer: <span id="timerDisplay">0:00</span></div>
    </div>
    <div id="controls">
      <div class="section-title">CONTROLS</div>
      1 / ←: Move Left<br>
      2 / →: Move Right<br>
      Type letters: Shoot word in lane<br>
      Space: Start / Pause<br>
      0: Reset
    </div>
    <div style="display:flex; gap:10px;">
      <div>
        <div class="section-title">SPEED</div>
        <input type="range" id="speedSlider" min="1" max="10" step="1" value="2">
        <div id="speedVal">2</div>
      </div>
      <div>
        <div class="section-title">LANES</div>
        <input type="range" id="laneSlider" min="1" max="8" step="1" value="4">
        <div id="laneVal">4</div>
      </div>
    </div>
    <div>
      <div class="section-title">WORD LIST</div>
      <select id="wordListSelect"></select>
      <textarea id="wordList"></textarea><br>
      <button class="pill" id="applyWords">Apply</button>
      <button class="pill" id="resetWords">Default</button>
    </div>
    <div>
      <div class="section-title">TIMER</div>
      <label class="pill"><input type="checkbox" id="timerToggle"> Timer Mode</label>
      <input type="range" id="timerSlider" min="1" max="5" step="1" value="3">
      <div id="timerVal">3 min</div>
    </div>
    <div id="quotes"></div>
  </div>
  <canvas id="rocketOverlay" width="1200" height="720"></canvas>
</div>
<script>
(() => {
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
let lanes = 4, playerLane = 0; // Start in leftmost lane
let laneW = W/lanes, floorY = H-48;

let score=0, lives=3, running=true, gameOver=false;
let speedValue=parseFloat(document.getElementById('speedSlider').value)/4;
let words=[], wordsLeft=0, totalWordsInLevel=20, spawnedCount=0;
let rocketLaunched=false, lastOutcomeSuccess=false;
let startTime, timerDuration=180;
let level=1;

const speedSlider=document.getElementById('speedSlider');
const laneSlider=document.getElementById('laneSlider');
const speedVal=document.getElementById('speedVal');
const laneVal=document.getElementById('laneVal');
const scoreEl=document.getElementById('score');
const wordsLeftEl=document.getElementById('wordsLeft');
const wpmEl=document.getElementById('wpm');
const wordListSelect=document.getElementById('wordListSelect');
const applyWordsBtn=document.getElementById('applyWords');
const resetWordsBtn=document.getElementById('resetWords');
const timerToggle=document.getElementById('timerToggle');
const timerSlider=document.getElementById('timerSlider');
const timerVal=document.getElementById('timerVal');
const timerDisplay=document.getElementById('timerDisplay');
const quotesEl=document.getElementById('quotes');
const splashScreen=document.getElementById('splashScreen');
const splashBtn=document.getElementById('splashBtn');
const splashText=document.getElementById('splashText');

const rocketOverlay=document.getElementById('rocketOverlay');
const rocketCtx=rocketOverlay.getContext('2d');

/* ===== Audio ===== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const actx = new AudioCtx();
function beep(freq=440,dur=0.07,type='square',vol=0.02){
  const o=actx.createOscillator();
  const g=actx.createGain();
  o.type=type; o.frequency.value=freq;
  o.connect(g); g.connect(actx.destination); g.gain.value=vol;
  o.start(); o.stop(actx.currentTime+dur);
}
function rocketRumble(){
  const g=actx.createGain(); g.gain.value=0.04; g.connect(actx.destination);
  const o1=actx.createOscillator(), o2=actx.createOscillator();
  o1.type='sawtooth'; o2.type='square';
  o1.frequency.setValueAtTime(90, actx.currentTime);
  o2.frequency.setValueAtTime(55, actx.currentTime);
  o1.frequency.exponentialRampToValueAtTime(140, actx.currentTime+0.6);
  o2.frequency.exponentialRampToValueAtTime(70, actx.currentTime+0.6);
  o1.connect(g); o2.connect(g);
  const end=actx.currentTime+0.7;
  g.gain.setValueAtTime(0.045, actx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.01, end);
  o1.start(); o2.start(); o1.stop(end); o2.stop(end);
}
function fireworksPop(){
  [900,1100,1300].forEach((f,i)=>{
    const delay= i*0.08;
    const o=actx.createOscillator(), g=actx.createGain();
    o.type='triangle'; o.frequency.value=f;
    o.connect(g); g.connect(actx.destination);
    g.gain.setValueAtTime(0.03, actx.currentTime+delay);
    g.gain.exponentialRampToValueAtTime(0.0001, actx.currentTime+delay+0.2);
    o.start(actx.currentTime+delay); o.stop(actx.currentTime+delay+0.22);
  });
}

/* ===== word lists ===== */
const wordListsData=[
  {name:"Beginner 0 (2 letter)", words:["an", "as", "at", "in", "is", "it" ]},
  {name:"Beginner 1 (3 letter)", words:["ant", "nan", "nap", "nip", "nit", "pan", "pat", "pin", "pip", "pit", "sat", "sip", "sit", "tan", "tap", "tin", "tip" ]},
  {name:"Easy 2", words:["fish","frog","tree","milk","bird"]},
  {name:"Medium 3", words:["apple","chair","train","horse","glass"]},
  {name:"Hard 4", words:["banana","school","friend","planet","happy"]},
  {name:"Expert 5", words:["elephant","computer","kangaroo","mountain","diamond"]}
];
wordListsData.forEach((wl,i)=>{
  let opt=document.createElement('option');
  opt.value=i; opt.textContent=wl.name;
  wordListSelect.appendChild(opt);
});
let wordBank = [...wordListsData[0].words];
applyWordsBtn.onclick = ()=>{ wordBank=[...wordListsData[parseInt(wordListSelect.value)].words]; resetLevel(true); };
resetWordsBtn.onclick = ()=>{ wordBank=[...wordListsData[0].words]; resetLevel(true); };

/* ===== quotes ===== */
const QUOTES=["You are brave and strong!","Trust yourself—you can do it!","Your kindness makes magic!","Every step shows courage!","You are unstoppable!","Believe in yourself!","Your heart is full of power!","You are wise and brave!","Shine with your own light!","You make the world brighter!"];
let quoteIndex=0;
function rotateQuotes(){ quotesEl.textContent=QUOTES[quoteIndex]; quoteIndex=(quoteIndex+1)%QUOTES.length; }
setInterval(rotateQuotes,5000); rotateQuotes();

/* ===== words & lanes ===== */
function laneX(l){ return l*laneW+laneW/2; }
function randWord(){ return wordBank[Math.floor(Math.random()*wordBank.length)]; }
function randColor(){ const colors=["#0f0","#0ff","#ff0","#f0f","#f60","#0fa","#ff3","#f3f","#3ff","#f06","#f33","#33f","#fff"];
  return colors[Math.floor(Math.random()*colors.length)];
}

/* Random spawn timing */
let nextSpawnAt=0;
function scheduleNextSpawn(){
  nextSpawnAt = Date.now() + 350 + Math.random()*1100;
}
function spawnWord(){
  if(wordsLeft<=0 || spawnedCount>=totalWordsInLevel) return;
  if(Date.now() < nextSpawnAt) return;
  const l = Math.floor(Math.random()*lanes);
  const crowded=words.some(w=>w.lane===l && w.y<80 && !w.fly);
  if(!crowded){
    const text=randWord();
    words.push({text,lane:l,y:-10,progress:0,done:false,speed:speedValue,color:randColor(),fly:false,alpha:1});
    spawnedCount++;
  }
  scheduleNextSpawn();
}

/* ===== Rocket Class (overlay, visuals, audio, movement) ===== */
class Rocket {
  constructor(overlayCanvas, { fireworksPop, rocketRumble, actx }, onFireworksDone){
    this.canvas = overlayCanvas;
    this.ctx = overlayCanvas.getContext('2d');
    this.width = overlayCanvas.width;
    this.height = overlayCanvas.height;

    // Sounds
    this.fireworksPop = fireworksPop;
    this.rocketRumble = rocketRumble;
    this.actx = actx;

    // Placement on the far left (inside overlay space)
    this.baseX = 60;                        // LHS position (kept always visible)
    this.groundY = this.height - 40;        // a bit above bottom of overlay

    // Size / growth
    this.minHeight = 28;                    // short at start
    this.growStep = 10;                     // added height per word
    this.currentHeight = this.minHeight;
    this.targetHeight = this.minHeight;

    // Animation state
    this.launched = false;
    this.inFireworks = false;

    // Launch path randomness
    this._y = this.groundY - this.currentHeight - 12;
    this._tAccum = 0;
    this._lastT = 0;
    this._launchParams = null;

    // Loop
    this._raf = null;
    this.onFireworksDone = onFireworksDone || (()=>{});
    this._startLoop();
  }

  resetForLevel(){
    this.launched = false;
    this.inFireworks = false;
    this.currentHeight = this.minHeight;
    this.targetHeight = this.minHeight;
    this._y = this.groundY - this.currentHeight - 12;
    this._launchParams = null;
  }

  grow(){
    // Smooth growth via target height
    this.targetHeight += this.growStep;
  }

  launch(){
    if(this.launched || this.inFireworks) return;
    this.launched = true;

    // resume context (for autoplay restrictions)
    this.actx.resume && this.actx.resume();
    this.rocketRumble && this.rocketRumble();

    const dir = Math.random()<0.5 ? -1 : 1;              // left/right arc
    const amplitude = 120 + Math.random()*160;           // horizontal wiggle
    const speed = 260 + Math.random()*110;               // vertical speed px/s
    const wobble = 2 + Math.random()*3;                  // sine frequency

    // Start near its ground position on the LHS
    this._y = this.groundY - this.currentHeight - 16;
    this._launchParams = {
      dir, amplitude, speed, wobble,
      baseX: this.baseX + 10
    };
    this._lastT = performance.now();
    // Loop already running; launch is handled in draw/update
  }

  _drawGrounded(){
    const x = this.baseX;
    const yTop = this.groundY - this.currentHeight;

    // Small idle flame
    this.ctx.fillStyle = "orange";
    this.ctx.beginPath();
    this.ctx.ellipse(x+10, this.groundY+6, 4+Math.random()*2, 8+Math.random()*4, 0, 0, Math.PI*2);
    this.ctx.fill();

    // Body
    this.ctx.fillStyle = "red";
    this.ctx.fillRect(x, yTop, 20, this.currentHeight);

    // Nose cone
    this.ctx.fillStyle = "yellow";
    this.ctx.beginPath();
    this.ctx.moveTo(x+10, yTop-12);
    this.ctx.lineTo(x, yTop);
    this.ctx.lineTo(x+20, yTop);
    this.ctx.closePath();
    this.ctx.fill();

    // Tiny smoke puffs
    this.ctx.fillStyle="rgba(200,200,200,0.5)";
    for(let i=0;i<2;i++){
      const sx = x+10 + (Math.random()*10-5);
      const sy = this.groundY + 12 + i*8;
      this.ctx.beginPath();
      this.ctx.arc(sx, sy, 3+Math.random()*3, 0, Math.PI*2);
      this.ctx.fill();
    }
  }

  _drawLaunched(dt){
    if(!this._launchParams) return;

    this._tAccum += dt;
    // Vertical motion
    this._y -= this._launchParams.speed * dt;
    const x = this._launchParams.baseX + Math.sin(this._tAccum*this._launchParams.wobble) * this._launchParams.amplitude * this._launchParams.dir;
    const y = this._y;

    // Flame
    this.ctx.fillStyle="orange";
    this.ctx.beginPath();
    this.ctx.ellipse(x, y+24, 6+Math.random()*5, 12+Math.random()*8, 0, 0, Math.PI*2);
    this.ctx.fill();

    // Body
    this.ctx.fillStyle="red";
    this.ctx.fillRect(x-6, y-20, 12, 40);

    // Nose cone
    this.ctx.fillStyle="yellow";
    this.ctx.beginPath();
    this.ctx.moveTo(x, y-32);
    this.ctx.lineTo(x-10, y-20);
    this.ctx.lineTo(x+10, y-20);
    this.ctx.closePath();
    this.ctx.fill();

    // Smoke puffs
    this.ctx.fillStyle="rgba(200,200,200,0.5)";
    for(let i=0;i<3;i++){
      const sx = x + (Math.random()*20-10);
      const sy = y + 30 + i*10;
      this.ctx.beginPath();
      this.ctx.arc(sx, sy, 6+Math.random()*6, 0, Math.PI*2);
      this.ctx.fill();
    }

    // Off the top? -> fireworks
    if(y < -60){
      this.launched = false;
      this._launchParams = null;
      this._fireworksShow();
    }
  }

  _fireworksShow(){
  this.inFireworks = true;
  const bursts=[];
  const numBursts=4 + Math.floor(Math.random()*3);

  // Use rocket's last x position as base
  const baseX = this._launchParams ? this._launchParams.baseX : this.baseX;
  const baseY = this.groundY - this.currentHeight - 60;

  for(let b=0;b<numBursts;b++){
    const bx = baseX + (Math.random()*60-30); // around rocket
    const by = baseY + (Math.random()*40-20);
    const count = 25 + Math.floor(Math.random()*20);
    const parts=[];
    for(let i=0;i<count;i++){
      const angle = Math.random()*Math.PI*2;
      const speed = 80 + Math.random()*140;
      parts.push({
        x: bx,
        y: by,
        vx: Math.cos(angle)*speed,
        vy: Math.sin(angle)*speed,
        life: 0.9 + Math.random()*0.6,
        color: randColor()
      });
    }
    bursts.push(parts);

    setTimeout(()=>{ this.fireworksPop(); }, b*120);
  }

  const start = performance.now();
  const animate = (now)=>{
    const t = (now - start)/1000;
    this.ctx.clearRect(0,0,this.width,this.height);
    this.ctx.globalCompositeOperation='lighter';

    bursts.forEach(parts=>{
      parts.forEach(p=>{
        if(p.life<=0) return;
        p.vy += 80*0.016;
        p.x += p.vx*0.016;
        p.y += p.vy*0.016;
        p.life -= 0.016;
        const a = Math.max(0, p.life);
        const c = p.color;
        this.ctx.fillStyle=`rgba(${parseInt(c.slice(1,3),16)},${parseInt(c.slice(3,5),16)},${parseInt(c.slice(5,7),16)},${a})`;
        this.ctx.beginPath();
        this.ctx.arc(p.x,p.y,2,0,Math.PI*2);
        this.ctx.fill();
      });
    });

    this.ctx.globalCompositeOperation='source-over';

    if(t<1.5){
      requestAnimationFrame(animate);
    } else {
      this.ctx.clearRect(0,0,this.width,this.height);
      this.inFireworks=false;
      this.onFireworksDone && this.onFireworksDone();
    }
  };

  requestAnimationFrame(animate);
}



  _startLoop(){
    const loop = (now)=>{
      // Smooth growth tween
      this.currentHeight += (this.targetHeight - this.currentHeight)*0.18;
      if(Math.abs(this.currentHeight - this.targetHeight) < 0.05){
        this.currentHeight = this.targetHeight;
      }

      // Clear overlay each frame
      this.ctx.clearRect(0,0,this.width,this.height);

      if(this.launched){
        if(!this._lastT) this._lastT = now;
        const dt = (now - this._lastT)/1000;
        this._lastT = now;
        this._drawLaunched(dt);
      } else if(!this.inFireworks){
        // Draw grounded rocket if not in fireworks
        this._drawGrounded();
      }

      this._raf = requestAnimationFrame(loop);
    };
    this._raf = requestAnimationFrame(loop);
  }
}

/* ===== level control ===== */
let rocket; // single instance
function resetLevel(keepLevelNumber=false){
  if(!keepLevelNumber) level=1;
  score=0; lives=3; running=true; gameOver=false; words=[]; rocketLaunched=false; lastOutcomeSuccess=false;
  lanes=parseInt(laneSlider.value); laneW=W/lanes;
  speedValue=parseFloat(speedSlider.value)/4; 
  totalWordsInLevel = wordBank.length*4;
  spawnedCount=0;
  wordsLeft=totalWordsInLevel;
  startTime = Date.now();
  timerDuration=parseInt(timerSlider.value)*60*1000;
  updateScore();
  scheduleNextSpawn();
  draw();

  // (Re)create rocket if needed, else reset it
  if(!rocket){
    rocket = new Rocket(
      rocketOverlay,
      { fireworksPop, rocketRumble, actx },
      () => { splashLevelOver(true); } // after fireworks
    );
  } else {
    rocket.resetForLevel();
  }
}
function startNextLevel(){
  level++;
  running=true; gameOver=false; words=[]; rocketLaunched=false; lastOutcomeSuccess=false;
  spawnedCount=0;
  wordsLeft=totalWordsInLevel;
  startTime=Date.now();
  scheduleNextSpawn();
  rocket && rocket.resetForLevel();
}

/* ===== scoreboard ===== */
function updateScore(){
  scoreEl.textContent=score;
  wordsLeft = Math.max(0, wordsLeft);
  wordsLeftEl.textContent=wordsLeft;
}

/* ===== draw ===== */
function drawWord(w){
  const x=laneX(w.lane), y=w.y;
  ctx.font='28px monospace'; ctx.textAlign='center';
  let typed=w.text.slice(0,w.progress),rest=w.text.slice(w.progress);
  if(w.fly){
    w.y-=6; w.alpha-=0.07;
    ctx.fillStyle=`rgba(255,255,255,${w.alpha})`; ctx.fillText(w.text,x,y);
    if(w.alpha<=0) w.done=true; return;
  }
  if(w.done && !w.fly){
    ctx.fillStyle="#f00"; ctx.save(); ctx.translate(x,y); ctx.rotate(Math.PI); ctx.fillText(w.text,0,0); ctx.restore(); return;
  }
  ctx.fillStyle='#fff'; ctx.fillText(typed,x-ctx.measureText(rest).width/2,y);
  ctx.fillStyle=w.color; ctx.fillText(rest,x+ctx.measureText(typed).width/2,y);
}
function draw(){
  ctx.fillStyle="#000"; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle="#0f0"; ctx.lineWidth=1;
  for(let l=1;l<lanes;l++){ ctx.beginPath(); ctx.moveTo(l*laneW+0.5,0); ctx.lineTo(l*laneW+0.5,H); ctx.stroke(); }
  ctx.beginPath(); ctx.moveTo(0,floorY+12); ctx.lineTo(W,floorY+12); ctx.stroke();
  for(const w of words) drawWord(w);
  ctx.fillStyle="#0f0"; ctx.font='16px monospace'; ctx.textAlign='left'; ctx.fillText(`LIVES: ${lives}`,8,16);
  ctx.textAlign='center';
  ctx.fillStyle="#ff0"; ctx.fillRect(laneX(playerLane)-15,floorY-12,30,12);
  ctx.fillStyle="#0f0"; ctx.textAlign='right'; ctx.fillText(running?'RUN':'PAUSE',W-8,16);
}

/* ===== game step ===== */
function step(){
  if(!running){ draw(); requestAnimationFrame(step); return; }

  if(timerToggle.checked){
    const elapsed=Date.now()-startTime, remaining=Math.max(0,timerDuration-elapsed);
    timerDisplay.textContent=Math.floor(remaining/60000)+":"+("0"+Math.floor((remaining%60000)/1000)).slice(-2);
    if(remaining<=0){ gameOver=true; running=false; lastOutcomeSuccess=false; splashLevelOver(false); return; }
  }

  spawnWord();

  for(const w of words){ if(!w.done && !w.fly) w.y+=speedValue; }

  // Missed words that reach bottom
  for(const w of words){
    if(!w.done && !w.fly && w.y>=floorY){
      lives--; w.done=true; wordsLeft = Math.max(0, wordsLeft-1);
      beep(140,0.08);
      if(lives<=0){ gameOver=true; running=false; lastOutcomeSuccess=false; splashLevelOver(false); }
    }
  }

  // Level completion
if(!gameOver){
  if(wordsLeft===0){
    running=false;
    lastOutcomeSuccess = (lives>0);
    if(lastOutcomeSuccess && !rocketLaunched){
      rocketLaunched = true;
      rocket && rocket.launch(); // splash will be triggered by rocket's onFireworksDone
    } else if(!lastOutcomeSuccess){
      splashLevelOver(false); // only immediate game over
    }
  }
}

  updateScore();
  draw();
  requestAnimationFrame(step);
}

/* ===== typing ===== */
function wordInPlayerLane(){
  const candidates = words.filter(w=>!w.done && !w.fly && w.lane===playerLane);
  candidates.sort((a,b)=>b.y-a.y);
  return candidates[0]||null;
}
document.addEventListener('keydown',(e)=>{
  if(e.key==='1'||e.key==='ArrowLeft'){ playerLane=Math.max(0,playerLane-1); beep(300,0.02); return; }
  if(e.key==='2'||e.key==='ArrowRight'){ playerLane=Math.min(lanes-1,playerLane+1); beep(300,0.02); return; }
  if(e.code==='Space'){ running=!running; if(running) actx.resume(); return; }
  if(e.key==='0'){ splashScreen.style.display="none"; resetLevel(false); return; }
  if(e.key.length===1 && /[a-z]/i.test(e.key)){
    const target = wordInPlayerLane();
    if(!target){ beep(180,0.03); return; }
    const expected = target.text[target.progress] || '';
    if(e.key.toLowerCase()===expected){
      target.progress++; beep(520,0.03);
      if(target.progress>=target.text.length){
        target.fly=true; target.done=true; wordsLeft = Math.max(0, wordsLeft-1);
        score+=target.text.length;
        updateScore();

        // GROW ROCKET on each completed word
        rocket && rocket.grow();

        // If last word just finished, trigger rocket launch only
        if(wordsLeft===0 && !gameOver){
          running=false;
          lastOutcomeSuccess = (lives>0);
          if(lastOutcomeSuccess && !rocketLaunched){
            rocketLaunched = true;
            rocket && rocket.launch(); // splash will be triggered by rocket's onFireworksDone
          } else if(!lastOutcomeSuccess){
            splashLevelOver(false); // only immediate game over
          }
        }
      }
    }else{ beep(180,0.03); }
  }
});

/* ===== splash ===== */
function splashLevelOver(success){
  splashText.textContent = success ? `LEVEL ${level} COMPLETE!` : "GAME OVER! Try Again";
  splashScreen.style.display="flex";
}
splashBtn.onclick = ()=>{
  splashScreen.style.display="none";
  if(lastOutcomeSuccess){
    startNextLevel();
  }else{
    resetLevel(false);
  }
  running=true; gameOver=false; rocketLaunched=false;
};

/* ===== UI Events ===== */
speedSlider.oninput=()=>{ speedValue=parseFloat(speedSlider.value)/4; speedVal.textContent=speedSlider.value; };
laneSlider.oninput=()=>{ 
  lanes=parseInt(laneSlider.value); 
  laneW=W/lanes; 
  laneVal.textContent=lanes; 
  // Ensure player lane is within new lane count
  playerLane = Math.min(playerLane, lanes-1);
  draw(); // Redraw to show updated lane indicator
};
timerSlider.oninput=()=>{ timerDuration=parseInt(timerSlider.value)*60*1000; timerVal.textContent=timerSlider.value+" min"; };

/* ===== init ===== */
resetLevel(false);
draw(); // Draw immediately to show player lane indicator
step();
})();
</script>
</body>
</html>
